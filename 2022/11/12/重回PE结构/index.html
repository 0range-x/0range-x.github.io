<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="baidu-site-verification" content="code-n4alrUzr1E" />
    <meta name="description" content="去年学了一遍pe，但是没有用代码实现，导致对pe的理解非常浅，今年又重新学了一遍，旨在加强对代码的掌握，并不是从0开始，只是方便本人理解，因此笔记内容很残缺，可以参考去年的笔记一起看。 代码仓库： https:&#x2F;&#x2F;github.com&#x2F;0range-x&#x2F;windows&#x2F;tree&#x2F;main&#x2F;pe PE头解析 4gb &#x3D; 2^32 ，寻址长度， 对齐的目的：查找速度更快，用空间换时间 硬盘对齐：200">
<meta property="og:type" content="article">
<meta property="og:title" content="pe解析">
<meta property="og:url" content="https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="0r@nge の窝">
<meta property="og:description" content="去年学了一遍pe，但是没有用代码实现，导致对pe的理解非常浅，今年又重新学了一遍，旨在加强对代码的掌握，并不是从0开始，只是方便本人理解，因此笔记内容很残缺，可以参考去年的笔记一起看。 代码仓库： https:&#x2F;&#x2F;github.com&#x2F;0range-x&#x2F;windows&#x2F;tree&#x2F;main&#x2F;pe PE头解析 4gb &#x3D; 2^32 ，寻址长度， 对齐的目的：查找速度更快，用空间换时间 硬盘对齐：200">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220925134144246.png">
<meta property="og:image" content="https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220926143523309.png">
<meta property="og:image" content="https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220926141455399.png">
<meta property="og:image" content="https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220926134140064.png">
<meta property="og:image" content="https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220928223839801.png">
<meta property="og:image" content="https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220929092350689.png">
<meta property="og:image" content="https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220929092703113.png">
<meta property="og:image" content="https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220929092703113.png">
<meta property="og:image" content="https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220929002230234.png">
<meta property="og:image" content="https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220929002252829.png">
<meta property="og:image" content="https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221004004812121.png">
<meta property="og:image" content="https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221004005156880.png">
<meta property="og:image" content="https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221004005436127.png">
<meta property="og:image" content="https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221004005453377.png">
<meta property="og:image" content="https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221004005944989.png">
<meta property="og:image" content="https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221004011229479.png">
<meta property="og:image" content="https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221005132256650.png">
<meta property="og:image" content="https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221005201309769.png">
<meta property="og:image" content="https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221006155541354.png">
<meta property="og:image" content="https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221006175628766.png">
<meta property="og:image" content="https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221006175745262.png">
<meta property="og:image" content="https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221007101925829.png">
<meta property="og:image" content="https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221007124323902.png">
<meta property="og:image" content="https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221008133831339.png">
<meta property="og:image" content="https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221008133346306.png">
<meta property="og:image" content="https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221008134133377.png">
<meta property="og:image" content="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210408162001903.png">
<meta property="og:image" content="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210408162937094.png">
<meta property="article:published_time" content="2022-11-11T17:16:10.000Z">
<meta property="article:modified_time" content="2022-11-12T10:48:32.296Z">
<meta property="article:author" content="0r@nge">
<meta property="article:tag" content="基础">
<meta property="article:tag" content="windows">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220925134144246.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/icon.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/icon.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/icon.jpg">
        
      
    
    <!-- title -->
    <title>pe解析</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/true" title="0r@nge の窝" type="application/atom+xml" />
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/categories/">Categories</a></li><!--
     --><!--
       --><li><a href="/links">Links</a></li><!--
     --><!--
       --><li><a href="/atom.xml">RSS</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2022/11/12/inject/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2022/03/31/%E6%B5%85%E6%9E%90%E6%9D%80%E8%BD%AF/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/&text=pe解析"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/&title=pe解析"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/&is_video=false&description=pe解析"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=pe解析&body=Check out this article: https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/&title=pe解析"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/&title=pe解析"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/&title=pe解析"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/&title=pe解析"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/&name=pe解析&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/&t=pe解析"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#PE%E5%A4%B4%E8%A7%A3%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">PE头解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dos%E5%A4%B4"><span class="toc-number">1.0.1.</span> <span class="toc-text">dos头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NT-headers"><span class="toc-number">1.0.2.</span> <span class="toc-text">NT_headers</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Image-File-Header-%E6%A0%87%E5%87%86PE%E5%A4%B4"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">Image_File_Header (标准PE头)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Image-Optional-Header-%E5%8F%AF%E9%80%89pe%E5%A4%B4"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">Image_Optional_Header(可选pe头)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">节表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FileBuffer-%E2%80%93-gt-ImageBuffer"><span class="toc-number">3.</span> <span class="toc-text">FileBuffer –&gt; ImageBuffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%8A%82%E7%A9%BA%E7%99%BD%E5%8C%BA%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81"><span class="toc-number">4.</span> <span class="toc-text">代码节空白区添加代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E6%93%8D"><span class="toc-number">4.0.0.1.</span> <span class="toc-text">实操</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E7%A9%BA%E7%99%BD%E5%8C%BA%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81"><span class="toc-number">5.</span> <span class="toc-text">任意代码空白区添加代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E8%8A%82-%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81"><span class="toc-number">6.</span> <span class="toc-text">新增节-添加代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%A4%A7%E8%8A%82%E2%80%93%E5%90%88%E5%B9%B6%E8%8A%82%E2%80%93%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95"><span class="toc-number">7.</span> <span class="toc-text">扩大节–合并节–数据目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E2%80%93%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93"><span class="toc-number">8.</span> <span class="toc-text">静态链接库–动态链接库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8dll"><span class="toc-number">8.1.</span> <span class="toc-text">使用dll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E8%A2%AB%E7%9B%B4%E6%8E%A5%E5%88%86%E6%9E%90%E5%88%B0dll%E5%87%BD%E6%95%B0"><span class="toc-number">8.2.</span> <span class="toc-text">避免被直接分析到dll函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E8%A1%A8"><span class="toc-number">9.</span> <span class="toc-text">导出表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8"><span class="toc-number">10.</span> <span class="toc-text">重定位表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E5%AF%BC%E5%87%BA%E8%A1%A8%E2%80%93%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8"><span class="toc-number">11.</span> <span class="toc-text">移动导出表–重定位表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IAT%E8%A1%A8"><span class="toc-number">12.</span> <span class="toc-text">IAT表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E8%A1%A8"><span class="toc-number">13.</span> <span class="toc-text">导入表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E5%AF%BC%E5%85%A5%E8%A1%A8"><span class="toc-number">14.</span> <span class="toc-text">绑定导入表</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        pe解析
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">0r@nge</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-11-11T17:16:10.000Z" itemprop="datePublished">2022-11-12</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/windows/">windows</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/windows/" rel="tag">windows</a>, <a class="tag-link-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a>
    </div>



    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>去年学了一遍pe，但是没有用代码实现，导致对pe的理解非常浅，今年又重新学了一遍，旨在加强对代码的掌握，并不是从0开始，只是方便本人理解，因此笔记内容很残缺，可以参考去年的笔记一起看。</p>
<p>代码仓库：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/0range-x/windows/tree/main/pe">https://github.com/0range-x/windows/tree/main/pe</a></p>
<h2 id="PE头解析"><a href="#PE头解析" class="headerlink" title="PE头解析"></a>PE头解析</h2><p> 4gb = 2^32 ，寻址长度，</p>
<p>对齐的目的：查找速度更快，用空间换时间</p>
<p>硬盘对齐：200h</p>
<p>内存对齐：1000h</p>
<p>所以程序在内存执行的时候，会在内存中扩展。节和节之间用0填充。</p>
<p>dos头、pe头、pe可选头</p>
<h4 id="dos头"><a href="#dos头" class="headerlink" title="dos头"></a>dos头</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e_magic			//5A 4D</span><br><span class="line">e_lfanew 		//00 00 00 E8       pe头相对于文件的偏移，用于定位pe文件</span><br></pre></td></tr></table></figure>

<p>从e8开始就是pe开始的地方，对应的  50 45  对应的ascii字符是pe，</p>
<h4 id="NT-headers"><a href="#NT-headers" class="headerlink" title="NT_headers"></a>NT_headers</h4><p>包含signature+标准pe头(Image_File_Header)+<strong>可选pe头(IMAGE_OPTIONAL_HEADER)</strong></p>
<p> signature为50 45 00 00 ，找完后不找nt_headers，去找 Image_File_Header， </p>
<h5 id="Image-File-Header-标准PE头"><a href="#Image-File-Header-标准PE头" class="headerlink" title="Image_File_Header (标准PE头)"></a>Image_File_Header (标准PE头)</h5><p>大小确定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WORD		Machine					//86 64 	//可以在什么机器上运行 </span><br><span class="line">WORD		NumberOfSections		//07 00		//文件中存在的节的总数，如果要新增或者合并节需要修改该字段</span><br><span class="line">DWORD		TimeDateStamp			//2b 8c 95 22		//文件编译时间戳</span><br><span class="line"></span><br><span class="line">WORD		SizeOfOptionalHeader	//f0 00	 	可选pe头的大小，32位pe默认为E0h,64位pe为f0h，大小可以自定义</span><br></pre></td></tr></table></figure>





<h5 id="Image-Optional-Header-可选pe头"><a href="#Image-Optional-Header-可选pe头" class="headerlink" title="Image_Optional_Header(可选pe头)"></a>Image_Optional_Header(可选pe头)</h5><p>大小不确定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">WORD		Magic						//0b 02   //10b为32位的文件，20b为64位的文件</span><br><span class="line">DWORD		SizeOfCode					//00 60 02 00</span><br><span class="line">DWORD		SizeOfInitializedData		//00 00 03 00</span><br><span class="line">DWORD		SizeOfUNinitializedData		//00 00 00 00</span><br><span class="line">DWORD		AddressOfEntryPoint			//90 1b 00 00		//程序入口  != 代码入口 ，程序在内存中真正的运行地址为   基址+oep (入口点)</span><br><span class="line"></span><br><span class="line">DWORD		BaseOfCode					//00 10 00 00</span><br><span class="line">DWORD		BaseOfData					//00 00 00 40</span><br><span class="line">DWORD		ImageBase					//01 00 00 00 		//内存映像基址</span><br><span class="line">DWORD		SectionAlignment			//00 10 00 00		//内存对齐，内存中整个pe文件的尺寸，可以比实际值大，但必须是SectionAlignment的整数倍</span><br><span class="line">DWORD		FileAlignment				//00 10 00 00		//文件对齐</span><br><span class="line">DWORD		SizeofImage					//00 70 05 00		//内存中 整个PE文件的映射的大小，可以比实际的值大，但必须是SectionAlignment的整数倍</span><br><span class="line">DOWRD		SizeofHeaders				//00 10 00 00		//所有头(DOS+...+PE标记+标准PE+可选PE)+节表 按照文件对齐后lao 否则加载会出错</span><br><span class="line">DWORD		SizeOfStackReverse			//00 00 08 00</span><br><span class="line">DWORD		SizeofStackCommit			//00 00 00 00</span><br><span class="line">DWORD		SizeOfHeapReverse			//00 10 01 00</span><br><span class="line">DWORD		SizeOfHeapCommit 			//00 00 00 00</span><br></pre></td></tr></table></figure>

<p>将pe文件从硬盘中读到内存中，是原封不动的读进去，拷贝到内存中，存储到 <code>FileBuffer</code>,但这个时候还没有办法运行，需要peloader修改 <code>FileBuffer</code>为内存中可执行的过程，就是内存拉伸的过程。写到的地址(内存运行的起始地址)叫<code>ImageBuffer</code>（文件映像）</p>
<p>修改OEP</p>
<p>pe后面的20个字节为标准pe头</p>
<p>剩下的为可选pe头，从0b 02 开始。  修改 <code>ImageBase</code>(程序入口点 EntryBase)，保存后程序仍然正常运行</p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220925134144246.png" alt="image-20220925134144246"></p>
<h2 id="节表"><a href="#节表" class="headerlink" title="节表"></a>节表</h2><p>相当于节中的目录 描述  节中的概要信息</p>
<p>定位节表：</p>
<p>可选pe头的大小是不确定的，标准pe头里有个成员变量     <code>SizeofOptionalHeader</code> 表示可选pe头的大小，32位默认是 e0， 64位默认是 f0</p>
<p>dos+4+pe+可选pe</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifanew + 4(signature) + 20(标准pe头大小) +E0(32位的 SizeOfOptionalHeader) </span><br></pre></td></tr></table></figure>

<p>Image_File_Header（标准pe） 里的 <code>NumberOfSections</code> 是节表的数量</p>
<p>pe后面的第二个成员，就是节表数量，这里是5个。</p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220926143523309.png" alt="image-20220926143523309"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define IMAGE_SIZEOF_SHORT_NAME				8</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220926141455399.png" alt="image-20220926141455399"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.Name 占8个字节，一般情况下是以&quot;\0&quot;结尾的ASCII码字符串来标识的名词。但是该名称并不遵守以&quot;\0&quot;结尾的规律，如果不是以 &quot;\0&quot;结尾，系统会截取8个字节的长度进行处理，有时候会导致越界乱码。</span><br><span class="line">所以不用`char*`来解析， char* 会自动找 &quot;\0&quot;，用数组来解析。</span><br><span class="line"></span><br><span class="line">2.Misc.VirtualSize表示在文件对齐前，实际的大小，该值可以修改，不影响，所以不一定准确</span><br><span class="line"></span><br><span class="line">3.VirtualAddress 是节区在内存中的偏移地址，加上 ImageBase 才是在内存中的真正地址。 VirtualAddress是距离 ImageBase（ImageBuffer的dos头）的距离</span><br><span class="line"></span><br><span class="line">4.SizeOfRawData 节在文件中对齐后的尺寸</span><br><span class="line"></span><br><span class="line">5.PointerToRawData 节区在文件中的偏移，即在文件中距离dos头的距离</span><br></pre></td></tr></table></figure>

<p>代码空白区一般指的是  VirtualSize – SizeOfRawData 中的大小，</p>
<h2 id="FileBuffer-–-gt-ImageBuffer"><a href="#FileBuffer-–-gt-ImageBuffer" class="headerlink" title="FileBuffer –&gt; ImageBuffer"></a>FileBuffer –&gt; ImageBuffer</h2><p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220926134140064.png" alt="image-20220926134140064"></p>
<p>FileBuffer 是在文件中的内容，Image Buffer是在内存中的内容，在内存中扩展一下</p>
<p>sizeofheaders 包括 dos头+标准PE头+可选PE头+节表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.根据 SizeofImage 的大小，开辟一块缓冲区（ImageBuffer）</span><br><span class="line">2.根据SizeOfHeader 的大小，将头信息从FileBuffer 拷贝到 ImageBuffer</span><br><span class="line">3.根据节表的信息循环将 FileBuffer 中的节拷贝到 ImageBuffer</span><br><span class="line">复制到什么地方，由节中的 VirtualAddress 决定，每个节copy Siz</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>将Filebuffer 读到 ImageBuffer，先分配 SizeOfImage 大小的内存，在可选pe头里</p>
<p>转VirtualAddress eg:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.  501234 - 500000(ImageBase) = 1234 (RVA)</span><br><span class="line">2.  1234 &gt; VirtualAddress(1000)</span><br><span class="line">	1234 &lt; VirtualAddress + misc.VirtualAddress</span><br><span class="line">3.	1234 - 1000 = 234</span><br><span class="line">4.	400(PointerToRawData) + 234 =   (在文件中的地址 )</span><br></pre></td></tr></table></figure>



<h2 id="代码节空白区添加代码"><a href="#代码节空白区添加代码" class="headerlink" title="代码节空白区添加代码"></a>代码节空白区添加代码</h2><p>关于修正E8的理解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">公式：X = 要跳转的地址 - (E8当前的地址 + 5)；</span><br><span class="line">    要跳转的地址，就是我们要加入代码MessageBox的地址；</span><br><span class="line">    然后要减去E8当前的地址+5的位置，这里不是太好理解；</span><br><span class="line">    我们的目的是要将E8后面的4个字节计算出来，然后写入到E8后面，也就是公式中X；</span><br><span class="line">    上面公式E8当前地址+5 ，而在此情况要定位到这个位置就要从代码的Dos开始通过指针相加；</span><br><span class="line">    进行位置偏移到E8当前地址+5的位置；</span><br><span class="line">    所以定位codeBegin的位置是：pImageBuffer指针最开始的位置（Dos头位置）通过内存中偏移的宽度移动到第一个节表的位置；</span><br><span class="line">    也就是上面的pSectionHeader-&gt;VirtualAddress 操作形式；</span><br><span class="line">    然后再偏移第一个节表在内存中对齐前实际的宽度（尺寸）pSectionHeader-&gt;Misc.VirtualSize；</span><br><span class="line">    上述一番操作之后就到了第一个节表没有对齐前的位置，这个位置就是我们可以添加ShellCode代码的起始位置；</span><br><span class="line">    到了添加ShellCode代码的起始位置之后，就要想办法添加E8位置后面的4个字节，此时根据ShellCode代码的宽度；</span><br><span class="line">    进行计算，确认0x6A 00 0x6A 00 0x6A 00 0x6A 00 E8 00 00 00 00 刚好向后面数13个位置，按照十六进制看；</span><br><span class="line">    就是0xD，所以在codeBegin偏移0xD个位置即可到达E9的位置，这也就是我们说的(E8当前的地址 + 5);</span><br><span class="line">    到了上面的位置之后，由于我们最终是需要在程序运行之后在内存中添加ShellCode代码；所以这里一定要计算出；</span><br><span class="line">    其准确的偏移地址，这样不管怎么拉伸到哪个位置，都能准确找到位置；</span><br><span class="line">    注意：这里需要注意一点理解，上面说的pImageBuffer这个是我们加载程序到我们申请的内存中，绝不是程序在；</span><br><span class="line">    运行中的那个内存，这里一定要理解清楚，她们是不一样的，理解了这个就能理解上面代码为什么要减去Dos头的；</span><br><span class="line">    首地址，(DWORD)(codeBegin + 0xD) - (DWORD)pImageBuffer)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关于e9修正的理解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">公式：X = 要跳转的地址 - (E9当前的地址 + 5)</span><br><span class="line">   这里同样是要计算出E9后面4个字节的地址，我们的目的是在这里添加OEP的地址，让其执行完成MessageBox之后跳转；</span><br><span class="line">   OEP的地址，那么这里就要先计算出OEP地址，就是pOptionHeader-&gt;ImageBase + pOptionHeader-&gt;AddressOfEntryPoint；</span><br><span class="line">   再减去(E9当前的地址 + 5) 0x6A 00 0x6A 00 0x6A 00 0x6A 00 E8 00 00 00 00 E9 00 00 00 00；</span><br><span class="line">   (DWORD)codeBegin + SHELLCODELENGTH 就是加上ShellCode总长度，偏移完成之后减去ImageBuffer首地址再加上ImageBase；</span><br></pre></td></tr></table></figure>

<p>修正oep：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修正OEP好理解，就是定位到OEP地址，然后直接通过codeBegin地址减去pImageBuffer的首地址即可</span><br></pre></td></tr></table></figure>





<h5 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h5><p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220928223839801.png" alt="image-20220928223839801"></p>
<p>messagebox 的地址为  75 5e 06 60</p>
<p>找硬编码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">6A  00</span><br><span class="line">6A  00</span><br><span class="line">6A 	00</span><br><span class="line">6A 	00</span><br><span class="line">E8 	00 00 00 00 ；call</span><br><span class="line">E9 	00 00 00 00 ；jmp</span><br></pre></td></tr></table></figure>



<p>查找pe信息   win10 的  32位的calc</p>
<p>需要注意的字段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AddressOfEntryPoint:	1B90</span><br><span class="line">ImageBase:				400000</span><br><span class="line">Section Alignment:		1000</span><br><span class="line">File Alignment:			200</span><br><span class="line"></span><br><span class="line">Section:				.text</span><br><span class="line">VirtualSize:			f2c（对齐前的长度）</span><br><span class="line">VirtualAddress:			1000（内存中的偏移）</span><br><span class="line">PointerToRawData:		400 （文件中的偏移）</span><br></pre></td></tr></table></figure>

<p>代码空白区的起始地址为 ： PointerToRawData+VirtualSize</p>
<p>计算FileBuffer 代码节的结束地址</p>
<p>Formulas: PointerToRawData + VirtualSize = 132c</p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220929092350689.png" alt="image-20220929092350689"></p>
<p>在空白区填充代码的硬编码</p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220929092703113.png" alt="image-20220929092703113"></p>
<p>当程序中的文件对齐和内存对齐不一致时需要进行转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foa_shellcodeAddr - PointerToRawData + VirtualAddress + ImageBase = Rva_shellcodeAddr</span><br></pre></td></tr></table></figure>

<p>132c - 400 + 1000 + 400000 = 40192c</p>
<p>e8和e9 调用地址 = 跳转的目标地址- （指令地址+ 指令长度）</p>
<p>计算E8后的值：</p>
<p>e8后的值= 真正跳转的地址 - E8 下一条指令地址</p>
<p>ImageBuffer 中 插入代码的地址（rva_shellcodeaddr） ： ImageBase + Virtualsize+ VirtualAddress = 400000 +f2c  +1000 = 401f2c </p>
<p>插入了 messagebox 对应的硬编码  8 个字节，所以 E8 的地址为   401f2c + 8 =  421f34</p>
<p>e8下一行地址为 ： 401f34(内存中的值) +5 = 401f39</p>
<p>E8 后的值： 75 94 06 60（messagebox函数运行时起始地址）-401f39（e8下一行地址）= 7553 E727</p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220929092703113.png" alt="image-20220929092703113"></p>
<p>计算e9后的值：</p>
<p>真正要跳转的地址： ImageBase + EntryPoint = 400000 +1b90 = 401b90</p>
<p>E9的下一条指令的地址：401f39(e8下一行地址)+5 = 401f3e</p>
<p>e9后的值 = 401b90 - 401f3e=  ff ff fc 52</p>
<p>修改 OEP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OEP = RVA_shellcodeAddr - ImageBase</span><br></pre></td></tr></table></figure>

<p>421f34 - 400000 = 21f34</p>
<p>21860 改为 227b8</p>
<p>60 18 02  b8 27 02</p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220929002230234.png" alt="image-20220929002230234"></p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220929002252829.png" alt="image-20220929002252829"></p>
<h2 id="任意代码空白区添加代码"><a href="#任意代码空白区添加代码" class="headerlink" title="任意代码空白区添加代码"></a>任意代码空白区添加代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 根据sizeofIMage分配空间</span><br><span class="line">2. copy 头  （sizeofheaders）</span><br><span class="line">3.根据节表中的PointerToRawData 确定文件中开始拷贝的位置，根据节表属性VirtualAddress 知道要复制到的位置</span><br><span class="line">4. 拷贝节的大小， 拷贝sizeofRawData</span><br><span class="line">5.申请new buffer  分配 最后一个节起始大小 + sizeofRawData()</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="新增节-添加代码"><a href="#新增节-添加代码" class="headerlink" title="新增节-添加代码"></a>新增节-添加代码</h2><p>判断</p>
<p>sizeofHeader - （DOS + 垃圾数据 + PE标记 + 标准PE头 + 可选PE头 + 已存在节表）&gt;= 2个节表的大小</p>
<p>因为节表中需要有空间装得下2个节表，其中一个节表是我们自己新增的，其中一个是00填充(windows判断一个结构体结束，是判断和结构体相同大小的空间 都为0，规定，写为1也可以运行，但不知道写为几不能运行)</p>
<p>节表中的信息指的是  .text   .rdata   .data  .rsrc 中的数据</p>
<p>需要修改的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.添加一个新的节</span><br><span class="line">2.在新增节后面  填充一个节大小的0000 （40个字节）</span><br><span class="line">3.修改pe头中节的数量    （4+1）</span><br><span class="line">4.修改sizeofIMage的大小 （在可选pe头里）</span><br><span class="line">5.在原有数据的最后，新增一个节的数据（内存对齐的整数倍）</span><br><span class="line">6.修正新增节表的属性</span><br></pre></td></tr></table></figure>

<p>修改virtualSize时， 直接修改为和文件中对齐后的长度一样，1000h</p>
<p>VirtualAddreess + sizeofRawData                      //最后一个节开始的地方 + max （Virtualsize，sizeofRawdata）</p>
<p>加完以后按照内存对齐</p>
<p>如果节后面有编译器新增的数据，把dos头后面的stub 删除，将NT头提前，修改 e_lfanew</p>
<p>3.修改sizeofimage</p>
<p>因为节在内存对齐是 1000</p>
<p>6000 + 1000 = 7000 </p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221004004812121.png" alt="image-20221004004812121"></p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221004005156880.png" alt="image-20221004005156880"></p>
<p>新增一个节表的数据</p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221004005436127.png" alt="image-20221004005436127"></p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221004005453377.png" alt="image-20221004005453377"></p>
<p>修正节表数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.VirtualAddress   按照上一个对齐</span><br><span class="line">2.sizeofRawData</span><br><span class="line">3.PointerToRawData</span><br><span class="line">上一个节开始位置+节对齐后的大小 = RAW大小 + RAW偏移</span><br></pre></td></tr></table></figure>



<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221004005944989.png" alt="image-20221004005944989"></p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221004011229479.png" alt="image-20221004011229479"></p>
<h2 id="扩大节–合并节–数据目录"><a href="#扩大节–合并节–数据目录" class="headerlink" title="扩大节–合并节–数据目录"></a>扩大节–合并节–数据目录</h2><p>扩大节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.拉伸到内存</span><br><span class="line">2.分配一块新的空间： sizeofImage + Ex</span><br><span class="line">3.将最后一个节的sizeofRawData 和VirtualSize 改成N</span><br><span class="line">SizeOfRawData = VirtualSize = N</span><br><span class="line">N = (SizeOfRawData 或者 VirtualSize 内存对齐后的值) + Ex</span><br><span class="line">4.修改SizeOfImage的大小</span><br><span class="line">SizeofImage = SizeofImage + Ex</span><br></pre></td></tr></table></figure>







<p>合并节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.取最后一个节中 （sizeofRawData 和 VirtualSize）的值，谁大就取谁</span><br><span class="line">即  max = sizeofRawData &gt; VirtualSize &gt; SizeOfRawDzata : VirtualSize</span><br><span class="line">2.通过最后一个节的VirtualAddress + 上面的道德最后一个节max - 拉伸后的SizeOfHeaders内存对齐后的大小</span><br><span class="line">3.SizeifRawData = VirtualSize </span><br><span class="line">4.numberofSections = 1</span><br></pre></td></tr></table></figure>







<h2 id="静态链接库–动态链接库"><a href="#静态链接库–动态链接库" class="headerlink" title="静态链接库–动态链接库"></a>静态链接库–动态链接库</h2><h3 id="使用dll"><a href="#使用dll" class="headerlink" title="使用dll"></a>使用dll</h3><p>隐式链接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.将*.dll *.lib 放到工程目录下面</span><br><span class="line">2.将 #pragma comment(lib,&quot;DLLming.lib&quot;) 添加到调用文件中</span><br><span class="line">3.加入函数的声明</span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) __stdcall int Plus(int x,int y);</span><br><span class="line">说明：</span><br><span class="line">__declspec(dllimport) 告诉编译器此函数为导入函数</span><br><span class="line">__stdcall 平衡堆栈</span><br></pre></td></tr></table></figure>



<p>显式链接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.定义函数指针</span><br><span class="line">//typedef int</span><br><span class="line">2.声明函数指针变量</span><br><span class="line">3.动态加载dll到内存中     //告诉编译器用到哪个dll，加载到exe内存</span><br><span class="line">LoadLibrary(&quot;DLLDemo.dll&quot;)</span><br><span class="line">4.获取函数地址</span><br><span class="line">GetProcessAddress</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>Handle  HMODULE  HINSTANCE  HWND  都表示无符号类型的整数  4个字节</p>
<h3 id="避免被直接分析到dll函数"><a href="#避免被直接分析到dll函数" class="headerlink" title="避免被直接分析到dll函数"></a>避免被直接分析到dll函数</h3><p>使用 *.def 文件 达到隐藏函数名的目的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPORTS</span><br><span class="line">Plus  @12   //plus函数的导出序号是12</span><br><span class="line">Sub	  @15   //导出序号15</span><br></pre></td></tr></table></figure>



<h2 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h2><p>真正导出表的结构</p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221005132256650.png" alt="image-20221005132256650"></p>
<p>只要见到RVA的地方，先转成foa 再去找</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AddressOfFUnctions 指向了一张表，表里存储着pe 所有导出函数的地址</span><br><span class="line">AddressOfNames 存储着所有导出函数的名字的地址</span><br><span class="line">AddressOfNameOrdinals （函数序号表） + base（起始序号） 才是真正的序号表</span><br><span class="line">按照序号 来找  用不到序号表，按照名字来找才有意义</span><br></pre></td></tr></table></figure>





<p>定位数据目录的位置</p>
<p>pe标记往后数24（20+4）个字节 到达可选pe头，可选pe头往后数 224-128 = 96 个字节 （可选pe头– DataDirectory） = _IMAGE_DATA_DIRECTORY * 16 = 8*16</p>
<p>DataDirectory首地址= 可选pe头 + 96</p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221005201309769.png" alt="image-20221005201309769"></p>
<p>定位导出表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.找到可选pe头的最后一个成员 DataDirectory</span><br><span class="line">2.获取DataDirectory[0]</span><br><span class="line">3.通过DataDirectory[0].VirtualAddress 得到导出表的RVA</span><br><span class="line">4.将导出表的RVA转换为FOA，在文件中定位到导出表</span><br></pre></td></tr></table></figure>

<p>​    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numberOfFunctions = （编写dll时）最大序号-最小序号+1</span><br></pre></td></tr></table></figure>



<p>根据函数名称获取导出函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.根据导出表的函数名称去AddressOfNames指向的每个名称字符串查询是否有匹配的字符串</span><br><span class="line">2.找到匹配的字符串后，根据找到的顺序索引去AddressOfNameOrdinals中找到对应的索引</span><br><span class="line">3.根据前面找到的Ordinals到 AddressOfFunctions中获取函数地址</span><br></pre></td></tr></table></figure>



<p>根据函数序号获取导出函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.根据函数序号 - 导出表.base 获得导出函数的Ordinal</span><br><span class="line">2.根据前面找到的Ordinals到 AddressOfFunctions中获取函数地址</span><br></pre></td></tr></table></figure>



<p>总结</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">导出表中包含了3张小表：导出函数地址表，导出函数名称表，导出函数序号表</span><br><span class="line">导出表存储了这3张表地址的指针，而不是直接存储表的内容</span><br><span class="line">序号表并不是真正存储序号的表，只是用来给name中转的表</span><br></pre></td></tr></table></figure>





<h2 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h2><p>绝大多数dll中，exe基本没有重定位表</p>
<p>数据目录项的第6个结构是重定位表</p>
<p>重定位表的结构是按照块来的</p>
<p>一堆需要修改的放在一个块中</p>
<p>如下图，只有高4位 为 0011 这个值才需要修改，后面的低12位+前面的x(VirtualAddress)</p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221006155541354.png" alt="image-20221006155541354"></p>
<p>每一块有多少个需要修改的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(SizeofBlock - 8) /2</span><br></pre></td></tr></table></figure>

<p>定位重定位表的流程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.找到可选pe头的最后一个成员 DataDirectory</span><br><span class="line">2.获取DataDirectory[5]</span><br><span class="line">3.通过DataDirectory[5].VirtuallAddress 得到重定位表的RVA</span><br><span class="line">4.转换FOA，在文件中定位到重定位表</span><br></pre></td></tr></table></figure>





<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221006175628766.png" alt="image-20221006175628766"></p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221006175745262.png" alt="image-20221006175745262"></p>
<p>重定位表块中的SizeOfBlock后面的数据部分是用来作为偏移使用的，每一个数据项的大小为WORD，两字节，只有后面12位是用来表示偏移的，高4位用来判定该地址是否需要偏移。这里为什么只有12位用来表示偏移呢？因为重定位表是根据物理内存来设计的，物理内存是以4kb = 2^12 为单位，也就是4kb为一个物理页，所以只需要12位就可以表示一个物理页内的所有偏移。</p>
<p>高4位为0的话，表示该数据为对齐用的填充的垃圾数据，不需要重定位</p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221007101925829.png" alt="image-20221007101925829"></p>
<h2 id="移动导出表–重定位表"><a href="#移动导出表–重定位表" class="headerlink" title="移动导出表–重定位表"></a>移动导出表–重定位表</h2><p>为什么要移动这些表：</p>
<p>是对程序加密/破解的基础</p>
<p>移动导出表步骤</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.在dll中新增一个节，并返回新增节后的FOA</span><br><span class="line">2.复制AddressOfFunctions</span><br><span class="line">  长度： 4*NumberofFunctions</span><br><span class="line">3.复制AddressofNameOrdinals</span><br><span class="line">  长度：2*NumberOfNames</span><br><span class="line">4.复制AddressOfNames</span><br><span class="line">  长度：4*NumberOfNames</span><br><span class="line">  </span><br><span class="line"> 移动函数名字</span><br><span class="line">5.复制所有的函数名</span><br><span class="line">  长度不确定，复制时直接修复AddressOfNames</span><br><span class="line">6.复制IMAGE_EXPORT_DIRECTORY结构</span><br><span class="line">7.修复IMAGE_EXPORT_DIRECTORY 结构中的</span><br><span class="line">  AddressOfFunctions</span><br><span class="line">  AddressOfNameOrdinals</span><br><span class="line">  </span><br><span class="line">8.修复目录项的值，指向新的IMAGE_EXPORT_DIRECTORY</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221007124323902.png" alt="image-20221007124323902"></p>
<p>移动重定位表步骤</p>
<p>tip: DATA_DIRECTORY 里面的值不能修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.首先移动重定位表</span><br><span class="line">2.修改重定位表结构指向移动后的重定位的位置</span><br><span class="line">3.手动imagebase自增1000</span><br><span class="line">4.最后修复重定位表</span><br></pre></td></tr></table></figure>









<h2 id="IAT表"><a href="#IAT表" class="headerlink" title="IAT表"></a>IAT表</h2><p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221008133831339.png" alt="image-20221008133831339"></p>
<p>运行时：</p>
<p>call     4070bc  ： [77d5050b]       user32.dll -&gt; messagebox</p>
<p>运行前：</p>
<p>call    4070bc:     [7604]   —&gt;messagebox的字符串</p>
<p>因为重定位表的关系，call后面的地址不能写死，所以调用dll的时候，call后面都是跟的地址，而不是写死的函数值</p>
<h2 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h2><p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221008133346306.png" alt="image-20221008133346306"></p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221008134133377.png" alt="image-20221008134133377"></p>
<p>导入表两个重要的结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OriginalFirstThunk       //RVA   指向IMAGE_THUNK_DATA结构数组    INT表</span><br><span class="line">FIrstThunk				//RVA   指向IMAGE_THUNK_DATA结构数组		IAT表</span><br></pre></td></tr></table></figure>



<p>导入表中的FirstThunk 属性 指向IAT表</p>
<p>pe文件加载前：</p>
<p>INT表和IAT表中存储的值是一样的，可能是存储函数名称  或者函数序号</p>
<p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210408162001903.png" alt="image-20210408162001903"></p>
<p>pe文件加载后：</p>
<p>IAT表中存储函数地址</p>
<p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210408162937094.png" alt="image-20210408162937094"></p>
<p>在pe加载的时候，系统会调用GetProcessAddress(), 循环遍历INT表，添加到IAT表的对应地址</p>
<p>INT表和IAT表在文件中是一样的（没有绑定导入表的情况下）</p>
<p>导出表只有一个，但是导入表可能有多个</p>
<p>定位导入表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.DATADirectory 中的第二个是导入表</span><br><span class="line">2.通过DataDirectory[1].VirtualAddress得到导入表的RVA</span><br><span class="line">3.得到  IMAGE_IMPORT_DESSRIPTOR</span><br><span class="line">4.遍历FirstThunk， IMAGE_THUNK_DATA32  是一个联合体，把它当成DWORD型。判断最高位是否为1，如果是，那么除去最高位的值就是函数的到处序号。如果不是，那么这个值是一个RVA，指向IMAGE_IMPORT_BY_NAME   </span><br></pre></td></tr></table></figure>



<p>imagebase 就是程序加载到模块中的句柄</p>
<p>需要根据导入表去找函数地址</p>
<h2 id="绑定导入表"><a href="#绑定导入表" class="headerlink" title="绑定导入表"></a>绑定导入表</h2><p>如果导入表的时间戳(TimeDateStamp)为0，代表这个dll的函数地址还没绑定</p>
<p>如果时间戳为 –1（FFFFFFFF），代表dll的函数已经绑定</p>
<p>绑定导入表位于数据目录的第12项</p>
<p>当IMAGE_BOUND_IMPORT_DESCRIPTOR 结构中的TimeDateStamp 与dll文件标准pe头中的TimeDateStamp值不相符时，或者dll需要重定位时，会重新计算IAT中的值</p>

  </div>
</article>

    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <div id="vcomments" class="blog-post-comments"></div>
    <script>
        new Valine({
            el: '#vcomments',
            visitor: true,
            appId: '7u7uebjtVAc7zqC8W6KLczVp-gzGzoHsz',
            appKey: 'MWpJPixdx6qnP8OBPnTR7Yd9',
            placeholder: '',
            avatar: 'mp'
        })
    </script>






        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/categories/">Categories</a></li>
         
          <li><a href="/links">Links</a></li>
         
          <li><a href="/atom.xml">RSS</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#PE%E5%A4%B4%E8%A7%A3%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">PE头解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dos%E5%A4%B4"><span class="toc-number">1.0.1.</span> <span class="toc-text">dos头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NT-headers"><span class="toc-number">1.0.2.</span> <span class="toc-text">NT_headers</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Image-File-Header-%E6%A0%87%E5%87%86PE%E5%A4%B4"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">Image_File_Header (标准PE头)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Image-Optional-Header-%E5%8F%AF%E9%80%89pe%E5%A4%B4"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">Image_Optional_Header(可选pe头)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">节表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FileBuffer-%E2%80%93-gt-ImageBuffer"><span class="toc-number">3.</span> <span class="toc-text">FileBuffer –&gt; ImageBuffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%8A%82%E7%A9%BA%E7%99%BD%E5%8C%BA%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81"><span class="toc-number">4.</span> <span class="toc-text">代码节空白区添加代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E6%93%8D"><span class="toc-number">4.0.0.1.</span> <span class="toc-text">实操</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E7%A9%BA%E7%99%BD%E5%8C%BA%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81"><span class="toc-number">5.</span> <span class="toc-text">任意代码空白区添加代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E8%8A%82-%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81"><span class="toc-number">6.</span> <span class="toc-text">新增节-添加代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%A4%A7%E8%8A%82%E2%80%93%E5%90%88%E5%B9%B6%E8%8A%82%E2%80%93%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95"><span class="toc-number">7.</span> <span class="toc-text">扩大节–合并节–数据目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E2%80%93%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93"><span class="toc-number">8.</span> <span class="toc-text">静态链接库–动态链接库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8dll"><span class="toc-number">8.1.</span> <span class="toc-text">使用dll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E8%A2%AB%E7%9B%B4%E6%8E%A5%E5%88%86%E6%9E%90%E5%88%B0dll%E5%87%BD%E6%95%B0"><span class="toc-number">8.2.</span> <span class="toc-text">避免被直接分析到dll函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E8%A1%A8"><span class="toc-number">9.</span> <span class="toc-text">导出表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8"><span class="toc-number">10.</span> <span class="toc-text">重定位表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E5%AF%BC%E5%87%BA%E8%A1%A8%E2%80%93%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8"><span class="toc-number">11.</span> <span class="toc-text">移动导出表–重定位表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IAT%E8%A1%A8"><span class="toc-number">12.</span> <span class="toc-text">IAT表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E8%A1%A8"><span class="toc-number">13.</span> <span class="toc-text">导入表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E5%AF%BC%E5%85%A5%E8%A1%A8"><span class="toc-number">14.</span> <span class="toc-text">绑定导入表</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/&text=pe解析"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/&title=pe解析"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/&is_video=false&description=pe解析"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=pe解析&body=Check out this article: https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/&title=pe解析"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/&title=pe解析"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/&title=pe解析"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/&title=pe解析"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/&name=pe解析&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://0range-x.github.io/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/&t=pe解析"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2022
    0r@nge
  </div>
  
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
</footer>

    </div>

    

    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-86660611-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-86660611-1');
    </script>

<!-- Baidu Analytics -->

  <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?2e6da3c375c8a87f5b664cea6d4cb29c";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
        </script>

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
